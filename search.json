[{"title":"太崆动漫-游戏客户端","url":"/2024/02/07/太崆动漫-游戏客户端/","content":"\n一家动漫公司，好像是去年开的游戏业务，做的是一款上线 steam 的 3d rpg 游戏。\n\n### 一面(1h)\n1. 写出你知道的生命周期函数和使用场景\n\n+ Awake(): 对象被实例化之后调用，不论对象是否处于 Active 状态且脚本是否被激活，只调用一次，用于进行变量的初始化工作\n+ OnEnable(): 在 Awake() 之后调用，每一次脚本被激活就会调用一次，通常用在一个GameObject会被取消激活并且每次激活都要进行初始化等操作时，且在里面初始化的东西可以在热重载中保留。与之相对的还有 OnDisEnable() \n+ Start(): 在 Awake() 和 OnEnable() 之后调用，要求对象被设置为Active且脚本被激活，只调用一次\n+ Update(): 在Start之后调用, 需要对象被设置为Active以及脚本被激活, 每次渲染(一帧)调用一次，用于改变状态\n+ LateUpdate(): 在每一帧渲染之后调用, 如果有多个脚本，则会在执行完所有脚本的 Update 之后才会调用, 常常用来处理摄像机跟随、相机控制和其他需要在对象位置被更新后执行的任务\n+ FixedUpdate(): 和 Update() 类似，但是是间隔固定的时间步长调用一次，适用于不想受到帧率波动影响的操作\n\n2. 给了两个 C# 代码，问输出\n\n> 这个题当时答错了，主要是考第一帧的时候，会不会调用 Start 的问题，注意空引用\n\n3. 层级检测\n\n位运算\n\n4. 设计题, 如何检测 3d 人物前方半径为 5、张角为 120 度范围内的敌人，给出伪代码，详细到 api 即可。\n\n直接用球形碰撞检测，然后获取到每一个敌人的位置，再利用两个向量判断是否在指定区域内\n\n5. 射线检测，忘了题目是啥\n\n6. ugui 题\n\n7. ugui 题\n\nugui 用的不多，不怎么熟，乱答的\n\n8. 设计题，由同一个 prefab 实例化出来的小球，发生碰撞后发出声音，需要添加哪些组件，以及如何实现\n\n首先要进行碰撞检测，要发生碰撞，要求两个小球都有 Collider 组件，至少有一个有 Rigidbody 刚体组件，发生碰撞后会返回一个回调函数(OnCollisionEnter), 检测到碰撞之后发出声音，使用 AudioSource 播放 AudioClip 。\n\n9. 第八题的扩展\n    (a). 如果两个小球, 要求只能发出一个声音如何解决\n    (b). 有成千上万个小球，每两个小球碰撞都发出一次声音。\n\n(a). 只给其中一个小球添加声音组件\n(b). 因为有很多小球实例，可以直接给预制件添加组件或者使用 [RequireComponent] 自动给小球添加组件，又因为同一时刻只能发出一次声音，所以考虑创建一个 int 变量维护小球当前时刻发生了多少次碰撞，考虑对这个数据进行数据重用，数据重用有两种方案，首先是使用静态变量进行全局访问，其次是使用单例模式，只创建一个实例进行维护。\n\n10. 设计题，3d 人物，设计移动残影，并给出性能分析\n\n没遇到过，想了一个暴力方法，序列化一个 count 变量固定残影的数量，然后维护一个 Vector3[] , 然后每次更新都将当前人物的位置加入到数组中，类似于滑动窗口的方式来固定维护，然后每次更新就对这个数组里的每个位置都显示人物，因为是残影，可以考虑从后往前降低 alpha 通道的值来使得人物变得逐渐透明，又因为考虑到更新速度太快可能会导致残影效果不明显，所以还可以序列化一个 deltaTime 变量，只有当当前的 FixedUpdate 方法与上一次记录位置的 FixedUpdate 的间隔时间达到 deltaTime 之后才记录新的残影位置(Update 的话可以考虑维护帧数量，但是这样会受到帧率波动的影响)。\n\n### 二面(1.5h)\n全程拷打项目，直接打开项目让你讲，然后讲的过程中对针对你的设计进行一些提问，问你为什么这么做以及有没有更好的办法。开始的时候很紧张说不出来，好在面试官很好，对引导性地进行提示，后面就顺很多了。\n\n### oc\n最后接了这个 off，一方面是主程感觉人很好，面试的时候学到了很多东西，印象分加了很多。另一方面是下学期还有课，可能偶尔还得回一下学校，这个公司正好在武汉，方便一点。还有一点原因是听说这家公司的几个创始人是以前迪士尼的，参与了疯狂动物城、冰雪奇缘、超能陆战队等动漫的制作(我以前很喜欢疯狂动物城)，所以比较好奇，想去看看。\n\n目前的打算是边在这里实习，等三月份开始投暑期实习，下一站想去上海或者深圳。"},{"title":"柠檬微趣-游戏客户端-笔试","url":"/2024/02/07/柠檬微趣-游戏客户端-笔试/","content":"\n1. 两两翻转链表节点(lc24)\n\n2. 有如下约定:\n    + \"abc\" 是好串\n    + 设 s 是好串，且 s = X+Y ，其中 X 和 Y 可以是空串，则称 X+\"abc\"+Y 也是好串\n\n给定一个字符串，判断该串是不是好串\n\n3. 给定一个数组和一个正整数 n ，如果有 $x\\bmod n = y\\bmod n$ 则称 $x$ 和 $y$ 同余，并称 $x+y$ 为该同余组的值，求出所有同余组里值最大的那一组，要求: 不能使用取模运算符\n\n4. 正则表达式，给定一个待匹配字符串和模式串，询问是否匹配，其中模式串只会出现以下字符:\n    + 字母\n    + '.' 可以匹配任意单一字符\n    + '*' 可以匹配任意次前一个字符，可以为0次\n    + '?' 可以匹配任意次前一个字符，至少为1次\n\n","tags":["面经"]},{"title":"UnityGenshin项目总结","url":"/2024/02/02/UnityGenshin项目总结/","content":"\n`new input system` 插件的使用可以归纳为两个步骤\n1. 创建行为资产(Input Action Assets), 绑定输入控件\n2. 编写自定义脚本, 定义用于响应输入事件的回调函数\n \n## 摄像机系统\n摄像机系统是根据 `Cinemachine` 插件来进行制作的, 先创建了一个虚拟相机命名为  \"PlayerCamera\" , 然后因为相机需要一个 `Follow` 和 `LookAt` 目标, `Follow` 用来作为相机跟随的目标, `LookAt` 来作为相机的朝向, 这里给角色创建一个空物体 \"CameraLookPoint\" 来作为相机的 `LookAt` 和 `Follow` 的目标, 然后是使用 `CameraZoom.cs` 来控制摄像机的变焦。主要就是设置一个默认距离、最小距离和最大距离, 然后获取到摄像机的引用之后, 计算出目标距离, 然后使用线性插值平滑地将当前摄像机的距离移动到目标距离去.\n<!-- ```csharp\nprivate void Zoom() {\n    float zoomValue = inputProvider.GetAxisValue(2) * zoomSensitivity; // 获取缩放值\n\n    currentTargetDistance = Mathf.Clamp(currentTargetDistance + zoomValue, minimumDistance, maximumDistance); // 更新目标距离并确保在 min/max 之间\n\n    float currentDistance = framingTransposer.m_CameraDistance;\n\n    if (currentDistance == currentTargetDistance) {\n        return;\n    }\n\n    float lerpedZoomValue = Mathf.Lerp(currentDistance, currentTargetDistance, smoothing * Time.deltaTime);\n\n    framingTransposer.m_CameraDistance = lerpedZoomValue;\n}\n``` -->\n\n## 动作系统\n要设计一个动作系统主要是考虑两个部分, 第一个部分就是要实现的不同动作, 项目的动作是可以分成两个方面的, 一方面是空中的动作, 包括跳跃(`Jump`)和下落(`Fall`) , 另一方面是在地面上的动作, 包括猛冲(`Dash`)和待机(`Idle`), 重着陆(`Hard Landing`)、轻着陆(`Light Landing`)、翻滚(`Rall`), 步行(`Walk`)、跑步(`Run`)和冲刺(`Dash`)。第二个部分就是要实现不同的动作之间的相互转换。\n\n首先要考虑设计不同的动作, 在 \"PlayerInputActions\" 窗口里绑定各个动作的输入控件, 比如\"Dash\" 绑定了 \"Left Shift\" 键和 \"Right Button(Mouse)\" 键。\n\n这里实现了一个玩家控制移动的状态机, 这个状态机将会处理所有玩家的移动, 首先定义一个接口 `IState`\n<!-- ```csharp\nusing UnityEngine;\n\nnamespace GenshinImpactMovementSystem {\n    public interface IState {\n        public void Enter(); // 进入状态时调用\n        public void Exit(); // 退出状态时调用\n        public void HandleInput(); // 处理输入, 用于检测和响应玩家的输入\n        public void Update(); // 更新状态时调用\n        public void PhysicsUpdate(); // 物理更新时调用\n        public void OnTriggerEnter(Collider collider); // 当状态碰撞器进入其他碰撞器时调用\n        public void OnTriggerExit(Collider collider); // 当状态碰撞器离开其他碰撞器时调用\n        public void OnAnimationEnterEvent(); // 响应动画进入事件\n        public void OnAnimationExitEvent(); // 响应动画退出事件\n        public void OnAnimationTransitionEvent(); // 处理状态的过渡\n    }\n}\n``` -->\n在接口中定义了状态需要的多个函数, 然后定义一个状态机的抽象基类 `StateMachine` 作为状态机的基础, 以一个 `IState` 接口为成员变量, 每次调用不同的方法都会委托给当前状态的相应方法进行处理。然后 `PlayerMovementStateMachine` 作为 `StateMachine` 的子类, 里面为每个状态创建了相应的实例, 以便于后续状态之间的转化. 除此之外, 还编写了一个 `PlayerMovementState` 类来实现了 `IState` 接口, 后续再针对不同的状态的话, 都从这个 `PlayerMovementState` 类继承过来, 这里的继承分为几步, 首先是定义 `PlayerGroundedState` 从 `PlayerMovementState` 继承过来, 然后再先根据状态的不同分别定义几个大类从 `PlayerGroundedState` 继承, 静止状态单独为一类, 猛冲状态也单独为一类, 从 `PlayerGroundedState` 继承, 然后着陆分为重着陆和轻着陆以及重着陆之后的翻滚, 这三种着陆姿势的场景分别是\n+ \"Light Landing\" 从一个小的高度坠落, 比如 \"Jumping\" 之后\n+ \"Hard Landing\" 从一个比较高的高度坠落\n+ \"Roll\" 从一个更高的地方坠落, 但是前提是按下了移动键\n\n因此先总的有一个着陆状态 `PlayerLandingState` 从 `PlayerGroundedState` 继承过来, 再对每一个单独的状态从着陆状态继承过去, 再之后是移动状态可以分为慢跑、快跑和步行, 总的定义一个 `PlayerMovingState` 完成继承过渡, 最后是停止行动, 停止之后状态又变成待机状态。\n\n这是动作系统的一个大致的架构, 然后继续分下去的话, 控制一个动作大概可以分为动画 Animation 和位置移动, 位置移动有几种方式, 要不然就直接修改人物 transform 组件的位置(Position), 要不然就自己计算速度和加速度, 然后每一次 `Update` 或者 `FixedUpdate` 时就根据速度和加速度的变化计算位置, 因为这里的人物挂了刚体(Rigidbody) 组件, 所以一般就考虑 `Rigidbody.velocity` 直接更改它的速度, 或者是 `Rigidbody.addForce` , 给它添加力。这里实现基本上使用的是后者, 因为这样过渡更加自然。动画就只需要给人物添加一个 `Animator` 组件, 然后在资产文件夹下创建一个 `Animator Controller` , 因为本项目的动作不是很复杂, 所以只用到了可重用子状态机, 而没有用到混合树\n\n### IdlingState\n静止状态主要就是控制设置速度修正量设置为0, 以及刚体速度为 0 即可。\n\n### DashingState\n猛冲状态把地面冲刺数据中的速度修正为设定值, 然后设置相应的动画状态、跳跃力和旋转数据。\n\n### StoppingState\n主要有三个状态, `HardStoppingState` 、`LightStoppingState` 和 `MediumStoppingState` , 也是调用动画和添加不同的停止减速力。\n\n### LandingState\n启用着陆动画, 禁用移动、禁用玩家的移动输入并且重置玩家的速度, 然后等动画过渡事件发生后根据玩家输入切换不同的状态(静止、行走等)\n\n## 数据重用\n要实现数据重用的话一般就是使用静态变量或单例模式来实现\n+ 静态变量(Static Variables): 在脚本中声明一个静态变量, 并在需要重用数据的地方进行访问和修改。静态变量的值在整个应用程序中都是唯一的。\n+ 单例模式(Singleton Pattern): 单例模式可以确保只存在一个实例对象, 并且可以通过该实例访问和修改数据。这是一种更具封装性和可控性的方式。\n\n静态变量适用于简单的数据共享，而单例模式适用于需要更复杂操作和管理的情况。\n\n这里通过 `PlayerOS` 来保存大部分数据, 用 `PlayerStateReusableData` 来保存多个状态重复使用的数据。\n\n这里用到的是可编程对象(ScriptableObject), ScriptableObject 是一个可独立于类实例来保存大量数据的数据容器。它可以通过将数据存储在ScriptableObject对象中来减少工程以及游戏运行时因拷贝值所造成的内存占用。这里需要存储很多数据, 比如当前是否需要旋转、是否处于冲刺状态、当前的移动速度、前进方向等等。"},{"title":"LeetCode-Hot-100-链表","url":"/2024/01/31/LeetCode-Hot-100-链表/","content":"\n## 160. 相交链表\n### 题目描述\n给定两个单链表的头节点 `headA` 和 `headB` , 请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点则返回空.\n+ 数据保证整个链式结构中不存在环\n+ 函数返回结果后, 链表必须保持其原始结构\n+ 进阶考虑: 设计时间复杂度 `O(m + n)` , 空间复杂度 `O(1)` 的解决方案.\n\n### Solution\n考虑双指针 `pA-pB`, 不妨考虑链表 $A$ 有 $m$ 个节点, 记为 $1\\sim m$ , 链表 $B$ 有 $n$ 个节点, 记为 $1\\sim n$ \n1. 相交, 相交位置对于 $A$ 来说为 $a$ , 对 $B$ 来说是 $b$ , 则 $A$ 有 $a - 1$ 个不相交节点, $m - a + 1$ 个相交节点, $B$ 有 $b - 1$ 个不相交节点, 有 $n - b + 1$ 个相交节点. 又知道相交部分节点数量应该相同, 即 $m - a + 1 = n - b + 1$ , 整理得 $m + b = n + a$ , 左式的含义就是: `pA` 先走完链表 $A$ , 再从链表 $B$ 走到相交节点. 右式的含义是: `pB` 先走完链表 $B$ , 再从链表 $A$ 走到相交节点.\n2. 不相交, 先考虑 $m = n$ , 则会第一遍同时走到末尾同时为空指针. 再考虑 $m\\ne n$ , `pA` 先走完链表 $A$ 再走完链表 $B$ , `pB` 先走完链表 $B$ 再走完链表 $A$ , 还是会同时到达空指针.\n\n代码如下\n```cpp\n/* \n * language: C++\n * author: liuwx\n */\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *pA = headA;\n        ListNode *pB = headB;\n        while(pA != pB) {\n            pA = (pA == nullptr ? headB : pA->next);\n            pB = (pB == nullptr ? headA : pB->next);\n        }\n        return pA; \n    }\n};\n```\n\n```csharp\n/* \n * language: C#\n * author: liuwx\n */\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA;\n        ListNode pB = headB;\n        while(pA != pB) {\n            pA = (pA == null ? headB : pA.next);\n            pB = (pB == null ? headA : pB.next);\n        }\n        return pA;\n    }\n}\n```\n\n## 206. 反转链表\n### 题目描述\n给定单链表的头节点 `head` , 请你反转链表, 并返回反转后的链表. \n\n### Solution\n模拟即可\n```cpp\n/* \n * language: C++\n * author: liuwx\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev = nullptr;\n        while(head != nullptr) {\n            ListNode *nxt = head->next;\n            head->next = prev;\n            prev = head;\n            head = nxt;\n        }\n        return prev;\n    }\n};\n```\n\n```csharp\n/* \n * language: C#\n * author: liuwx\n */\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        ListNode prev = null;\n        while(head != null) {\n            ListNode nxt = head.next;\n            head.next = prev;\n            prev = head;\n            head = nxt;\n        }\n        return prev;\n    }\n}\n```\n\n## 234. 回文链表\n\n给定链表判断是否属于回文链表\n\n```cpp\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        std::vector<int> num;\n        while (head != nullptr) {\n            num.push_back(head->val);\n            head = head->next;\n        }\n        bool ok = true;\n        for (int i = 0, j = (int)num.size() - 1; i < j; i ++, j --) {\n            if(num[i] != num[j]) {\n                ok = false;\n                break;\n            }\n        }\n        return ok;\n    }\n};\n```\n\n### 141. 环形链表\n\n给定链表判断是否有环\n```cpp\nclass Solution {\nconst int value = 114514;\npublic:\n    bool hasCycle(ListNode *head) {\n        while(head != nullptr) {\n            if(head->val == value) return true;\n            head->val = value;\n            head = head->next;\n        }\n        return false;\n    }\n};\n```\n\n### ","tags":["Algorithm","LeetCode"]},{"title":"渲染流水线","url":"/2024/01/14/渲染流水线/","content":"\n## 渲染流水线\n\n渲染(Render)是指通过计算机程序将二维图像或者三维模型经过一系列计算工序处理为图像的过程。将输入的模型、图像按照流程依次处理再输出，因此实施渲染工作的程序也被成为**渲染流水线(Rendering Pipeline)**\n\n将一个点花到屏幕上，首先需要知道一个 **模型空间(Object Space)** 或者 **本地空间(Local Space)**，并且知道这个空间中顶点的坐标，然后计算出本地空间到**世界空间(World Space)** 的变换矩阵，就可以相应得到这个顶点在世界空间中的坐标，最后再得到由世界空间到**屏幕空间(Screen Space)** 的变换矩阵，就可以计算得到这个顶点的屏幕坐标了。\n\n一个世界中的点是否可以被画到屏幕上，使用 **视锥体(View Frustum)** 来实现，一种常见的视锥体有一个顶点(观察者的位置)和五个面，在视锥体内部的顶点都是可以被看到的点，而视锥体有两个参数，一个是棱锥张开的角度(即**视野**，**Field of View，FOV**)和最远视距。除此之外还可以添加一个最近视距来限制最近能看到什么，这时候视锥体也从棱锥变成棱台。\n\n以视锥体为参考系建立一个空间，将所有看不到的东西裁剪掉，这个空间就叫做**裁剪空间(Clip Space)**。\n\n整体的渲染流水线就可以整理为:\n**信息输入->模型空间->世界空间->裁剪空间->判断点是否能看到->将看得到的点转到屏幕空间->找出各个三角形->对三角形进行插值->根据插值结果涂色**\n\n以上就是CPU的渲染流程，即在一个CPU中分步骤地执行以上流程。为了提高效率，考虑GPU。CPU首先将数据传给GPU，然后GPU的各个计算单元分别元对这些数据进行简单的处理，最后组装出完整的图像。完整的处理的过程大致可以分为3个阶段，**应用结果**输出渲染图元，进入**几何阶段**输出屏幕空间的顶点信息，最后进入**光栅化阶段**。\n\n### 应用阶段(Application Stage)\n\n应用阶段主要由 CPU 负责，CPU 从 RAM 得到初始数据然后进行数据处理和剔除，然后将这些数据和如何处理的方式(着色器)丢给GPU\n\nCPU 将数据传递给 GPU 后还需要向 GPU 下达一个渲染指令，即**Draw call**。CPU向命令缓冲区放入一个个命令，然后由GPU以此取出，但是由于往往GPU的渲染速度超过了CPU提交命令的速度，因此就导致渲染中大部分时间都消耗在了 CPU 提交 Draw Call上，解决的方法是使用**批处理(Batching)**，即把要渲染的模型合并在一起提交给 GPU。\n\n### 几何阶段(Geometry Stage)\n\n几何阶段由GPU负责，主要就是渲染流水管线，以 OpenGL 为例就是\n\n**从应用阶段得到图元数据->顶点着色器->曲面细分着色器->几何着色器->投影->裁剪->屏幕映射**\n\n其中**顶点着色器**、**曲面细分着色器**、**几何着色器**都由开发者完整编程控制，**裁剪**部分开发者不能完全控制但是可以进行一些配置，**投影**和**屏幕映射**则已经由 GPU 固定实现。\n\n1. 顶点着色器: 每个顶点相互独立，计算单元不需要考虑其他顶点的状态。除此之外，GPU 还需要在这里进行**模型转化与相机转换(Model- & Camera transformation)** ，和之前「把模型从模型空间转移到世界空间」不一样的是，这里为了方便后续运算，还需要将顶点的空间由世界空间映射到摄像机的**观察空间**\n\n2. 曲面细分着色器: 在这里进行曲面细分操作，看起来就像在原有的图元内加入了更多的顶点。\n\n3. 几何着色器: 几何着色器与顶点着色器都可以对顶点的坐标进行修改，但是建议是除了顶点增、删这些仅仅能用几何着色器实现的效果，其余的顶点修改还是由顶点着色器完成，几何体着色器并行调用硬件困难，并行程度低，效率比顶点着色器低很多。\n\n4. 投影: 在这个阶段 GPU 将顶点从摄像机观察空间转换到裁剪空间，为之后的剔除过程以及投射到二维平面做准备。常见的投影方式有 **透视投影**(锥体，有远的地方看起来小的效果) 和 **正交投影**(方体，没有远的地方看起来小的效果) 。计算时需要考虑 **远裁剪平面(Far Clipping Plane)** 和 **近裁剪平面(Near Clipping Plane)** ，即摄像机最远看到的位置和最近看到的位置。透视投影需要额外考虑 **视野(FOV)** ，即视锥体张开的角度。而在正交投影中，因为是方体，远裁剪平面和近裁剪平面一样大，用裁剪平面的 **尺寸** 来表示它能看到的范围。\n\n5. 裁剪: 即将摄像机看不到的顶点剔除出去，然后再把顶点映射到屏幕空间，这里得到的 $x、y、z$ 要进行归一化，范围在 $[-1, 1]$ 之间，因为屏幕是 2 维空间，所以只需要 $x$ 和 $y$ 分量，而 $z$ 分量不会被丢弃，而是写入 **深度缓冲(Z-Buffer)** 之中。\n\n6. 屏幕映射: 经过裁剪后得到的 $x$ 和 $y$ 坐标在 $[-1,1]$ 之间，在这里进行映射到特定分辨率的屏幕上。\n\n### 光栅化阶段\n\n光栅化阶段可以分为以下步骤:\n\n**从几何阶段收集到的顶点信息->进行图元组装->三角形遍历->片元着色器->逐片元操作** \n\n1. 图元组装: 这个过程做的工作就是把顶点数据收集并组装为简单的基本体(线、点或三角形)\n\n2. 三角形遍历: 这个过程将检验屏幕上的某个像素是是否被一个三角形网格覆盖，被覆盖的区域将生成一个 **片元(Fragment)** ，一个像素是一个小正方形，显然像素不一定会被完全覆盖，有3种方案: **Standard Rasterization** (中心点被覆盖即被划入片元)、**Outer-conservative Rasterization** (只要覆盖到就划入片元)、**Inner-conservative Rasterization** (完全被覆盖才划入片元) 。一个片元包含了很多种状态的集合(屏幕坐标、深度、法线、纹理等)，GPU 还将对覆盖区域的每个像素的进行插值计算，因为只知道这个三角形片元的三个顶点的信息，中间部分的信息就通过插值得到。\n\n3. 片元着色器: 它将为每个片元计算颜色，除此之外还可以实现一些诸如法线贴图等效果，这里是对每一个片元进行操作的，每一个片元之间相互独立。\n\n4. 逐片元操作: 主要的工作有两个，对片元进行 **测试(Test)** 并进行 **合并(Merge)** 。测试步骤决定了片元最终会不会被显示出来，主要的测试步骤有 **透明度测试(Alpha Test)**、**模板测试(Stencil Test)**、**深度测试(Depth Test)** 。\n    + 透明度测试: 对片元的透明度值进行检测，仅仅允许透明度值达到设置的阈值后才可以会绘制。\n    + 深度测试: GPU 将读取片元的深度值(之前留下来的坐标 z 分量)与缓冲区的深度值进行比较。\n    + 模板测试: GPU 将读取片元的模板值与模板缓冲区的模板值进行比较，比较方式由程序员决定。","tags":["渲染"]},{"title":"Unity3D C#小汇总","url":"/2024/01/03/Unity3D-C-小汇总/","content":"\n## C-sharp\n\n1. 继承自 MonoBehaviour 才能作为游戏中的组件\n2. `[SerializeField]` 序列化: 帮助用户将[成员变量]在Inspector中显示, 并且自定义Serialize关系\n3. rotation 是返回世界坐标旋转四元数信息， localRotation 是返回本地旋转(围绕父)四元数信息\n4. Awake() 方法只在开始调用一次, Update() 方法每一帧渲染时都调用一次\n5. `Debug.Log(DateTime.Now);` 打印日志(当前时间)\n6. 定义变量时, 如果是在定义的时候同时赋值, 即可以推断出变量类型时可以用 var 代替数据类型(和 golang 类似)\n7. `[SerializeField, Range(10, 100)]` 这里的 `Range(10, 100)` 是让游戏内添加一个范围在10到100的滑块\n8. `Object.Instantiate` 方法用于实例化游戏对象, 因为我们的类继承了 MonoBehaviour , 所以间接继承了 Object(完整继承链是: MonoBehaviour - Behaviour - Component - Object)\n9. `Object.Instantiate` 方法还会返回一个对其创建内容的引用, 可以使用 `Transform point = Instantiate(pointPrefab);` 来获取位置\n10. `Prefab` 是预制件, 只需要把游戏对象拖到 Assets 里就行, 即可以重复使用, 而且只需要修改预制件, 游戏内所有的实例对象都会修改, 可以用来做比如说 树、草之类的东西\n11. Vector3 是 Unity 中表示三维向量的结构体，用于表示在三维空间中的位置、方向或缩放。它包含三个浮点数成员：x、y 和 z\n    + 构造函数：Vector3(x, y, z)： 通过给定的 x、y 和 z 值创建一个新的 Vector3\n    + 静态属性:\n        (1).Vector3.zero： 表示零向量 (0, 0, 0)\n        (2).Vector3.one： 表示全一向量 (1, 1, 1)\n        (3).Vector3.up： 表示单位向量指向正Y轴方向\n        (4).Vector3.down： 表示单位向量指向负Y轴方向\n        (5).Vector3.forward： 表示单位向量指向正Z轴方向\n        (6).Vector3.back： 表示单位向量指向负Z轴方向\n        (7).Vector3.right： 表示单位向量指向正X轴方向\n        (8).Vector3.left： 表示单位向量指向负X轴方向\n    + 常用方法:\n        (1).Vector3.Normalize()： 将向量转化为单位向量，即长度为 1\n        (2).Vector3.magnitude： 返回向量的长度(模)\n        (3).Vector3.sqrMagnitude： 返回向量长度的平方，用于比较向量的大小而无需进行平方根运算，提高性能\n        (4).Vector3.Distance(a, b)： 返回两个点之间的距离\n        (5).Vector3.Dot(a, b)： 返回两个向量的点积\n        (6).Vector3.Cross(a, b)： 返回两个向量的叉积\n    + 运算符重载:\n        (1).+、-、*、/： 支持向量之间的常规数学运算\n        (2).==、!=： 用于比较两个向量是否相等\n\n12. localPosition 是 Transform 类的一个属性, 用于表示游戏对象在其父级坐标系中的位置。换句话说, localPosition 描述了一个对象相对于其父对象的位置。在三维空间中，localPosition 是一个 Vector3 类型的属性, 与之相对应的是 position 属性, 它表示对象在世界坐标系中的位置。如果没有父对象, localPosition 和 position 是相同的。但如果有父对象, 那么 position 将考虑到了所有父对象的变换, 而 localPosition 只考虑了直接的父对象的变换。\n13. localScale 是相对于父对象的缩放因子, 如果一个对象的 localScale 是 (2, 1, 0.5), 那么它相对于其父对象的尺寸在 X 轴上放大了两倍, 在 Y 轴上没有变化, 在 Z 轴上缩小了一半, 注意, localScale 会受到父对象变化的影响\n\n14. Awake方法在对象被实例化之后就调用，不管对象是否被设置为Active以及脚本是否被激活，只调用一次; Start方法在Awake方法调用完毕之后调用，但是必须要求对象被设置为Active且脚本被激活，只调用一次; Update方法在Start之后调用，需要对象被设置为Active以及脚本被激活，每次渲染(一帧)调用一次; OnEnable 方法在 Awake 和 Start 之后调用，是每一次脚本激活时调用，通常用在一个GameObject会被取消激活并且每次激活都要进行初始化等操作时，还有就是在Awake里初始化的东西无法在热重载中保留，但是OnEnable里初始化的东西可以在热重载里保留，与之对应的还有OnDisEnable方法在每次脚本取消激活时调用\n\n15. 两个碰撞体(Collider)发生碰撞(Collision)，且至少有其中的一个游戏对象附加了刚体(Rigibody)，会向它们附加的对象发射三条碰撞信息\n    + `void OnCollisionEnter(Collision collision)`: 两个碰撞体刚发生碰撞时，只会调用一次\n    + `void OnCollisionStay(Collision collision)`: 两个碰撞体持续保持接触状态时，会一直调用，直到两个物体没有碰撞后才会停止\n    + `void OnCollisionExit(Collision collision)`: 两个碰撞体停止互相接触时，只会调用一次\n\n16. 碰撞器和触发器的区别: 碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性，当 `Is Trigger = false` 时，同样会收到三条触发消息 `OnCollisionEnter/Stay/Exit` 分别是当碰撞体进入到触发器时、当碰撞体和触发器有重叠区域时、当碰撞体离开触发器时，当 `Is Trigger = true` 时，碰撞器会被物理引擎忽略，没有碰撞效果。\n\n17. `FixedUpdate` 和 `Update` 之间的区别在于，前者间隔固定的时间步长调用一次，而后者每一帧调用一次，会受到帧速率的影响。通常，因为Unity内置的物理引擎(NVIDIA的PhysX物理仿真引擎)是隔固定时间计算一次，所以一般在需要对物理游戏对象计算比如速度之类的属性时，也会使用 `FixedUpdate` 。\n\n18. `RequireComponent` 是一个属性标签，如\n```csharp\nusing UnityEngine;\n\n[RequireComponent(typeof(Camera))]\npublic class OrbitCamera : MonoBehaviour {}\n```\n作用是该脚本所附加的游戏对象必须具有指定类型的组件，否则Unity会自动添加该组件\n\n19. `LateUpdate` 是一个特殊的生命周期方法，与 `Update` 不同，它在每一帧渲染之后调用，假如有多个脚本，则会在执行完所有脚本的 `Update` 之后才会调用 `LateUpdate` ，常常用来处理摄像机跟随、相机控制和其他需要在对象位置被更新后执行的任务，因为相机跟随角色时，一般是等角色移动好了，再把相机移动过去。\n\n20. `Vector3.Lerp(Vector3 a, Vector3 b, float t)` 是通过按照线性比例在 a 和 b 之间插值得到一个新的 Vector3，返回 $a+(b-a)\\times t$ ，在一定时间内实现在一个点到另一个点的平滑过渡，可以用来实现相机跟随玩家物体移动效果\n```csharp\nusing UnityEngine;\n    \n// 属性标签，作用是该脚本所附加的游戏对象必须具有指定类型的组件，否则Unity会自动添加该组件    \n[RequireComponent(typeof(Camera))]\npublic class OrbitCamera : MonoBehaviour {\n    [SerializeField] private Transform focus = default; // 相机聚焦的位置\n    [SerializeField, Range(1f, 20f)] private float distance = 5f; // 相机距离聚焦点的距离\n    [SerializeField, Min(0f)] private float focusRadius = 1f; // 只有当新的位置超出范围时才改变相机位置\n    private Vector3 focusPoint;\n    void Awake() {\n        focusPoint = focus.position;\n    }\n    void LateUpdate() {\n        UpdateFocusPoint();\n        Vector3 lookDirection = transform.forward; // 当前轨道相机的视线方向(单位向量)\n        transform.localPosition = focusPoint - lookDirection * distance; // 相机新的坐标\n    }\n    void UpdateFocusPoint() {\n        Vector3 targetPoint = focus.position;\n        if (focusRadius > 0f) {\n            float currentDistance = Vector3.Distance(targetPoint, focusPoint);\n            if (currentDistance > focusRadius) {\n                focusPoint = Vector3.Lerp(targetPoint, focusPoint, focusRadius / currentDistance); // 插值，实现平滑过渡\n            }\n        }\n        else {\n            focusPoint = targetPoint;\n        }\n    }\n}\n```\n相应的还有 `Color.Lerp()` 、`Mathf.Lerp()` ，它们的原理都大致相同，只是该变的值类型不同\n\n21. `Time.unscaledDeltaTime` 在正常情况下和 `Time.deltaTime` 没区别，都是计算两帧之间的间隔时间，但是后者会受到 `Time.timeScale` 的影响，`Time.timeScale` 属性用于控制游戏世界的时间流速，默认为 1, 如果设置为2，则是两倍速，以此类推。必须大于等于0且小于100。但是 `Time.unscaledDeltaTime` 不会受到 `Time.timeScale` 的影响。\n\n22. camera 的方向由两个轨道角控制，`X` 角定义其垂直方向，0表示直视地平线，90表示向下看，`Y` 角定义其水平方向，和 `Z` 坐标轴之间的角度\n\n23. 自制的轨道摄像机不穿墙/物体的话，可以使用 box cast，匹配到世界空间中相机的近平面矩阵\n\n24. Unity里给一个游戏对象添加一个Animation来移动它的位置，在脚本里这个对象的速度为0,需要通过跟踪其位置来自己推断出连接速度。\n\n25. `Transform.InverseTransformPoint(Vector3 B)` 将世界坐标转化为当前物体下的相对坐标，`Transform.TransformPoint()`相反。\n\n26. 射线检测: https://dullsword.github.io/2020/05/13/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/\n\n27. 要在类外访问类内的元素，一个方法是将变量声明为 `public` ，另一个办法是使用 **属性Property** ，属性是一个特殊的成员函数，包含了 `set` 和 `get` 访问器，**属性不分配内存**，可以使用 `public int Health {get; set;}` 这样的方式简写\n```csharp\n// Player.cs\nusing UnityEngine;\nusing System.Collections;\n\npublic class Player {\n    // 外部不可直接访问的成员变量(字段)\n    private int experience;\n\n    // 属性 开头大写\n    public int Experience {\n        get {\n            return experience; // 还可以有其他的代码\n        }\n        set {\n            experience = value;\n        }\n    }\n    public int Level {\n        get {\n            return experience / 1000;\n        }\n        set {\n            experience = value * 1000;\n        }\n    }\n    public int Health{ get; set;}\n}\n\n/*---------------*/\n// Game.cs\nusing UnityEngine;\nusing System.Collections;\n\npublic class Game : MonoBehaviour \n{\n    void Start () \n    {\n        Player myPlayer = new Player();\n\n        //属性可以像变量一样使用\n        myPlayer.Experience = 5;\n        int x = myPlayer.Experience;\n    }\n}\n```\n\n28. C# 也有**泛型**，类似于 C++，泛型有助于最大限度地重用代码、保护类型的安全以及提高性能。\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nnamespace GenericMethodAppl {\n    class Program {\n        static void Swap<T>(ref T lhs, ref T rhs) {\n            T temp;\n            temp = lhs;\n            lhs = rhs;\n            rhs = temp;\n        }\n        static void Main(string[] args) {\n            int a, b;\n            char c, d;\n            a = 10;\n            b = 20;\n            c = 'I';\n            d = 'V';\n\n            // 在交换之前显示值\n            Console.WriteLine(\"Int values before calling swap:\");\n            Console.WriteLine(\"a = {0}, b = {1}\", a, b);\n            Console.WriteLine(\"Char values before calling swap:\");\n            Console.WriteLine(\"c = {0}, d = {1}\", c, d);\n\n            // 调用 swap\n            Swap<int>(ref a, ref b);\n            Swap<char>(ref c, ref d);\n\n            // 在交换之后显示值\n            Console.WriteLine(\"Int values after calling swap:\");\n            Console.WriteLine(\"a = {0}, b = {1}\", a, b);\n            Console.WriteLine(\"Char values after calling swap:\");\n            Console.WriteLine(\"c = {0}, d = {1}\", c, d);\n            Console.ReadKey();\n        }\n    }\n}\n/*\n * Int values before calling swap:\n * a = 10, b = 20\n * Char values before calling swap:\n * c = I, d = V\n * Int values after calling swap:\n * a = 20, b = 10\n * Char values after calling swap:\n * c = V, d = I \n */\n```\n\n29. **接口**使用 interface 关键字进行定义，可由方法、属性、事件、索引器或这四种成员类型的任意组合构成。接口类似于抽象基类，不能直接实例化接口；接口中的方法都是抽象方法，实现接口的任何非抽象类型都必须实现接口的所有成员。接口成员是自动公开的，且不能包含任何访问修饰符。注意，C# 只能继承一个类(不能多类继承)，但是可以有多个接口。使用方法是: `public class EnemyMove: MonoBehaviour, IDamage { }` (脚本名+分号+继承类+接口,接口,...)\n```csharp\nusing UnityEngine;\nusing System.Collections;\n\n// 这是只有一个必需方法的基本接口\npublic interface IKillable {\n    void Kill();\n}\n\n//这是一个通用接口，其中 T 是将由实现类提供的数据类型的占位符\npublic interface IDamageable<T> {\n    void Damage(T damageTaken);\n}\n\n/***************/\n// Avatar.cs\nusing UnityEngine;\nusing System.Collections;\n\npublic class Avatar : MonoBehaviour, IKillable, IDamageable<float> {\n    //IKillable 接口的必需方法\n    public void Kill() {\n        // ...\n    }\n\n    //IDamageable 接口的必需方法\n    public void Damage(float damageTaken) {\n        // ...\n    }\n}\n```\n\n30. **扩展方法**无需继承就可以改写类，让类中增加方法，比如 `trnasform` 类看不到源代码，想要给它添加一个其他方法就需要使用扩展方法，扩展方法定义为静态(static)，并且在变量里还需要添加 `this` 关键字。\n```csharp\nusing UnityEngine;\nusing System.Collections;\n\n// 创建一个包含所有扩展方法的类是很常见的做法。此类必须是静态类。\npublic static class ExtensionMethods {\n    // 扩展方法即使像普通方法一样使用，也必须声明为静态。请注意，第一个参数具有“this”关键字，后跟一个 Transform 变量。此变量表示扩展方法会成为那个类的一部分。\n    public static void ResetTransformation(this Transform trans) {\n        trans.position = Vector3.zero;\n        trans.localRotation = Quaternion.identity;\n        trans.localScale = new Vector3(1, 1, 1);\n    }\n}\n\n/***********/\n// test\n\nusing UnityEngine;\nusing System.Collections;\n\npublic class SomeClass : MonoBehaviour  {\n    void Start () {\n        transform.ResetTransformation();\n    }\n}\n```\n\n## 其他\n1. 在图形学里，我们用 $(x, y, z, 1)$ 表示点，用 $(x, y, z, 0)$ 表示向量，即用一个额外的分量来区分点和向量，这叫做齐次坐标系。这是通常的，但是由于经常做变换操作时会使得 $w$ 分量改变，因此只要 $w$ 为 0 就表示向量，不为0就表示点，如果要从齐次坐坐标得到3D坐标只需要将 $x、y、z$ 都除以 $w$ 即可。\n\n2. 正交投影和透视投影: 透视投影就是会有越远的地方看起来越小的效果，而正交投影则不会，正交投影映射出来的大小只和物体本身的相对大小有关而和远近无关。","tags":["Unity3D","C#"]},{"title":"xv6 Lab2: system calls","url":"/2023/12/02/xv6-Lab2-system-calls/","content":"\nLab: https://pdos.csail.mit.edu/6.S081/2022/labs/syscall.html\n\n> attention: 在你开始写代码之前，请阅读xv6手册《book-riscv-rev1》的第2章、第4章的第4.3节和第4.4节以及相关源代码文件：\n> 系统调用的用户空间代码在user/user.h和user/usys.pl中。\n内核空间代码是kernel/syscall.h、kernel/syscall.c。\n与进程相关的代码是kernel/proc.h和kernel/proc.c。\n\n### ","tags":["OS","mit6.s081","xv6 Lab"]},{"title":"MIT6.s081-Notes-2","url":"/2023/12/02/MIT6-s081-Notes-2/","content":"\n### OS Organization and System Calls\n\n#### 操作系统的隔离性(isolation)\n某种程度上来说, 使用操作系统的一个主要原因就是为了实现multiplexing(CPU在多进程同分时复用)和内存隔离。所以如果不适用操作系统, 并且让应用程序和硬件交互就很难实现这两点, 所以将操作系统设计成一个库并不是一个常见的设计, 或许在一些实时操作系统中可以看到这样的设计, 但那时因为在这些实时操作系统里应用程序之间彼此相互信任。但是在大部分操作系统中都会强制硬件资源的隔离。\n\n> 举几个例子: \n> 进程抽象了cpu。fork创建了进程, 进程本身不是cpu, 但是它们对应了cpu, 应用程序通过和进程交互来实现在cpu上的计算。同一个cpu核一次只能运行一个进程, 它是分时复用。\n> exec抽象了内存。当我们执行exec系统调用时, 会传入一个文件名, 而这个文件名对应了一个应用程序的内存镜像, 内存镜像里包括了程序对应的指令和全局的数据。应用程序可以逐渐扩展自己的内存, 但是应用程序并没有直接访问物理内存的权限。操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。exec是这样一种系统调用，它表明了应用程序不能直接访问物理内存。\n> files抽象了磁盘。应用程序不会直接读写挂在计算机上的磁盘本身，并且在Unix中这也是不被允许的。在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。\n\n> exec抽象内存是如何做到的?\n> chatgpt: 在操作系统中，exec 系统调用是用于在一个进程内执行一个新的程序的机制。它通过用一个新的程序替代当前进程的映像来实现。当一个进程调用 exec 系统调用时，操作系统会做以下主要步骤：\n> 1. 加载新程序的可执行文件：首先，操作系统会从磁盘加载新程序的可执行文件到内存中。这个文件通常包含了程序的机器码、数据段、代码段等信息。\n> 2. 创建新的内存映像：操作系统会为新的程序创建一个新的内存映像，这个内存映像将会包含新程序的代码、数据以及堆栈等区域。\n> 3. 清理原有资源：操作系统会关闭或释放原有程序所占用的资源，比如文件描述符、堆内存等。这确保了新程序不会受到旧程序的影响。\n> 4. 加载新程序的代码和数据：将新程序的机器码和数据从可执行文件加载到新的内存映像中。\n> 5. 初始化程序的环境：设置新程序的环境变量、命令行参数等信息。\n> 6. 跳转到新程序的入口点：通过设置程序计数器（PC）的值，将控制权转交给新程序的入口点，使其开始执行。\n> \n> 总的来说，exec 系统调用通过将新程序加载到内存中并初始化环境，然后跳转到新程序的入口点，实现了在当前进程内执行一个新程序的功能。这样做使得进程可以动态地切换执行不同的程序，从而实现了程序的多样性和灵活性。\n\n\n#### 操作系统的防御性(Defensive)\n强隔离需要应用程序和操作系统之间的硬边界，如果应用程序出错，我们不希望操作系统失败或其他应用程序失败，相反，操作系统应该能够清理失败的应用程序，并继续运行其他应用程序，要实现强隔离，操作系统必须保证应用程序不能修改（甚至读取）操作系统的数据结构和指令，以及应用程序不能访问其他进程的内存。\n\n通常来说，需要通过硬件来实现这的强隔离性。这里的硬件支持包括了两部分，第一部分是user/kernel mode，kernel mode在RISC-V中被称为Supervisor mode但是其实是同一个东西；第二部分是page table或者虚拟内存(Virtual Memory)。\n\n为了支持 user/kernel mode , 处理器会有两种操作模式, 第一种是 user mode, 第二种是 kernel mode。前者下CPU只能运行普通权限的指令(unprivileged instructions), 后者可以运行特定权限的指令(privileged instructions)。\n\n> 切换kernel mode需要特定权限, 如何做到的？\n\n虚拟内存则是每个进程都会有自己独立的 page table, 每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的page table中。\n> 就比如 ls 程序会有一个内存地址 0, echo 程序也会有一个内存地址 0, 但是操作系统会将两个程序的内存地址0映射到不同的物理内存地址，所以ls程序不能访问echo程序的内存，同样echo程序也不能访问ls程序的内存。\n\n我们可以认为user/kernel mode是分隔用户空间和内核空间的边界，用户空间运行的程序运行在user mode，内核空间的程序运行在kernel mode。操作系统位于内核空间。\n\n> 在内核空间(或管理模式)中运行的软件被称为内核。\n\n在RISC-V中, 有一个专门的指令让应用程序可以将控制权转移给内核(Entering Kernel), 叫做 `ECALL`\n\n> 举个例子, 当我们在用户空间的 Shell 执行 fork 指令时, 它并不是直接调用操作系统中对应的函数, 而是调用 ecall 指令, 指令的参数是代表了fork系统调用的数字。之后控制权到了syscall函数，syscall会实际调用fork系统调用。\n\n> 用户不能直接调用fork，用户的应用程序执行系统调用的唯一方法就是通过这里的ECALL指令。\n\n> 想要调用内核函数的应用程序（例如xv6中的read系统调用）必须过渡到内核。CPU提供一个特殊的指令，将CPU从用户模式切换到管理模式，并在内核指定的入口点进入内核（RISC-V为此提供ecall指令）。一旦CPU切换到管理模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝它或执行它。由内核控制转换到管理模式的入口点是很重要的；如果应用程序可以决定内核入口点， 那么恶意应用程序可以在跳过参数验证的地方进入内核。\n\n#### 宏内核 vs 微内核(Monolithic Kernel vs Micro Kernel)\n一个关键的设计问题是操作系统的哪些部分应该以管理模式运行。\n\n一种可能是整个操作系统都驻留在内核中，这样所有系统调用的实现都以管理模式运行。这种组织被称为**宏内核(monolithic kernel)**\n\n为了降低内核出错的风险，操作系统设计者可以最大限度地减少在管理模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。这种内核组织被称为**微内核(microkernel)**\n\n微内核是一种很好的设计。但是也有一些缺点。举个例子, Shell调用了exec, 必须有种方式可以接入到文件系统中, 通常来说, 这里的工作方式是, Shell 会通过内核中的IPC系统发送一条消息, 内核会查看这条消息并发现这是给文件系统发的消息, 之后内核会把消息发送给文件系统。文件系统完成工作后会向IPC系统回送一条消息表示exec系统调用后的结果, 之后IPC系统再将这条消息发送给Shell。和宏内核对比会多一次用户空间到内核空间的跳转, 所以导致**通常微内核性能更差**\n\n大部分Unix操作系统(例如xv6)都是宏内核。\n\n#### 内核编译过程\n首先, Makefile 会按顺序读取xv6目录下的所有 .c 文件, 然后调用 gcc 编译器, 生成一个 .s 文件, 这是 RISC-V 汇编语言文件, 然后再走到汇编解释器, 生成 .o 文件, 这是汇编语言的二进制格式。Makefile会为所有内核文件(.c)做相同的操作。之后, 系统加载器(Loader)会收集所有的 .o 文件, 将它们链接在一起, 并生成内核文件。这里生成的内核文件就是将在QEMU中运行的文件。","tags":["OS","mit6.s081"]},{"title":"xv6 Lab1: Xv6 and Unix utilities","url":"/2023/11/26/xv6-Lab1-Xv6-and-Unix-utilities/","content":"\nLab: https://pdos.csail.mit.edu/6.828/2022/labs/util.html\n\n实现一些基础的用户程序，帮助熟悉 xv6 操作系统以及它的系统接口，系统有如下接口:\n\n> C 程序中的命令行参数: `argc` 表示命令行参数数量, `char* argv[]` 用于接收命令行参数, 通常 `argv[0]` 表示程序名称, `argv[1]`以及往后表示命令行参数, 例如运行 `./sleep.c 10` , `argc` 就等于 2, `argv[0] = ./slepp.c` , `argv[1] = 10`.\n\n\n### sleep(easy)\n\n> Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c.\n\n首先查看 `user/echo.c` 如何实现，该命令用于将字符串输出，在 xv6 中实现如下\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main(int argc, char *argv[]) {\n  int i;\n\n  for(i = 1; i < argc; i++){\n    write(1, argv[i], strlen(argv[i]));\n    if(i + 1 < argc){\n      write(1, \" \", 1);\n    } else {\n      write(1, \"\\n\", 1);\n    }\n  }\n  exit(0);\n}\n```\n\n然后查看 `user/grep.c` 的实现\n```c\n// Simple grep.  Only supports ^ . * $ operators.\n\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nchar buf[1024];\nint match(char*, char*);\n\nvoid grep(char *pattern, int fd) {\n  int n, m;\n  char *p, *q;\n\n  m = 0;\n  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){\n    m += n;\n    buf[m] = '\\0';\n    p = buf;\n    while((q = strchr(p, '\\n')) != 0){\n      *q = 0;\n      if(match(pattern, p)){\n        *q = '\\n';\n        write(1, p, q+1 - p);\n      }\n      p = q+1;\n    }\n    if(m > 0){\n      m -= p - buf;\n      memmove(buf, p, m);\n    }\n  }\n}\n\nint main(int argc, char *argv[]) {\n  int fd, i;\n  char *pattern;\n\n  if(argc <= 1){\n    fprintf(2, \"usage: grep pattern [file ...]\\n\");\n    exit(1);\n  }\n  pattern = argv[1];\n\n  if(argc <= 2){\n    grep(pattern, 0);\n    exit(0);\n  }\n\n  for(i = 2; i < argc; i++){\n    if((fd = open(argv[i], 0)) < 0){\n      printf(\"grep: cannot open %s\\n\", argv[i]);\n      exit(1);\n    }\n    grep(pattern, fd);\n    close(fd);\n  }\n  exit(0);\n}\n\n// Regexp matcher from Kernighan & Pike,\n// The Practice of Programming, Chapter 9, or\n// https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\n\nint matchhere(char*, char*);\nint matchstar(int, char*, char*);\n\nint match(char *re, char *text) {\n  if(re[0] == '^')\n    return matchhere(re+1, text);\n  do {  // must look at empty string\n    if(matchhere(re, text))\n      return 1;\n  } while(*text++ != '\\0');\n  return 0;\n}\n\n// matchhere: search for re at beginning of text\nint matchhere(char *re, char *text) {\n  if(re[0] == '\\0')\n    return 1;\n  if(re[1] == '*')\n    return matchstar(re[0], re+2, text);\n  if(re[0] == '$' && re[1] == '\\0')\n    return *text == '\\0';\n  if(*text!='\\0' && (re[0]=='.' || re[0]==*text))\n    return matchhere(re+1, text+1);\n  return 0;\n}\n\n// matchstar: search for c*re at beginning of text\nint matchstar(int c, char *re, char *text) {\n  do{  // a * matches zero or more instances\n    if(matchhere(re, text))\n      return 1;\n  } while(*text!='\\0' && (*text++==c || c=='.'));\n  return 0;\n}\n```\n> 这是一个简单的 `grep` 的实现，仅支持四个简单的正则表达式运算符: `^`，`.`，`*`，`$`。它们的含义如下:\n> 1. `^`: 这个符号表示行的开始。如果一个正则表达式以`^`开头，那么它只会匹配那些以指定模式开始的文本。例如，`^abc` 会匹配所有以abc开始的行\n> 2. `.`: 这个符号表示任意单个字符。例如，`a.c` 可以匹配 abc，adc，a*c等\n> 3. `*`: 这个符号表示前面的元素可以重复任意次（包括零次）。例如，a*可以匹配空字符串，a，aa，aaa等。如果它跟在.后面（即`.*`），那么它可以匹配任意数量的任意字符。\n> 4. `$`: 这个符号表示行的结束。如果一个正则表达式以$结尾，那么它只会匹配那些以指定模式结束的文本。例如，abc$ 会匹配所有以abc结束的行。\n\n在这个程序中:\n1. `grep` 函数读取一个文件（由文件描述符fd指定），并查找与给定模式pattern匹配的行。它将每一行读入缓冲区buf，然后使用match函数检查这一行是否与模式匹配。如果匹配，它就将这一行写入标准输出。\n2. `match` 函数检查文本text是否与正则表达式re匹配。如果正则表达式以^开头，它就使用matchhere函数检查文本是否在开头处与剩余的正则表达式匹配。否则，它就在文本的每个位置尝试匹配整个正则表达式。\n3. `matchhere` 函数检查文本text是否在开头处与正则表达式re匹配。如果正则表达式的第二个字符是*，它就使用matchstar函数处理。否则，它就检查正则表达式的第一个字符是否与文本的第一个字符匹配，如果匹配，就在剩余的正则表达式和剩余的文本上递归调用自己。\n4. `matchstar` 函数处理带星号的正则表达式。星号表示前面的字符可以出现任意次数（包括零次）。它在文本的每个位置尝试匹配剩余的正则表达式，直到找到一个匹配的位置或者到达文本的末尾。\n\n然后查看 `user/rm.c` 实现:\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main(int argc, char *argv[]) {\n  int i;\n\n  if(argc < 2){\n    fprintf(2, \"Usage: rm files...\\n\");\n    exit(1);\n  }\n\n  for(i = 1; i < argc; i++){\n    if(unlink(argv[i]) < 0){\n      fprintf(2, \"rm: %s failed to delete\\n\", argv[i]);\n      break;\n    }\n  }\n\n  exit(0);\n}\n```\n> `unlink` 是一个系统调用，它从文件系统中删除一个文件的链接。如果文件的链接数减少到0，并且没有任何进程打开该文件，那么文件系统就会释放该文件的空间。如果unlink函数返回一个负值，那么就说明删除操作失败。\n\n最后根据上面几个例子可以实现 `sleep`\n\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main(int argc, char* argv[]) {\n    if(argc != 2) {\n        fprintf(2, \"sleep error\\n\");\n        exit(1);\n    }\n    int number = atoi(argv[1]);\n    sleep(number);\n    exit(0);\n}\n```\n\n测试成绩: `make GRADEFLAGS=sleep grade`\n\n### pingpong(easy)\n\n> Write a program that uses UNIX system calls to ''ping-pong'' a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print \"<pid>: received ping\", where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print \"<pid>: received pong\", and exit. Your solution should be in the file user/pingpong.c.\n\n代码如下:\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\n#define INDEX_READ 0\n#define INDEX_WRITE 1\n#define BUFFER_SIZE 16\n\nint main(int argc, char* argv[]) {\n    int fd1[2], fd2[2]; // 父->子，子->父\n    pipe(fd1);\n    pipe(fd2);\n    int pid;\n    pid = fork();\n    if(pid < 0) {\n        fprintf(2, \"fork failed\\n\");\n        exit(1);\n    } \n    if(pid == 0) {\n        // 子进程\n        /*\n         子进程接收一个来自父进程的字节然后打印 <pid>: received ping ，然后向父进程写一个字节\n         所以 fd1 只需要读，fd2 只需要写\n        */\n        close(fd1[INDEX_WRITE]);\n        close(fd2[INDEX_READ]);\n        char buf[BUFFER_SIZE];\n        if(read(fd1[INDEX_READ], buf, 1) == 1) {\n            fprintf(1, \"%d: received ping\\n\", getpid());\n        }\n        write(fd2[INDEX_WRITE], \"a\", 1);\n        close(fd2[INDEX_WRITE]); // 防止堵塞\n        exit(0);\n    } else {\n        // 父进程\n        /*\n         父进程向子进程发送一个字节，然后从子进程接收一个字节，然后打印 <pid>: received pong\n         所以 fd1 只需要写，fd2 只需要读\n        */\n        close(fd1[INDEX_READ]);\n        close(fd2[INDEX_WRITE]);\n        write(fd1[INDEX_WRITE], \"a\", 1);\n        close(fd1[INDEX_WRITE]); // 防止堵塞\n        char buf[BUFFER_SIZE];\n        if(read(fd2[INDEX_READ], buf, 1) == 1) {\n            fprintf(1, \"%d: received pong\\n\", getpid());\n        }\n    }\n    exit(0);\n}\n```\n\n### primes(moderate)/(hard)\n\n> Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c.\n> Your goal is to use pipe and fork to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.\n\n递归处理，维护左边的进程和下边的进程即可。需要注意管道的打开和关闭。\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\n#define STD_IN 0\n#define STD_OUT 1\n#define STD_ERR 2\n#define INDEX_READ 0\n#define INDEX_WRITE 1\n#define BUFFER_SIZE 16\n\nvoid prime(int fd[2]) {\n    // 子->孙\n    close(fd[INDEX_WRITE]);\n    int num;\n    if(read(fd[INDEX_READ], &num, sizeof(num)) == 0) {\n        close(fd[INDEX_READ]);\n        exit(0);\n    }\n    fprintf(STD_OUT, \"prime %d\\n\", num);\n    int p[2];\n    pipe(p);\n    if(fork() == 0) {\n        prime(p);\n    } else {\n        close(p[INDEX_READ]);\n        int now;\n        while(read(fd[INDEX_READ], &now, sizeof(now)) > 0) {\n            if(now % num != 0) {\n                write(p[INDEX_WRITE], &now, sizeof(now));\n            }\n        }\n        close(p[INDEX_WRITE]);\n        wait(0);\n    }\n    close(fd[INDEX_READ]);\n    exit(0);\n}\n\nint main(int argc, char* argv[]) {\n    int fd[2];\n    pipe(fd);\n    int pid = fork();\n    if(pid == 0) {\n        // 子进程\n        prime(fd);\n    } else {\n        // 父进程, 父->子，父写子读\n        close(fd[INDEX_READ]);\n        for(int i = 2; i <= 35; i ++) {\n            if(write(fd[INDEX_WRITE], &i, sizeof(i)) != sizeof(i)) {\n                fprintf(STD_ERR, \"write error(1)\\n\");\n                exit(1);\n            }\n        }\n        close(fd[INDEX_WRITE]);\n        wait(0);\n    }\n    exit(0);\n}\n```\n\n### find(moderate)\n\n> Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c.\n\n可以查看 `ls.c` 的实现: [刘刘大顺: xv6中对ls程序的实现(源码详细解析)](https://zhuanlan.zhihu.com/p/669012113) ，然后仿照完成即可。\n\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n\n#define STD_IN 0\n#define STD_OUT 1\n#define STD_ERR 2\n#define BUFFER_SIZE 16\n\nchar* fmtname(char *path) {\n    static char buf[DIRSIZ+1];\n    char *p;\n\n    // Find first character after last slash.\n    for(p=path+strlen(path); p >= path && *p != '/'; p--)\n        ;\n    p ++;\n    return p;\n}\n\nvoid find(char *dir, char* file) {\n    char buf[512], *p;\n    int fd;\n    struct dirent de;\n    struct stat st;\n\n    if((fd = open(dir, 0)) < 0){\n        fprintf(STD_ERR, \"ls: cannot open %s\\n\", dir);\n        return;\n    }\n    if(fstat(fd, &st) < 0){\n        fprintf(STD_ERR, \"ls: cannot stat %s\\n\", dir);\n        close(fd);\n        return;\n    }\n    switch(st.type) {\n        case T_DEVICE: // 不做处理\n        case T_FILE:\n            if(strcmp(fmtname(dir), file) == 0) {\n                fprintf(STD_OUT, \"%s\\n\", dir);\n            }\n            break;\n        case T_DIR:\n            if(strlen(dir) + 1 + DIRSIZ + 1 > sizeof buf) {\n                printf(\"ls: path too long\\n\");\n                break;\n            }\n            strcpy(buf, dir);\n            p = buf + strlen(buf);\n            *p++ = '/';\n            while(read(fd, &de, sizeof(de)) == sizeof(de)) {\n                if(de.inum == 0 || (strcmp(de.name, \".\") == 0) || (strcmp(de.name, \"..\") == 0))\n                    continue;\n                memmove(p, de.name, DIRSIZ);\n                p[DIRSIZ] = 0;\n                if(stat(buf, &st) < 0){\n                    printf(\"ls: cannot stat %s\\n\", buf);\n                    continue;\n                }\n                find(buf, file);\n            }\n            break;\n    }\n    close(fd);\n}\n\nint main(int argc, char *argv[]) {\n    if(argc != 3) {\n        fprintf(STD_ERR, \"Usage: find <dirName> <fileName>\\n\");\n        exit(-1);\n    }\n    find(argv[1], argv[2]);\n    exit(0);\n}\n```\n\n### xargs(moderate)\n\n具体实现过程发布在知乎: [xv6-Lab Utilities-xargs](https://zhuanlan.zhihu.com/p/669622915?)\n\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/param.h\"\n\n#define STD_IN 0\n#define STD_OUT 1\n#define STD_ERR 2\n#define BUFFER_SIZE 512\n\nchar *ugets(char *buf, int max) {\n    char c;\n    int i;\n    for (i = 0; i + 1 < max;) {\n        int cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        if (c == ' ' || c == '\\n' || c == '\\r')\n            break;\n        buf[i ++] = c; // 不读入 ' ' 和 '\\n'\n    }\n    buf[i] = '\\0';\n    return buf;\n}\n\nint ugetcmd(char *buf, int nbuf) {\n    memset(buf, 0, nbuf);\n    ugets(buf, nbuf);\n    if (buf[0] == 0) // EOF\n        return -1;\n    return 0;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(STD_ERR, \"Usage: xargs command\\n\");\n        exit(1);\n    }\n    char *_argv[MAXARG];\n    int _argc = argc - 1;\n    for(int i = 0; i < _argc; i ++) {\n        _argv[i] = argv[i + 1];\n    }\n    char buf[BUFFER_SIZE];\n    while(ugetcmd(buf, sizeof(buf)) != -1) {\n        if(fork() == 0) {\n            _argv[_argc] = buf;\n            _argc ++; // 在父进程中保留所有的输入参数, 可以删掉\n            exec(argv[1], _argv);\n            fprintf(STD_ERR, \"exec %s failed\\n\", argv[1]); // 执行失败\n            exit(0);\n        }\n        wait(0);\n    }\n    exit(0);\n}\n```","tags":["OS","mit6.s081","xv6 Lab"]},{"title":"MIT6.s081-Notes-1","url":"/2023/11/25/MIT6-s081-Notes-1/","content":"\n操作系统经典的组织架构，一般最底层包括了计算机的一些硬件资源，包括CPU、内存、磁盘、网卡等。而在这个架构的最上层则运行着各种各样的应用程序，这些程序都运行在同一个空间中，这个空间被称为**用户空间(Usersapce)**\n\n区别于运行在用户空间里的程序，有一个特殊的程序总是在运行，他称作**Kernel**。\n\n当打开计算机时，Kernel总是第一个启动，Kernel 程序只有一个，它维护数据来管理每一个用户空间进程，同时还维护了大量的数据结构来管理底层的硬件资源，以供用户空间的程序使用。因此，Kernel的核心功能就是: **管理硬件设备，供应用程序使用**\n\n我们通常会比较关心Kernel中的服务，一个是**文件系统**，另一个是**进程管理系统**\n> 每一个用户空间程序都被称为一个进程，他们有自己的内存和共享的CPU时间。\n> 同时, Kernel会管理内存的分配，不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。\n\n文件系统通常会有一些逻辑分区，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有的这些都被文件系统所管理。\n\n### Kernel的Access Control机制\n当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control 机制会决定是否允许这样的操作。\n\n### Kernel的系统调用(System Call)\n我们同时也会对应用程序如何与Kernel交互，它们之间的接口长什么样感兴趣，这些通常称为Kernel的API，它们决定了应用程序如何访问Kernel。通常来说，这是通过 **系统调用(System Call)** 来实现的。\n\n系统调用于程序中的函数调用看起来是一样的，区别在于**系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现**。\n\n> 第一个例子是如果应用程序要打开一个文件，它会调用名为 open 的系统调用，并且把文件名作为参数传给 open。比如我要打开一个名为 \"out\" 的文件，那么 \"out\" 将会作为参数传人，同时还希望写入数据，那么还会有一个额外的参数 1 , 表明我想要写入参数，就是 \n\n```cpp\nAPI-Kernel\nfd = open(\"out\", 1)\n```\n\n这里看起来就像是一个函数调用，但是 open 是一个系统调用，它会跳到Kernel, Kernel可以获取到 open 的参数，接下来执行实现 open 的 Kernel 代码，最后返回一个文件描述符对象，之后，应用程序可以使用这个文件描述符作为 handle , 来表示打开相应的文件。\n\n如果想要向文件写入数据，相应的系统调用则是 write .\n```cpp\nfd = open(\"out\", 1)\nwrite(fd, \"Hello\\n\", 6)\n```\n1. 第一个参数是由 open 返回的文件描述符\n2. 第二个参数是指向要写入数据的指针，通常是 char 型。实际上是内存中的地址\n3. 第三个参数是写入字符的数量\n\n除此之外还可能用到的系统调用是 fork, 它会创建一个与调用进程一模一样的进程，并返回新进程的 process ID/pid。\n\n> 系统调用跳到内核与标准的函数调用跳到另一个函数相比，区别是什么？\n> A: Kernel会有特殊的权限能够直接访问到底层硬件，而普通的用户程序是没有办法直接访问这些硬件的。\n\n#### 系统调用-copy\n```c\n//copy.c: copy input to output.\n\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint main() {\n    char buf[64];\n    \n    while(1) {\n        int n = read(0, buf, sizeof(buf));\n        if(n <= 0) {\n            break;\n        }\n        write(1, buf, n);\n    }\n    exit(0);\n}\n```\n\n这个程序执行了三个系统调用：read、write、exit\n\n#### 系统调用-read\n它接收三个参数：\n1. **第一个参数是文件描述符**，指向一个之前打开的文件。Shell 会确保在默认情况下，当一个程序启动时，文件描述符0链接到console的输入，文件描述符1链接到console的输出，所以可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。这里的0，1文件描述符是非常普遍的Unix风格，许多的Unix系统都会从文件描述符0读取数据，然后向文件描述符1写入数据。\n2. **第二个参数是指向某段内存的指针**，程序可以通过指针对应的地址读取内存中的数据。\n3. **第三个参数是代码想读取的最大长度。**\n\n**read 的返回值是读到的字节数，如果读到文件结尾没有更多内容了read会返回0，如果发生了一些错误比如文件描述符不存在则会返回-1。**\n\n#### 系统调用-open\n前面 copy 代码假设文件描述符已经设置好了，但是一般情况下，我们需要创建文件描述符，最直接的创建文件描述符的方法就是使用open系统调用。\n```c\n//open.c: create a file, write to it.\n#include \"kernel/types\"\n#include \"user/user.h\"\n#include \"kernel/fcntl.h\"\n\nint main() {\n    int fd = open(\"output.txt\", O_WRONLY | O_CREATE);\n    write(fd, \"ooo\\n\", 4);\n\n    exit(0);\n}\n```\n\n这个程序会创建一个叫做 output.txt 的新文件，并向它写入一些数据，最后退出。我们看不到任何输出，因为它只是向打开的文件中写入数据。\n\n1. 第一个参数是文件名\n2. 第二个参数是一些标志位，用来告诉 open 系统调用在内核中的实现：我们将要创建并写入一个文件。\n\nopen 系统调用会返回一个新分配的文件描述符，通常是一个比较小的数字，2、3、4等。\n\n之后这个文件描述符作为第一个参数传入 write，数据被写入到了文件描述符对应的文件中。\n\n#### 文件描述符\n**文件描述符本质上对应了一个内核中的表单数据**。内核维护了每个运行程序的状态，内核会为每一个运行进程保存一个表单，表单的 key 是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的是，**每个进程都有自己独立的文件描述符空间**，所以如果运行了两个不同的程序，对应两个不同的进程，如果他们都打开一个文件，他们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。\n\n> 文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。Linux中\"万物皆可文件\"\n\n\n#### Shell\nShell 通常就是人们说的命令行接口。它提供了很多工具来管理文件，编写程序，编写脚本。通常来说，当你输入内容时，其实是在告诉Shell运行相应的程序，比如输入 ls 时，实际意义就是要求 Shell 运行名为 ls 的程序，文件系统中有一个文件名为 ls, 这个文件中包含一些计算机指令。\n\n除了运行程序以外，Shell还可以做其他事情，比如重定向IO\n```c\n$ ls > out\n```\n要求Shell运行ls程序并将输出重定向到一个叫做out的文件中，然后可以通过 `cat` 命令来读取 out 中的数据。也可以运行一个叫做 `grep` 的程序。grep x会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。\n```c\n$ grep x < out\n```\n\n#### 系统调用-fork\n\n下面是一个简单用例\n```c\n// fork.c: create a new process\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint main() {\n    int pid;\n    pid = fork();\n    printf(\"fork() returned %d\", pid);\n    if(pid == 0) {\n        printf(\"child\\n\");\n    } else {\n        printf(\"parent\\n\");\n    }\n    exit(0);\n}\n```\n\n调用 fork 会拷贝当前进程的内存并且创建一个新的进程，这里的内存包含了进程的指令和数据，之后就有了两个拥有完全一样内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。(完全相同的内存，但是是不同的内存地址，此外，文件描述符也会被拷贝)\n\n#### 系统调用-exec, wait\necho是一个非常简单的命令，它接收任何你传递给它的输入，并将输入写到输出。\n\n下面是一个 exec 系统调用的简单使用\n```c\n// exec.c: replace a process with an executable file\n\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint main() {\n    // 指针0是一个NULL指针，它只表明结束\n    char *argv[] = {\"echo\", \"this\", \"is\", \"echo\", 0};\n    \n    exec(\"echo\", argv);\n\n    printf(\"exec failed!\\n\");\n\n    exit(0);\n}\n```\n\n代码会执行 exec 系统调用，这个系统调用会从指定的文件中读取并加载命令，并替代当前调用进程的指令。从某种程度上来说相当于丢弃了调用进程的内存，并开始执行新加载的指令。所以上面的代码执行 exec 命令后会有这样的效果：操作系统从名为 echo 的文件中加载指令到当前的进程中，并替代了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec允许传入一个命令行参数的数组，这里是一个C语言中的指针数组，这里的字符指针本质就是一个字符串。\n\n所以这里等价于运行 echo 命令，并且带上 \"this is echo\" 这三个参数。我们可以看到如下输出:\n```c\nthis is echo\n```\n即我运行了exec程序，exec程序实际上会调用exec系统调用，并用echo指令来代替自己，所以这里是echo命令在产生输出。\n\n> exec命令用于调用并执行指定的命令。exec命令通常用在shell脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。系统调用 exec 是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。\n\n除此之外，还有一些值得注意的地方：\n1. exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等，它们在新的程序中表示相同的东西。\n2. 通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。exec系统调用只会当出错时才会返回，例如程序文件根本不存在，因为exec系统调用不能找到文件，exec会返回-1。\n\n如果不想原进程被替代的话，可以先 fork 一个子进程，然后在子进程里调用exec系统调用。下面是一个应用场景\n```c\n// forkexec.c: fork then exec\n\n#include \"user/user.h\"\n\nint main() {\n    int pid, status;\n    pid = fork();\n    if(pid == 0) {\n        char *argv[] = {\"echo\", \"THIS\", \"IS\", \"ECHO\", 0};\n        exec(\"echo\", argv);\n        printf(\"exec failed!\\n\");\n        exit(1);\n    } else {\n        printf(\"parent waiting\\n\");\n        wait(&status);\n        printf(\"the child exited with status %d\\n\", status);\n    }\n    exit(0);\n}\n```\n\n在这个程序中先调用了fork，在子进程中与前一个程序一样调用exec。子进程会用echo命令来代替自己，echo执行完成之后就退出。之后父进程重新获得了控制。fork会在父进程中返回大于0的值。\n\n> Unix提供了一个wait系统调用，如第20行所示。wait会等待之前创建的子进程退出。当我在命令行执行一个指令时，我们一般会希望Shell等待指令执行完成。所以wait系统调用，使得父进程可以等待任何一个子进程返回。这里wait的参数status，是一种让退出的子进程以一个整数（32bit的数据）的格式与等待的父进程通信方式。所以在第17行，exit的参数是1，操作系统会将1从退出的子进程传递到第20行，也就是等待的父进程处。&status，是将status对应的地址传递给内核，内核会向这个地址写入子进程向exit传入的参数。wait返回子进程的进程号。\n>\n> Unix中的风格是，如果一个程序成功的退出了，那么exit的参数会是0，如果出现了错误，那么就会像第17行一样，会向exit传递1。\n\n#### IO重定向(Redirect)\n```c\n    // redirect.c: run a command with output redirected\n\n    int main() {\n        int pid;\n\n        pid = fork();\n        if(pid == 0) {\n            close(1);\n            open(\"output.txt\", O_WRONLY|O_CREATE);\n            \n            char *argv[] = {\"echo\", \"this\", \"is\", \"redirect\", \"echo\", 0};\n            exec(\"echo\", argv);\n            printf(\"exec failed!\\n\");\n            exit(1);\n        } else {\n            wait((int *) 0);\n        }\n        exit(0);\n    }\n```\n\nshell提供了方便的IO重定向工具，`echo hello > out` 会将 `echo` 的输出重定向到 `out` 文件中，然后运行 `cat < out` 就可以看到输出。\n> Shell之所以有这样的能力，是因为Shell首先会先fork一个子进程，然后再子进程里，Shell改变了文件描述符。文件描述符1通常是进程用来作为输出的(也就是console的输出文件符)，Shell会先将文件描述符1改为output文件，之后再运行你的指令。同时，父进程的文件描述符1并没有改变。所以这里先fork，再更改子进程的文件描述符，是Unix中常见的重定向指令的输入输出的方法。\n\n运行上面的代码，没有看到任何的输出，但实际上 redirect 程序里运行了 echo，并且把 echo 的输出重定向到 output.txt。在output.txt里可以看到 \"this is redirect echo\"。代码里 `close(1)` 的意义是我们希望文件描述符1指向一个其他的位置，也就是说，在子进程里，我们不想使用原本指向console的文件描述符1。后面的 `open` 语句一定会返回1，因为 open 会返回当前进程未使用的最小文件描述符。因为刚刚关闭了文件描述符1，而文件描述符0又对应着console的输入，所以open一定会返回1。再之后，文件描述符1就和output.txt关联起来了。\n\n#### 管道-PIPE\n管道是一种通信机制，通常用于进程间的通信，将前一个进程的输出(stdout)作为下一下进程的输入(stdin)。管道命令仅能处理standard output，也就是说类似 `less`、`head`、`tail`等可以接受标准输入的命令，而管道又可以分为匿名管道和有名管道。\n\n匿名管道用 `|` 来表示，用完即销毁，例如 `ls -al /etc | less` 。而有名管道又被称为先进先出队列(FIFO)，可以通过 `mkfifo` 命令来显式地常见，例如\n```c\nmkfifo hello\n```\n会在当前文件夹下创建一个管道文件 `hello` ，然后可以执行 `echo \"hello world\" > hello` 往管道里写入 `hello world` ，然后因为管道是同步的，所以在当前终端下会发生阻塞，需要新打开一个终端，然后执行 `cat < hello` 命令就可以将管道中的数据读取出来并打印，然后之前的终端阻塞也停止了。\n\n需要注意的是，当进程对命名管道的使用结束后，命名管道依然存在于文件系统中，使用 `ls` 命令可以看到该文件，需要手动删除。\n\n管道的创建是系统调用 `pipe()` ，该函数创建了一个管道 `pipe` 并且返回两个文件描述符用来表示管道的两端，读取端描述符是 `fd[0]` ，写入端描述符是 `fd[1]` 。\n\n而我们之所以能够使用类似 `ls -al /etc | less` 这样的命令来进行两个进程之间的通信，主要是进行了如下实现:\n\n1. 首先在当前进程下创建一个管道 `fd[2]` ，然后使用 `fork` 创建一个子进程，此时 `fd` 数组同样会被复制，但是由于它们指向了同一个文件(管道)，所以就实现了两个进程通过 `fd` 数组对同一个管道进行跨进程读写操作。\n2. 禁用父进程的读取端，禁用子进程的写入端，就实现了从父进程写入由子进程读取的单向操作。\n\n下面这段程序运行了 `wc` ，并将它的标准输出绑定到了一个管道的读端口:\n```c\nint fd[2];\nchar *argv[2];\nargv[0] = \"wc\";\nargv[1] = 0;\npipe(fd);\nif(fork() == 0) {\n    close(0);\n    dup(fd[0]);\n    close(fd[0]);\n    close(fd[1]);\n    exec(\"/bin/wc\", argv);\n} else {\n    write(fd[1], \"hello world\\n\", 12);\n    close(fd[0]);\n    close(fd[1]);\n}\n```\n这段程序首先创建了一个管道，然后 `fork` 出一个子进程，这样父子进程都指向同一个管道。\n\n在子进程中，首先关闭了标准输入(文件描述符为0)，然后使用 `dup(fd[0])` 复制了管道的读端，由于复制操作会使用最小可用的文件描述符，所以管道的读端成为了新的标准输入。接着，关闭了管道的两个端口，因为复制后就不再需要原来的文件描述符。最后，使用 `exec` 函数执行了 `wc` 命令，wc命令会从标准输入(现在是管道的读端)读取数据。\n\n在父进程中，使用write函数向管道的写端写入了字符串\"hello world\\n\"。然后，关闭了管道的两个端口。总的来说就是这里实现了父进程向子进程传输 \"hello world\\n\" ，然后子进程调用 `wc` 命令处理这个字符串，输出行数、单词数和字节数，在这里应该是输出 `1 2 12` 。\n\n如果数据没有准备好，那么对管道执行的 `read` 会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。后者 `read` 会返回 0，这也是为什么执行 `wc` 之前要关闭子进程的写端口 —— 防止堵塞。\n\n","tags":["OS","mit6.s081"]},{"title":"CSAPP-处理器体系结构","url":"/2023/11/21/CSAPP-处理器体系结构/","content":"\n## 写在正式开始之前\n\n这一部分内容，并非是CSAPP第四章笔记，因为该章节设计了一个 Y68-64 指令集架构，然而这并不通用，且并不优雅。这里选择 [RISC-V] 作为学习方式，阅读「RISC-V 手册」来写了这篇笔记。\n\n计算机体系结构的传统方法是增量ISA, 也就是在实现新的ISA扩展的同时还需要实现过去的所有扩展。而 RISC-V 的区别就在于它是模块化的，其核心是一个名为 RV32I 的基础 ISA，RV32I 是固定的，永远也不会改变，再次之外提供了可选的扩展标准，惯例是把代表扩展的字母附加到指令集名称之后作为指示，例如 RV32IMFD 将 乘法(RV32M)，单精度浮点(RV32F)和双精度浮点(RV32D)的扩展添加到了基础指令集(RV32I)中。\n\n在正式开始之前，推荐观看 [从沙子到芯片-中芯国际](https://www.bilibili.com/video/BV1bE411C76e/?spm_id_from=333.999.list.card_archive.click)\n\n<center>\n      <img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/74E7C9D2AD0A22A10EC654DF565EDFBE.png\" width=\"\" height=\"\">\n</center>\n<center>\n      图一: 半导体IC的制造过程[计算机组成与设计:硬件/软件接口(RISC-V版)]\n</center>\n","tags":["CSAPP"]},{"title":"万物的开始:Riemann积分","url":"/2023/11/15/万物的开始-Riemann积分/","content":"\n[TOC]\n\n## 0. 一切的开始:「黎曼积分」\n在现代数学体系里, 「微积分」是及其重要的组成部分, 而积分又由不定积分和定积分组成, 后者又被称作「黎曼积分」(Riemann integral)。微积分发展至今, 黎曼将柯西只对连续函数定义的积分概念扩张成黎曼积分, 扩大了积分的应用范围, 黎曼积分也首次对函数在给定区间上的积分给出了一个精确定义。\n\n### 0.1 黎曼积分定义\n设函数 $f$ 在区间 $[a,b]$ 上有定义\n\n$\\rm \\textbf{Definition 0.1.1}$ 如果点集 $P=\\{x_0,x_1,\\cdots,x_n\\}$ 满足 $a=x_0<x_1<\\cdots<x_{n-1}<x_n=b$ , 则称 $P$ 为 $[a,b]$ 的一个**分划**. 设 $\\Delta x_i = x_i-x_{i-1},i=1,2,\\cdots,n$ , 则称 $||P|| = \\max\\limits_{1\\le i\\le n} \\{\\Delta x_i\\}$ 为分划 $P$ 的**细度** . 如果 $\\Delta x_i=\\frac{b-a}{n},i=1,2,\\cdots,n$ , 则称 $P$ 为**等距分划**\n\n$\\rm \\textbf{Definition 0.1.2}$ 设 $P$ 是区间 $[a, b]$ 的一个分划, 对每个子区间 $[x_{i-1},x_i]$ , 任取 $\\xi_i\\in [x_{i-1},x_i]$ , 则称 $\\xi = \\{\\xi_i|i=1,2,\\cdots,n\\}$ 为从属于 $P$ 的一个**介点集**; 并称和式 $\\sum\\limits_{i=1}^n f(\\xi_i)\\Delta x_i$ 为 $f$ 在区间 $[a,b]$ 上的一个**Riemann和**.\n\n$\\rm \\textbf{Definition 0.1.3}$ 设 $I$ 为实数, 且有 $\\lim\\limits_{||P||\\to 0}\\sum\\limits_{i=1}^n f(\\xi_i)\\Delta x_i = I$ , 即 $\\forall \\varepsilon >0$ , $\\exists \\delta > 0$ , 对 $||P||<\\delta$ 的每个分划 $P$, 以及对从属于 $P$ 的每个介点集 $\\xi$ , 成立 $|\\sum\\limits_{i=1}^n f(\\xi_i)\\Delta x_i - I|<\\varepsilon$ , 则称函数 $f$ 在区间 $[a,b]$ 上**Riemann可积**或简称**可积**, 记为 $f\\in R[a,b]$ . 并称 $I$ 为 $f$ 在区间 $[a,b]$ 上的**Riemann积分**或**定积分**, 简称积分, 记为 $\\int_a^b f = I$ .\n\n### 0.2 黎曼可积条件\n\n$\\rm \\textbf{Definitions 0.2.1}$ 设函数 $f$ 在 $[a,b]$ 上有界, $P$ 为 $[a,b]$ 的一个分划, 对 $i=1,2,\\cdots,n$ , 记\n$$\n\\begin{align*}\nM_i &= \\sup\\{f(x)|x\\in [x_{i-1},x_i]\\}\\\\\nm_i &= \\inf\\{f(x)|x\\in [x_{i-1},x_i]\\}\\\\\n\\end{align*}\n$$\n称 $w_i = M_i-m_i$ 为 $f$ 在 $[x_{i-1},x_i]$ 上的**振幅**, $\\sum\\limits_{i=1}^n w_i\\Delta x_i$ 为 $f$ 的**振幅面积**.\n\n$\\rm \\textbf{Proposition 0.2.1}$(可积的第一充要条件): 有界函数 $f\\in R[a, b]$ 的充分必要条件是\n$$\n\\begin{align}\n\\lim_{||P||\\to 0}\\sum_{i=1}^n w_i \\Delta x_i = 0\n\\end{align}\n$$\n\n$\\rm \\textbf{Proposition 0.2.2}$(可积的第二充要条件): 有界函数 $f\\in R[a, b]$ 的充分必要条件是对每个 $\\varepsilon > 0$ , 存在区间 $[a,b]$ 的一个分划 $P$ 使得\n$$\n\\begin{align}\n\\sum_{P}w_i\\Delta x_i< \\varepsilon\n\\end{align}\n$$\n\n$\\rm \\textbf{Proposition 0.2.3}$(可积的第三充要条件): 有界函数 $f\\in R[a, b]$ 的充分必要条件是 $\\forall \\varepsilon, \\eta >0$, 存在 $[a,b]$ 的分划 $P$ , 使振幅不小于 $\\eta$ 的子区间的长度之和小于 $\\varepsilon$ .\n\n利用定级分定义以及三个充分必要条件可以得到一些推论:\n1. 设 $f\\in R[a, b]$ , 则 $f$ 在 $[a, b]$ 上有界\n2. 设 $f\\in C[a, b]$ , 则 $f\\in R[a, b]$\n3. 设 $f$ 在 $[a, b]$ 上有界且只有有限个间断点, 则 $f\\in R[a, b]$\n4. 设 $f$ 在 $[a, b]$ 上单调, 则 $f\\in R[a, b]$\n\n写一下第一个结论的证明。\n\n$\\rm \\textbf{Corollary 0.2.1} \\quad \\textbf{Proof}.$ 记 $\\int_a^b f = I$ , 由定积分定义知, 对于 $\\varepsilon = 1$, 存在一个分划 $P$ , 使得对于从属于这个 $P$ 的任何介点集 $\\xi$ 均成立\n$$ \n\\left|\\sum_{i=1}^n f(\\xi_i)\\Delta x_i - I\\right| < 1\n$$\n对于确定的子区间 $[x_{i-1},x_i]$ , 固定所有的 $\\xi_k$($k\\ne i$) 对 $f(\\xi_i)$ 作出如下估计\n$$\n\\frac{1}{\\Delta x_i}(I-1-\\sum_{k\\ne i}f(\\xi_{k}\\Delta x_k)) < f(\\xi_i)<\\frac{1}{\\Delta x_i}(I+1-\\sum_{k\\ne i}f(\\xi_k)\\Delta x_k)\n$$\n由于 $\\xi_i \\in I_i = [x_{i-1},x_i]$ 的任意性, 可得 $f$ 在 $[a, b]$ 上有界.\n\n### 0.3 黎曼积分的缺陷\n即时在有界函数范围内, 黎曼积分依旧存在着很大的缺陷。主要表现为以下两个方面:\n\n1. 黎曼积分与极限可交换的条件太强\n\n为了使\n$$\n\\int_{a}^{b} \\lim_{n\\to \\infty} f_n(x)dx = \\lim_{n\\to \\infty}\\int_{a}^{b}f_n(x)dx\n$$\n对一列收敛的黎曼可积函数 $\\{f_n(x)\\}$ 成立, 需要满足 $f_n(x)$ **一致收敛**.\n\n2. 积分运算不完全是微分运算的逆运算\n\n一方面, 任意一个黎曼可积的函数 $f(x)$ 的变上限积分 $F(x) = \\int_{a}^{x}f(t)dt$ 的所有连续点都有 $F'(x) = f(x)$ , 即积分之后再微分可以还原。\n\n另一方面, 一个可微函数 $F(x)$ 的导函数 $f(x)$ 即时有界也不一定黎曼可积, 也就无法成立 Newton-Leibniz 公式。\n\n为了改进黎曼积分的缺陷, 勒贝格基于可列可加的测度引入了一种新的积分——勒贝格积分。为了引入测度, 先从集合开始。\n\n## 1. 从集合出发\n### 1.1 集合的定义\n$\\rm \\textbf{Definitions 1.1.1}$ 以某种方式给定的一些事物的全体称为一个集合(简称为集), 集中的成员称为这个集的元素。\n\n$\\rm \\textbf{Definitions 1.1.2}$ 设 $A$ 和 $B$ 是两个集, 如果 $A$ 和 $B$ 具有完全相同的元素, 则称 $A$ 和 $B$ 相等, 记为 $A=B$ ; 如果 $A$ 的元素都是 $B$ 的元素, 则称 $A$ 为 $B$ 的子集, 记为 $A\\subset B$ , 若 $A\\subset B$ 且 $A\\ne B$ 则称 $A$ 为 $B$ 的真子集。\n\n由定义1.1.2可知, $A=B$ 当且仅当 $A\\subset B$ 且 $B\\subset A$ , 这也是证明两个集合相等最常用的方法。\n\n$\\rm \\textbf{Definitions 1.1.3}$ 设 $X$ 是一个给定的集, 由 $X$ 的所有子集构成的集称为 $X$ 的**幂集**, 记为 $\\mathcal{P}(X)$ . 一般地, 若 $X$ 是由 $n$ 个元素构成的集, 则 $X$ 有 $2^n$ 个不同的子集.\n\n\n\n### 1.2 集合的运算\n设 $I$ 是一非空集, 若对每个 $\\alpha\\in I$ 都对应一个集 $A_{\\alpha}$ , 则称 $\\{A_{\\alpha}\\}_{\\alpha\\in I}$ 为**集族**, 称 $I$ 为**指标集**. 特别地, 若指标集是自然数集 $N$ , 则称 $\\{A_{\\alpha}\\}_{\\alpha\\in N}$ 为**集列**, 简记为 $\\{A_n\\}$ . ","tags":["数学分析","积分"]},{"title":"数字图像处理Lab1-图像增强的空域方法","url":"/2023/11/11/数字图像处理Lab1-图像增强的空域方法/","content":"\n这个系列是针对数学图像处理课程的实验以及大作业写的手册。原始代码已上传至github。四次实验的内容分别为:\nLab1: 图像增强的空域方法\nLab2: 图像增强的频域方法\nLab3: 图像压缩编码实现\nLab4(大作业): 美颜算法原理及其实现\n\n地址: https://github.com/wxLiu925/Whut-ExperimentProject/tree/main/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80\n\n## 实验内容(Lab1)\n1. 读入一副彩色图像(非卡通), 大小为256*256, 观察它的每个点象素;将该彩色图像变成灰度图像; 将该图像的直方图画出来, 要求自己编写函数绘制直方图的函数。\n2. 自己编写函数，进行直方图均衡化，并显示均衡化后的图像。\n3. 将该彩色图像使用 imnoise 函数加入各种噪声，显示图像；或者读入一副低\n质量被噪声污染的图像。\n4. 分别使用 conv2 函数、fspecial 函数和 imfilter 函数，对受噪声污染的图像进行均值滤波和中值滤波、高斯滤波。要求设置不同大小的均值滤波模板，改变权值，测试试验结果。中值滤波要求能设置不同的滤波窗口大小，显示结果。请尽量使用矩阵的整体运算，来代替循环计算。\n5. 读入另外一副图像，对其采取不同的 roberts/laplace/sobel/priwitt 边缘锐化算子进行边缘增强和锐化，并显示不同算子的计算结果。对原始图像加入噪声，观察锐化后的效果。要求：请尽量避免循环运算，而使用矩阵整体运算。\n6. 结合试验结果，对不同图像空域增强方法进行分析和比较，写出你的实验体会。\n7. 对锐化算子的处理结果中，如果计算得到小于零的值，对小于 0 的部分，采用不同的方法标准化到[0,255]时，图像的显示效果有什么不同？为什么？\n\n## 实验原理\n这个实验没什么好讲的，实验内容比较简单，也比较繁杂，更多细节请看代码注释。\n### T6\n1. 均值滤波和高斯滤波：这两种方法都是线性滤波器，主要用于减少图像中的噪声。均值滤波器简单易用，但可能会使图像变得模糊。高斯滤波器可以更好地保留图像的细节，但计算复杂度较高。\n2. 中值滤波：中值滤波是一种非线性滤波器，特别适合于去除椒盐噪声。它可以保留图像的边缘信息，但可能会导致图像的纹理信息丢失。\n3. Sobel、Laplace、Prewitt和Roberts边缘检测：这些方法都是用于图像的边缘检测和锐化。Sobel和Prewitt操作符可以更好地保留边缘信息，但对噪声敏感。Laplace操作符可以检测所有方向的边缘，但可能会导致边缘变得较薄。Roberts操作符简单易用，但可能会错过一些细微的边缘信息。\n\n总的来说，如果图像中存在大量的高斯噪声，应该选择使用高斯滤波器。如果需要检测图像的边缘，则应该选择使用Sobel或Laplace操作符。\n\n### T7\n在图像处理中，像素值通常被标准化或缩放到[0,255]的范围。当我们应用锐化算子后，有可能得到小于0的值。对于这些小于0的值，我们需要进行处理以便能在[0,255]的范围内表示。以下是两种常用的处理方法：\n1. 截断处理：这种方法将所有小于0的值设为0。这是最直接的方法，但可能会导致一些信息丢失，因为所有小于0的值都变成了同样的值（即0）。\n2. 缩放处理：这种方法将所有的值（包括大于0的值）线性缩放到[0,255]的范围。这种方法可以保留更多的信息，因为它保持了原始数据中的相对差异。但这种方法可能会使图像看起来较暗，因为所有的值都被缩小了。\n这两种方法会导致不同的显示效果。截断处理可能会导致图像在某些地方看起来有\"断裂\"，因为所有小于0的值都变成了0，可能会造成边缘信息的丢失。而缩放处理则能保留更多的边缘信息，但可能会使整个图像看起来较暗。","tags":["C++","OpenCV"]},{"title":"CSAPP-第二章(Homework)","url":"/2023/11/01/CSAPP-第二章-Homework/","content":"### 2.57\n> 编写程序 `show_short` 、`show_long` 、`show_double`，它们分别打印类型为 `short`、`long` 和 `double` 的字节表示。\n\n`char` 是字符型，但也是属于整形的，因为 `char` 最终存储的是 ASCLL 码值到内存的。一个 `char` 有 8 个位，所以能存储的范围为 $-128\\sim 127$ ，而 `unsigned char` 存储的范围为 $0\\sim 255$ 。因为它占用一个字节，所以 `unsigned char` 可以精确地表示一个字节的所有可能值，所以它通常用于存储和处理字节数据。\n\n```c\n#include <stdio.h>\n\ntypedef unsigned char *byte_pointer;\n\n// 大端\nvoid show_byte(byte_pointer start, size_t sz) {\n    // 展示十六进制\n    for(int i = 0; i < sz; i ++) {\n        printf(\"%.2x\", start[i]);\n    }\n    printf(\"\\n\");\n    // 展示二进制(大端)\n    for(int i = 0; i < sz; i ++) {\n        for(int j = 7; j >= 0; j --) {\n            printf(\"%d\", (start[i] >> j) & 1);\n            if(j % 4 == 0) printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}\n\nvoid show_short(short num) {\n    printf(\"short: \\n\");\n    show_byte((byte_pointer)&num, sizeof(short));\n}\n\nvoid show_long(long num) {\n    printf(\"long: \\n\");\n    show_byte((byte_pointer)&num, sizeof(long));\n}\n\nvoid show_float(float num) {\n    printf(\"float: \\n\");\n    show_byte((byte_pointer)&num, sizeof(float));\n}\n\nvoid show_double(double num) {\n    printf(\"double: \\n\");\n    show_byte((byte_pointer)&num, sizeof(double));\n}\n\nint main() {\n    int num = 365;\n    show_short((short)num);\n    show_long((long)num);\n    show_float((float)num);\n    show_double((double)num);\n    return 0;\n}\n```\n\n### 2.58\n> 编写过程 `is_little_endian` ，当在小端法机器上编译和运行时返回1，在大端法机器上编译运行时则返回0。这个程序应该可以运行在任何机器上，无论机器的字长是多少。\n\n计算机存储数据在地址上都是由低到高，大小端的区别为小端法存储数据由低位到高位，而大端法则是由高位到低位，例如数据 `0x12345678` 小端法存储就是 `78 56 34 12`，而大端法存储则是 `12 34 56 78` 。\n可以使用 `union` 来实现，在 `union` 中存放两个数据，一个 `int` 一个 `char` ，`char` 占的地址为 `int` 数据的第一个字节，修改 `int` 值为1，这样就只需要判断 char 数据是否为 1 即可。\n\n```c\nint is_little_endian() {\n    union {\n        int i;\n        char c;\n    } test;\n    test.i = 1;\n    return (int)test.c;\n}\n```\n\n### 2. 59\n> 编写一个 C 表达式，它生成一个字，由 $x$ 的最低有效字节和 $y$ 中剩下的字节组成。对于运算数 `x = 0x89ABCDEF` 和 `y = 0x76543210` 得到 `0x765432EF`。\n\n+ **位(bit)是计算机内部数据存储的最小单位**，只能取0或者取1;\n+ **字节(byte)是计算机数据处理的最小单位**，每个字节有8个二进制位，其中最右边的一位为最低位，最左边的一位为最高位;\n+ **字是计算机进行数据处理和运算的单位**，即cpu一次处理二进制代码的位数，字的位数叫做字长，字长的大小与计算架构有关，通常说的32位机就是一个字有4个字节，32个位。\n\n`x & 0xFF`, 得到 x 最低有效位，`y & ~0xFF` 得到 y 最低有效位之外的位，两者进行或运算，得到组合结果\n```c\ntypedef unsigned char *byte_pointer;\n...\nsize_t x = 0x89ABCDEF;\nsize_t y = 0x76543210;\nsize_t mask = 0xff;\nsize_t res = ((x & mask) | (y & ~mask));\nbyte_pointer start = (byte_pointer)& res;\nfor(int i = 0; i < sizeof(size_t); i ++) {\n    printf(\"%.2x\", start[i]);\n}\n/*\n输出: ef32547600000000 (小端法机器)\n*/\n```\n\n### 2.60\n> 假设我们将一个 $w$ 位的字中的字节从 0(最低位)到 $\\frac{w}{8} - 1$(最高位)编号。写出下面C函数代码，它会返回一个无符号值，其中参数 $x$ 的字节 $i$ 被替换成字节 $b$ :\n`unsigned replace_byte (unsigned x, inti, unsigned char b);`\n以下示例说明其如何工作:\n`replace_byte(Ox12345678, 2, OxAB) --> Ox12AB5678`\n`replace_byte(Ox12345678, 0, OxAB) --> Ox123456AB`\n\n\n按要求模拟就好了\n```c\n#include <stdio.h>\n\ntypedef unsigned char *byte_pointer;\n\n/*\n* @brief 参数 x 的字节 i 被替换成字节 b\n*/\nunsigned replace_byte (unsigned x, int i, unsigned char b) {\n    byte_pointer start = (byte_pointer)& x;\n    start[i] = b;\n    return *(unsigned*)start;\n}\n\nvoid show_byte(byte_pointer start, size_t sz) {\n    for(int i = 0; i < sz; i ++) {\n        printf(\"%.2x\", start[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    unsigned res1 = replace_byte(0x12345678, 2, 0xAB);\n    unsigned res2 = replace_byte(0x12345678, 0, 0xAB);\n    show_byte((byte_pointer)&res1, sizeof(unsigned));\n    show_byte((byte_pointer)&res2, sizeof(unsigned));\n    return 0;\n}\n/*\noutput:\n7856ab12\nab563412\n*/\n```\n这里提一下最后为什么返回 `*(unsigned*)start` ，这里先要将 `unsigned char *` 类型的 `start` 转变为 `unsigned*` ，即先转换指针类型，再去指针指向地址的值，而如果使用 `(unsigned)(*start)` 的话，`*start` 由于是 `unsigned char` 类型的指针，所以只会取出第一个地址的值，而不是所有的内存单元。\n\n\n在接下来的作业中，我们特意限制了你能使用的编程结构，来帮你更好地理解 C 语言的位级、逻辑\n和算术运算。在回答这些问题时，你的代码必须遵守以下规则:\n+ 假设:\n    + 整数用补码形式表示;\n    + 有符号数的右移是算术右移;\n    + 数据类型 `int` 是 $w$ 位长的。对于某些题目，会给定 $w$ 的值，但是在其他情况下，只要 $2$ 是 8 的整数倍，你的代码就应该能工作。你可以用表达式 `sizeof(int)<<3` 来计算 $w$。\n+ 禁止使用\n    + 条件语句、循环、分支语句、函数调用和宏调用;\n    + 除法、模运算和乘法;\n    + 相对比较运算($>$ 、$<$ 、$\\le$ 和 $\\ge$)。\n+ 允许的运算\n    + 所有的位级和逻辑运算;\n    + 左移和右移，但是位移量只能在 $0$ 到 $w-1$ 之间;\n    + 加法和减法;\n    + 相等(==)和不等(!=)测试。(有些题目里也不允许这些运算);\n    + 整型常数 `INT_MAX` 和 `INT_MIN`;\n    + 对 `int` 和 `unsigned` 进行强制类型转换，无论是显式的还是隐式的。\n\n### 2.61\n> 写一个C表达式，在下列描述的条件下产生1, 而在其他情况下得到 0。假设 $x$ 是 `int` 类型。\nA. $x$ 的任何位都等于 1\nB. $x$ 的任何位都等于 0\nC. $x$ 的最低有效字节中的位都等于1\nD. $x$ 的最高有效字节中的位都等于0\n\n```c\n#include <stdio.h>\n#include <assert.h>\n\ntypedef unsigned char *byte_pointer;\n\nvoid show_byte(int x) {\n    unsigned mask = 1u << 31;\n\tfor(int cnt = 1; mask; mask >>= 1, cnt ++) {\n\t\tprintf(\"%d\", x & mask ? 1: 0);\n        if(cnt % 4 == 0) printf(\" \");\n\t}\n\tprintf(\"\\n\");\n}\n\nint A(int x) {\n    return !~x;\n}\n\nint B(int x) {\n    return !x;\n}\n\nint C(int x) {\n    return !~(x | ~0xFF);\n}\n\nint D(int x) {\n    return !(x >> ((sizeof(int) - 1) << 3));\n}\n\nint main() {\n    int all_bit_one = ~0;\n\tint all_bit_zero = 0;\n\t\n\tassert(A(all_bit_one));\n\tassert(!B(all_bit_one));\n\tassert(C(all_bit_one));\n\tassert(!D(all_bit_one));\n\t\n\tassert(!A(all_bit_zero));\n\tassert(B(all_bit_zero));\n\tassert(!C(all_bit_zero));\n\tassert(D(all_bit_zero));\n\t\n\tassert(!A(0x1234FF));\n\tassert(!B(0x1234FF));\n\tassert(C(0x1234FF));\n\tassert(D(0x1234FF));\n\t\n\tassert(!A(0x1234));\n\tassert(!B(0x1234));\n\tassert(!C(0x1234));\n\tassert(D(0x1234));\n    return 0;\n}\n```\n\n解释:\n1. `~` 是对每一位取反\n2. `!` 是对值取反\n\n而 C 部分，首先是和 `~0xFF` (亦即 `0xFFFFFF00`) 做或运算，前 3 个字节都为 1，最后一个字节为 $x$ 本来的最低字节，要判断是否为全 1 只需要全部取反再判断是否为0即可\n\nD 部分，`(x >> ((sizeof(int) - 1) << 3))` 会得到最高位字节右移后的结果，例如`0011 1011 1001 1010 1100 1010 0000 0000` 会变为 `0000 0000 0000 0000 0000 0000 0011 1011` ，最后判断即可。\n\n### 2. 62\n> 编写一个函数 `int_shifts_are_arithmetic()` 在对 `int` 类型的数使用算术右移的机器上运行时这个函数生成 1, 而其他情况下生成 0 。你的代码应该可以运行在任何字长的机器上。在几种机器上测试你的代码。\n\n```c\nint int_shifts_are_arithmetic() {\n    int x = -1;\n    return !(x ^ (x >> 1));\n}\n```\n\n后面的有时间慢慢做...","tags":["CSAPP"]},{"title":"CSAPP-程序的机器级表示","url":"/2023/11/01/CSAPP-程序的机器级表示/","content":"\n历史上出现过很多知名的指令集架构，比如Alpha， SPARC，PowerPC，MIPS等，而在今天最流行的则是x86(-64)，ARM，RISC-V。这一章以x86-64为重点。\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/isa.png\" width=\"\"></div>\n\n\n> 指令集体系结构或指令集架构(nstruetion Set Arehiteeture, ISA)，定义机器级程序的\n格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA, 包括 x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的。\n\n虽然我们日常使用的编程语言多种多样，但对于计算机来说，其唯一能理解的无非就是二进制，即0和1而已。 CPU的工作流程基本可以看作为控制器从计数器(PC)取出下一条指令并执行，同时更新程序计数器的值。下面是一些基本概念:\n\n+ **Instructure Set Architecture:** 指令集架构 (包括指令规格，寄存器等)，简称ISA，它是软硬件之间的“合同”\n+ **Mircoarchitecture:** 指令集架构的具体实现方式 (比如流水线级数，缓存大小等)，它是可变的\n+ **Machine Code:** 机器码，也就是机器可以直接执行的二进制指令\n+ **Assembly Code:** 汇编码，也就是机器码的文本形式 (主要是给人类阅读)\n\n\n\n## 程序编码\n### C编译过程\nC程序的编译过程: 源代码 `->` 编译 `->` 汇编 `->` 链接 `->` 可执行文件 `->` 装载 `->` 执行\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/05AFB7EEA96F9F7EEC5ADE1BEA97CC09.png\" width=\"\"></div> \n\n更具体的是:\n1. 预处理器(preprocessor) 把诸如 `#include`、`#define`、`#if`、`#else`、`#elif`、`#ifdef`、`#endif` 等预编译指令替换掉\n2. 编译器(compiler)把.c源文件编译成.s的汇编代码文件\n3. 汇编器(assembler)把汇编代码文件转换成相应的二进制目标文件.o，目标文件已经是机器码了，只是没有填入全局变量的地址\n4. 链接器(linker)，把多目标文件和库函数链接在一起，形成可执行文件\n\n在整个编译过程中，编译器会完成大部分工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。\n\n+ 程序计数器(\"PC\")，在 x86-64 中用 `%rip` 表示，给出将要执行的下一条指令在内存中的地址;\n+ 整数寄存器文件包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址或整数数据，有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值;\n+ 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，可以用来实现条件控制代码比如 `if` 和 `while`\n+ 向量寄存器可以存放一个或多个整数或浮点数值。\n\n\n> 以下并不严格按照CSAPP的内容\n\n例如有如下 C 代码 `mstore.c`\n```c\nlong mult2(long, long);\nvoid multstore(long x, long y, long *dest) {\n    long t = mult2(x, y);\n    *dest = t;\n}\n```\n\n在命令行使用 `gcc -Og -S mstore.c` , `-S` 选项会使GCC运行编译器,产生一个汇编文件 `mstore.s` , 但是不做进一步工作\n\n查看该汇编文件，内容如下:\n```c\n\t.file\t\"mstore.c\"\n\t.text\n\t.globl\tmultstore\n\t.type\tmultstore, @function\nmultstore:\n.LFB0:\n\t.cfi_startproc\n\tendbr64\n\tpushq\t%rbx\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 3, -16\n\tmovq\t%rdx, %rbx\n\tcall\tmult2@PLT\n\tmovq\t%rax, (%rbx)\n\tpopq\t%rbx\n\t.cfi_def_cfa_offset 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmultstore, .-multstore\n\t.ident\t\"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\t.section\t.note.gnu.property,\"a\"\n\t.align 8\n\t.long\t1f - 0f\n\t.long\t4f - 1f\n\t.long\t5\n0:\n\t.string\t\"GNU\"\n1:\n\t.align 8\n\t.long\t0xc0000002\n\t.long\t3f - 2f\n2:\n\t.long\t0x3\n3:\n\t.align 8\n4:\n```\n\n我们其实只需要关注其中的\n```c\nmultstore:\n.LFB0:\n\t.cfi_startproc\n\tendbr64\n\tpushq\t%rbx\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 3, -16\n\tmovq\t%rdx, %rbx\n\tcall\tmult2@PLT\n\tmovq\t%rax, (%rbx)\n\tpopq\t%rbx\n\t.cfi_def_cfa_offset 8\n\tret\n\t.cfi_endproc\n```\n\n### 寄存器文件(x86-64)\n16个64位的寄存器，构成了寄存器文件。\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/5948E8CF263182DEE3C28521452B4405.png\" width=\"\"></div> \n\n16个寄存器文件，但是有64个命名，这是因为字节数量的不同。比如 `%rax` ，存储 `char` 类型的变量时只会用到低八位，即 `al` ，存储 `short` 类型的变量则需要用到低16位，即 `%ax` ，而 `int` 类型的变量需要用到32位，即 `%eax` 。\n\n### 栈\n在 x86-64 中存在着栈空间，它存储着临时变量，担任过程调用的中转站，即保留返回地址、参数等。栈遵循先进后出原则(LIFO)。栈空间有一个栈顶指针，也就是十六个寄存器里的 `%rsp` ，在 x86-64 中，程序栈存放在内存中某个区域，栈向下增长，这样可以使得栈顶元素的地址是所有栈中元素地址最低的。栈指针 `%rsp` 保存着栈顶元素的地址，如下图\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/4F2CBA99F7FB1F479FC93BC217889736.png\" width=\"\"></div> \n\n栈有两个操作:\n+ 压入栈(push): 将栈顶指针往下移动若干个字节，使得栈的容量增大，再把新的数据填入栈顶;\n+ 弹出栈(pop): 将栈顶指针上移若干字节，随着栈顶指针的上移，原来的栈顶已经被排除在栈的范围之外。\n\n### PC寄存器\nPC(Program counter)寄存器，也就是前面说的程序计数器，用 `%rip` 表示，它并不是通用寄存器的一员，它存储着下一条要执行的指令的地址。此外，PC寄存器并不会显式地出现在汇编代码中，其值的变化都是暗地里进行的。\n\n## 汇编语言(AT&T)\n### 指令\n汇编代码是由多条指令组成的序列，指令序列存在内存里，PC指向下一条指令的地址，一个指令可以完成一个CPU操作。一条指令由**操作码**和 $0\\sim 2$ 个**操作数**组成，操作码指定了当前指令要执行的操作，例如两数相加，操作数则是操作码的作用对象。由此可见，指令的长度并不固定。\n\n### 操作数\n操作数可以是**立即数、寄存器、内存地址**，以下是三种操作数的表示方法\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/9812E8E00347A8E30C20E1A2635EC8D1.png\" width=\"\"></div> \n\n举例子对上图进行说明:\n1. `$5` 是立即数，它的值为 5;\n2. `%rax` 是寄存器，它的值是寄存器 `%rax` 中的值;\n3. `0x07` 是内存地址，它的值是内存中地址为 `0x07` 的某种类型的值;\n4. `(%rax)` 是内存地址，该地址保留在寄存器 `%rax` 中;\n5. `0xf7(%rax, %rbp, 4)` 是内存地址，所有的内存寻址方式都可以写成这种类型。\n\n最后一种表示一个基址寻址，寻址方式是: `displacement(base register, index register, scale factor)` ，在上面个例子中:\n+ displacement(偏移)是 `0xf7`，即十六进制的偏移值F7\n+ base register(基址寄存器)是 `%rax`\n+ index register(索引寄存器)是 `%rbp`\n+ scale factor(倍数因子)是 4\n\n也就是说，该表达式表示的内存地址是: `0xf7 + (%rax) + 4 * (%rbp)`\n\n### 操作码\n操作码分为**算数逻辑类、数据传输类、控制类**等。\n\n1. 算术和逻辑指令操作码\n```c\naddq $3, %rdi\n```\n`add` 表示相加，第一个操作数是源操作数，第二个操作数是目标操作数，表示将立即数 3 加到寄存器 `%rdi` 中。而 `add` 的后缀表示操作数的大小，分别为:\n+ `b` —— 字节(byte, 8bit);\n+ `w` —— 字(word, 16bit);\n+ `l` —— 双字(doubleword, 32bit);\n+ `q` —— 四字(quadword, 64bit)\n\n算数和逻辑类指令操作码被分为四组: **加载有效地址、一元操作、二元操作和移位**，二元操作有两个操作数，而一元操作有一个操作数。如下图所示\n\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/E1D9A89ED6FD8CBE5E3D5B4CD9FFCAF7.png\" width=\"\"></div> \n\n2. 数据传输指令操作码\n```c\nmovb %bl, %al\n```\n将 `%bl` 寄存器中的值赋给`%al` 寄存器。\n\n```c\npushq %rbp\n```\n表示将 `%rbp` 的值压入栈中，即先使栈顶指针寄存器`%rsp`的值减少8个字节，再将`%rbp`的值赋值给`%rsp`所指的内存单元。\n\n```c\npopq %rsi\n```\n将栈顶的8个字节的值弹出，并赋给 `%rsi`\n\n除此之外，还有诸如控制类、比较和测试类操作码。\n\n### 条件码\n除了整数寄存器，CPU还维护了一组单个位的条件码(condition code)寄存器，它们\n描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用\n的条件码有:\n+ `CF` : 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出;\n+ `ZF` : 零标志。最近的操作得出的结果为 0;\n+ `SF` : 符号标志。最近的操作得到的结果为负数;\n+ `OF` : 溢出标志。最近的操作导致一个补码溢出正溢出或负溢出。\n\n比如说，当使用一条 `add` 指令来完成等价于 C 表达式 `t = a + b` 的功能后，这里的变量都是整型的。然后由下面的 C 表达式来设置条件码\n+ CF —— (unsigned) t < (unsigned) a —— 无符号溢出\n+ ZF —— (t == 0) —— 零\n+ SF —— (t < 0) —— 负数\n+ OF —— (a < 0 == b < 0) && (t < 0 != a < 0) —— 有符号溢出\n\n### 实例\n准备一个 `test.c` 文件，写入如下代码\n```c\nvoid foo(){\n    return;\n}\n```\n\n使用 `gcc -Og -S test.c` 命令可以得到 *.s 的汇编语言文件，加入 `-Og` 的目的是使得到的汇编代码与源代码尽可能的对应。更好的办法是:\n\n首先编译源代码得到目标文件test.o\n```c\ngcc -c -Og test.c\n```\n\n然后用反汇编命令\n```c\nobjdump -d test.o\n```\n\n得到如下:\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/521877CBD05A3E6B85EAAA99A1A59C92.png\" width=\"\"></div> \n\n首先 `0000000000000000 <main>` ，前面的 16 个 0 是十六进制下的 0，也就是二进制下的 64 个 0, 表示该函数所在的虚拟地址，而 `<main>` 则是函数名。接下来是函数体，0、4、8、f...是各指令的地址，也是十六进制，因为第一条指令有4个字节(f3、0f、1e、fa)所以第二条指令的地址和第一条指令地址相差 4。\n\n","tags":["CSAPP"]},{"title":"CSAPP-信息的表示和处理","url":"/2023/10/26/CSAPP-信息的表示和处理/","content":"\n> 人总是对记忆有一种放不下的假清高，渴望在过去里找一点存在感，却因此而陷入更深的纠结。这并不能减少人的迷茫彷徨，反而会加剧内心的动荡。\n> 理解和接受过去的自己，这很重要。同时也要带着乐观派、理想主义和克制活着。\n> —— 2023.10.31记。\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/Fq8hp.png\" width=\"\"></div>\n\n## 信息存储\n大多数计算机使用 8 位的块，或者字节作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存(virtual memory)**。内存的每个字节都由一个唯一的数字来标识，称为它的**地址(address)**，所有可能地址的集合就称为**虚拟地址空间(virtual address space)**。\n\n+ 无符号编码基于传统的二进制表示法，表示大于或者等于零的数字;\n+ **补码(two’s-complement)** 编码是表示有符号整数的最常见的方式;\n+ **移码(增码)** 是符号位取反的补码，一般用指数的移码减去1来做浮点数的阶码，引入的目的是为了保证浮点数的机器零为全0;\n+ **原码(true form)** 是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位(即最高位为符号位):正数该位为0，负数该位为1(0有两种表示:+0和-0)，其余位表示数值的大小;\n+ **浮点数(floating-point)** 编码是表示实数的科学计数法的以2为基数的版本。\n\n### 十六进制(hex)\n使用 $0\\sim 9$ 和 $A\\sim F$ 来表示 `0000` 到 `1111` ，在 C 语言中，以 `0x` 或 `0X` 开头的数字常量通常被认为是十六进制的值，字符 $A\\sim F$ 可以是大写也可以是小写，也可以大小写混合。将一个二进制的数转换为十六进制需要将该数划分为每4个为一组，如果不是4的倍数则在最左边补0 \n\n而十进制转换为十六进制的话，可以使用辗转相除法，即不断除以16得到余数，再从下往上取。例如\n$$\n\\begin{align*}\n314156 &= 19634 \\times 16 + 12 \\tag{C}\\\\\n19634 &= 1227\\times 16+2 \\tag{2}\\\\\n1227 &= 76\\times 16+11 \\tag{B}\\\\\n76 &= 4\\times 16 + 12 \\tag{C}\\\\\n4 &= 0\\times 16 + 4 \\tag{4}\n\\end{align*}\n$$\n\n所以 314156 的十六进制表示就是 0x4CB2C 。反过来，将16进制转换为10进制只需要不断乘上16的幂次相加即可，例如 $314156 = 4\\times 16^4 + 12\\times 16^3 + 11\\times 16^2 + 2\\times 16^1 + 12$ .\n\n### 字数据大小\n每台计算机都有一个**字长(word size)**，指明指针数据的**标称大小(nominal size)**，字长决定了虚拟地址空间的最大大小: 对于一台字长为 $\\omega$ 位的机器，虚拟地址的范围为 $0\\sim 2^{\\omega}-1$\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/FgDwe.png\" width=\"\"></div>\n\n### 寻址和字节顺序\n基本上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。\n\n排列表示一个对象的字节有两个通用的规则:\n+ **小端法(little ending)**: 最低有效字节在前面的方式(低位放在低地址)\n+ **大端法(big ending)**: 最高有效字节在前面(高位放在低地址)\n\n> CSAPP里关于大小端之争记录的一个有趣故事: \" ‘……我下面要告诉你的是， Lilliput 和 Blefuscu 这两大强国在过去 36 个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由 Ble­fuscu 的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有 11000 人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。’(此段译文摘自网上蒋剑锋译的 《 格利佛游记 》 第一卷第 4 章。)\n在他那个时代，Swift 是在讽刺英国(Lilliput)和法国(Blefuscu)之间持续的冲突。Danny Cohen, 一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序, 后来这个术语被广泛接纳了 。“\n\n### 字符串\nC语言中字符串被编码为一个以 `null` 字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。\n\n### 布尔代数\n位向量是固定长度为 $\\omega$ 由 0 和 1 组成的串，位向量的运算可以定义成参数的每个对应元素之间的运算。\n\n位向量一个很有用的应用就是表示有限集合: 我们可以用位向量 $[a_{\\omega-1}, a_{\\omega-2}, \\cdots, a_0]$ 编码任何子集 $A\\in 0, 1, \\cdots, \\omega-1$ ，其中 $a_i=1$ 当且仅当 $i\\in A$ 。\n\n+ 对于任意整数 $\\omega>0$ ，长度为 $\\omega$ 的位向量上的布尔运算 `|`、`&`、`~` 形成了一个布尔代数。\n+ 对于任意整数 $\\omega>0$ ，长度为 $\\omega$ 的位向量上的布尔运算 `^`、`&`、`~` 形成了一个布尔环。\n\n## 整数表示\n### 无符号数的编码\n假设有一个整数数据类型有 $w$ 位，定义向量 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ 。那么 $B2U_w$(Binary to Unsigned) 为:\n$$\nB2U_w(\\vec{x}) := \\sum_{i=0}^{w-1}x_i2^i\n$$\n表示的最大整数值为 $\\sum_{i=0}^{w-1}2^i=2^w-1$ 。无符号数和二进制编码一一对应，函数 $B2U_w$ 是一个双射。\n\n### 补码编码(two's-complement)\n补码是表示有符号数最常见的方式: 将字的最高有效位解释为负权，用函数 $B2T_w$(Binary to Two's-complement) 来表示。定义向量 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ 。那么 $B2T_w$ 为:\n$$\nB2T_w(\\vec{x}):=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\n$$\n\n补码能表示的范围为: $[-2^{w-1}, 2^{w-1}-1]$ ，补码同样构成一一对应，函数 $B2T_w$ 也是一个双射。\n\n### 反码(Ones'Complement)和原码(Sign-Magnitude)\n除了补码之外，还有反码和原码可以用来表示有符号数。\n\n+ 反码: 除了最高有效位的权是 $-(2^{w-1}-1)$ 而不是 $-2^{w-1}$，它和补码是一样的\n$$\nB2O_w(\\vec{x}) := -x_{w-1}(2^{w-1}-1)+\\sum_{i=0}^{w-2}x_i2^i\n$$\n+ 原码: 最高有效位是符号位，用来确定剩下的位应该取负权还是正权\n$$\nB2S_w(\\vec{x}) := (-1)^{x_{w-1}}\\times \\sum_{i=0}^{w-2}x_i2^i\n$$\n> 反码和原码对于 0 都有两种表示方式，对于 +0 两者都表示为 $[00\\cdots 0]$ ，而 -0 在原码中表示为 $[10\\cdots 0]$ 在反码中表示为 $[11\\cdots 1]$\n\n### 有符号数和无符号数之间的转换\n考虑下面这段代码\n```c\nshort int v = -12345;\nunsigned short uv = (unsigned short) v;\nprintf(\"v = %d, uv = %u\\n\", v, uv);\n```\n输出: `v = -12345, uv = 53191` ，其含义是强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。\n\n> C语言中执行一个运算时，它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数来执行运算。例如 `-1 < 0u` 会返回 false，因为左边的操作数将被隐式地转换为无符号数: $-1\\to -1+2^{w}$\n\n### 扩展一个数的位表示\n即从一个较小的数据类型转换到一个较大的类型同时又保持数值不变。\n\n+ 要将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头加0，这种运算被称为**零扩展(zero extension)**;\n+ 要将一个补码转换为更大的数据类型，可以执行一个**符号扩展(sign extension)**，在表示中添加最高有效位的值: \n    + 将原始位 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ 扩展为 $\\vec{x}'=[x_{w-1},x_{w-1},\\cdots, x_{w-1}, x_{w-2}, \\cdots, x_0]$\n\n即 $B2T_{w}(\\vec{x}) = B2T_{w'}(\\vec{x}')$ 。要证明这个，其实只需证明扩展1位时成立即可，即要证明 \n$$\nB2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\\cdots,x_0])=B2T_{w}([x_{w-1},x_{w-2},\\cdots,x_0])\n$$\n由于\n$$\n\\begin{align*}\nB2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\\cdots,x_0])&=-x_{w-1}2^w+\\sum_{i=0}^{w-1}x_i2^i\\\\\n&=-x_{w-1}2^w+x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\\\\\n&=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\\\\\n&=B2T_{w}([x_{w-1},x_{w-2},\\cdots,x_0])\n\\end{align*}\n$$\n这就证得了上结论。\n\n观察下面的代码:\n```c\nshort sx = -12345;\nunsigned uy = sx;\nprintf(\"uy = %u\\n\", uy);\n```\n在一台大端法机器中输出 `uy = 4294954951` ，这表明当把 short 转换成 unsigned 时会先改变大小，再完成从有符号到无符号的转换，也就是说 `(unsigned) sx` 等价于 `(unsigned) (int) sx`\n\n### 截断数字\n即不用额外的位来扩展一个数值，而是减少表示一个数字的位数。截断一个数字可能会改变它的值，溢出的一种形式。\n+ 截断无符号数: 令 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ ，而 $\\vec{x}' = [x_{k-1},x_{k-2},\\cdots,x_0]$ 为将 $\\vec{x}$ 截断为 $k$ 位的结果，令 $x=B2U_w(\\vec{x})$ ，$x'=B2U_k(\\vec{x}')$ ，则 $x' = x\\bmod{2^k}$ 。(直接带入即可证明)\n+ 截断补码数值: 令 $x=B2U_w(\\vec{x})$，$x'=B2T_k(\\vec{x}')$ ，则 $x'=U2T_k(x\\bmod{2^k})$\n\n## 整数运算\n### 无符号加法\n考虑两个非负整数 $x$ 和 $y$ 满足 $0\\le x, y< 2^w$ ，表示它们的和可能需要 $w+1$ 位，这样就会造成字节膨胀。\n\n定义运算 $+^u_w$ ，该运算把整数和 $x+y$ 截断为 $w$ 位得到的结果，再把这个结果看作一个无符号数，即取 $(x+y)\\bmod{2^w}$ 。\n\n检测无符号数加法中的溢出: 对在范围 $0\\le x$ ，$y\\le UMax_w$ 中的 $x$ 和 $y$ ，令 $s = x +_{w}^{u} y$ , 则对计算 $s$ ，当且仅当 $s<x$ 或者等价地 $s<y$ 时发生了溢出。\n\n$Proof.$ 首先需要注意到 $x+y\\ge s$ ，如果 $s$ 没有发生溢出，则 $s\\ge x$ 。另一方面，如果 $s$ 发生了溢出，则有 $s = x+y-2^w=x+(y-2^w)< x$\n\n### 补码加法\n对整数 $x$ 和 $y$ 满足 $-2^{w-1}\\le x, y\\le w^{w-1}-1$ ，定义 $x+_w^t y$ 为整数和 $x+y$ 被截断为 $w$ 位的结果，并将这个结果看作补码数。有:\n$$\nx+_w^t y = \\begin{cases}\nx+y-2^w, &2^{w-1}\\le x+y\\\\\nx+y, &-2^{w-1}\\le x+y< 2^{w-1}\\\\\nx+y+2^w, &x+y<-2^{w-1}\n\\end{cases}\n$$\n\n检测补码加法溢出: 对在范围 $TMin_w\\le x$ ，$y\\le TMax_w$ 中的 $x$ 和 $y$ ，令 $s = x +_{w}^{t} y$ , 则对计算 $s$ :\n+ 当且仅当 $x>0$ ，$y>0$ 但 $s\\le 0$ 时发生了正溢出;\n+ 当且仅当 $x<0$ ，$y<0$ 但 $s\\ge 0$ 时发生了负溢出.\n\n### 补码的非\n对满足 $TMin_w\\le x\\le TMax_w$ 中的 $x$ ，其补码的非 $-^t_w x$ 由下式给出\n$$\n-^t_w x = \\begin{cases}\nTMin_w , &x=TMin_w\\\\\n-x, &x> TMin_w\n\\end{cases}\n$$\n\n也就是说，对 $w$ 位的补码加法来说，$TMin_w$ 是自己的加法的逆，而其他任何数值的 $x$ 都有 $-x$ 作为其加法的逆。\n\n**求补码非的简便方法**:\n\n1. 对每一位求补(取反)，再对结果+1，也就是 `-x` 和 `~x+1` 等价。\n2. 假设 $k$ 是最右边 1 的位置，即将 $x$ 的位级表示为: $[x_{w-1},\\cdots, x_{k+1},1,0,\\cdots, 0]$ ，然后对 $k$ 左边的所有位取反(01110 $\\to$ 10010)\n\n### 补码乘法\n对整数 $x$ 和 $y$ 满足 $-2^{w-1}\\le x, y\\le w^{w-1}-1$ ，定义 $x*^t_w y$ 为整数和 $x*y$ 被截断为 $w$ 位的结果，并将这个结果看作补码数。将一个补码数截断为 $w$ 位相当于先计算该值模上 $2^w$ 再将无符号数转换为补码，即\n$$\nx*^t_w y = U2T_w((x\\times y)\\bmod{2^w})\n$$\n\n> 无符号和补码乘法的位级等价。\n\n### 乘以常数\n对于大多数机器来说整数乘法指令都相当慢，而加法、减法、位级运算和移位等运算很快，因此编译器使用了用移位和加法运算的组合来对乘法指令进行优化。\n\n首先考虑乘以 2 的幂次，$x\\times 2^k$ 只需要将 $x$ 的位级表示左边加 $k$ 个 0 即可。如果是固定字长，则其高 $k$ 位被舍弃，可以发现左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法。而乘一个常数 $C$ 只需要将 $C$ 改写为 2 的幂次的和或者差，例如执行 $x*14$ 编译器会将乘法重写为 $(x<<3)+(x<<2)+(x<<1)$ 或者更优地改为 $(x<<4)-(x<<1)$\n\n### 除以2的幂\n整数除法总是舍入到 0，即对于 $x\\ge 0, y>0$ ，结果是 $\\lfloor\\frac{x}{y}\\rfloor$ ，而对于 $x\\le 0, y>0$ ，结果是 $\\lceil \\frac{x}{y}\\rceil$ 。无符号数的右移一定是逻辑右移。\n\n**除以 2 的幂的无符号除法原理**: C 变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$ ，且 $0\\le k<w$ ，则 C 表达式 `x >> k` 产生数值 $\\lfloor \\frac{x}{2^k}\\rfloor$\n\n**除以 2 的幂的补码除法向下舍入原理**: C 变量 $x$ 和 $k$ 有补码值 $x$ 和无符号数值 $k$ ，且 $0\\le k<w$ ，则 C 表达式 `x >> k` 产生数值 $\\lfloor \\frac{x}{2^k}\\rfloor$\n\n## 浮点数\n### 二进制小数\n考虑一个形如 $b_mb_{m-1}\\cdots b_1b_0b_{-1}b_{-2}\\cdots b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值为 0 或 1 ，这种表示方法定义如下:\n$$\nb = \\sum_{i=-n}^{m} 2^i\\times b_i\n$$\n\n二进制小数点向左移动一位相当于这个数除以 2 ，向右移动一位相当于这个数被乘以 2。但是定点表示法不能很有效地表示非常大的数字。\n\n1. 将二进制小数转换为十进制小数: $110.101_2 = 2^2 + 2^1 + 2^{-1} + 2^{-3} = 6.625$\n2. 将十进制小数转换为二进制小数: 整数部分：除 2 取余数，直到商为 0 ，小数部分：乘 2 取整数，直到小数部分为 0 。比如表示 0.1 :\n$$\n\\begin{align*}\n0.1 \\times 2 = 0.2 \\tag0\\\\\n0.2\\times 2 = 0.4 \\tag0\\\\\n0.4\\times 2 = 0.8 \\tag0\\\\\n0.8\\times 2 = 1.6 \\tag1\\\\\n0.6\\times 2 = 1.2 \\tag1\\\\\n0.2\\times 2 = 0.4 \\tag0\\\\\n\\cdots\n\\end{align*}\n$$\n\n如此就可以将 0.1 表示为 $0.000110...$ ，如此循环，所以需要四舍五入存储到计算机当中，这就造成了误差。除此之外还比如 $0.875=0.111_2$ 。\n\n### IEEE浮点表示\nIEEE浮点标准用 $V = (-1)^s\\times M\\times 2^E$ 的形式来表示一个数:\n+ 符号(sign) $s$ : 决定 $V$ 是整数( $s=0$ ) 还是负数( $s=1$ ) ，而对于数值 0 的符号位解释作为特殊情况处理;\n+ 尾数(significand) $M$ : $M$ 是一个二进制小数，范围是 $1\\sim 2-\\varepsilon$ 或者 $0\\sim 1-\\varepsilon$ ;\n+ 阶码(exponent) $E$ : 作用是对浮点数加权，这个权重是 2 的 $E$ 次幂(可能是负数)。将浮点数的位表示划分为 三 个字段，分别对这些值进行编码:\n    + 一个单独的符号位 $s$ 直接编码符号 $s$ ;\n    + $\\rm{exp}$: 阶码位，以移码形式存储，位数决定数据的范围，用 $\\rm{e}$ 表示，其阶码值为 $\\rm{E}$ 。$\\rm{k}$ 位的阶码字段 $\\rm exp =$ $e_{k-1}\\cdots e_{1}e_0$ 编码阶码值 $\\rm E$ ;\n    + $\\rm frac$ : 尾数位，以原码形式存储，小数部分，其尾数决定小数的精度。$n$ 位小数字段 $\\rm frac= $ $f_{n-1}\\cdots f_1f_0$ 编码尾数 $M$ ，但是编码出来的值也依赖于阶码字段的值是否等于0。\n\n在单精度浮点格式(C语言中的 `float` ) 中，$\\rm s$、$\\rm exp$ 和 $\\rm frac$ 的字段分别为 1 位，$k=8$ 位和 $n = 23$ 位，得到一个 32 位的表示。\n在双精度浮点格式(C语言中的 `double` ) 中，$\\rm s$、$\\rm exp$ 和 $\\rm frac$ 的字段分别为 1 位，$k=11$ 位和 $n = 52$ 位，得到一个 64 位的表示。\n\n以一个 32 位的 `float` 为例，由符号位、指数位和小数位组成，如图所示\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/ALnuv.png\" width=\"\"></div>\n\n\n+ 符号位: 1 位，0 表示正数，1 表示负数;\n+ 指数位: 8/11(float/double) 位表示指数，可以表示 256/2048 种状态;\n> 因为指数可正可负，在 IEEE 标准里并没有选择用补码来表示负数，而是选择了直接向左平移(又叫**阶码**)，8 位的范围是 $[0, 255]$ ，我们将它向左平移一半(取127)，范围就变成了 $[-127, 128]$ ，也就是说指数位减去127才是真实的指数，比如 12(00001100) 代表 12-127 = -115 。这里减去的数叫**偏移量(biase)**，对单精度来说是127，对双精度来说是1023。\n+ 小数位: 23/52位，表示底数。显然底数的长度决定了类型的精度，决定了到底能存几位有效数字，而指数位只是表示小数点的位置;\n\n**Q.** 将 $78.625$ 转化为单浮点数形式。\n\n**A.** 首先将 $78.625$ 转化为二进制表示，为 $1001110.101$ ，即 $1.001110101\\times 2^6$ 。\n考虑指数位为 $6+127=133=10000101_2$ ，并将底数的小数点后面添加0补到23位，得到结果为:\n$$\n\\color{red}{0}\\color{green}{10000101}\\color{blue}{00111010100000000000000}\n$$\n\nIEEE-754浮点转换器: https://www.h-schmidt.net/FloatConverter/IEEE754.html\n\n> 注意到，由于第一位总是1，所以就不需要显式地表示它，这就获得了一个额外的精度位。\n\n### 非规约数 & 正零和负零\n考虑到指数范围为 $[-127, 128]$ ，也就是说能表示最大精度(`0x00000000`)为 $\\pm2^{-127}$ 。\n\n为了表示更小的数，在指数位全为0时，丢弃掉最高位为1的束缚，将最高位规定为0,将\"全0指数位\"规定为-126而不是本来的-127，用于表示绝对值小于 $2^{-126}$ 的数，这样的数就可以叫做**非规约数(denormal number)**\n\n比如 $\\color{red}{0}\\color{green}{00000000}\\color{blue}{00111010100000000000000}$ 表示的数为 $0.001110101\\times 2^{-126}=1.110101\\times 2^{-129}$ ，这样就可以表示 $\\pm 2^{-126-23} = \\pm2^{-149}$ 。\n\n而对于 0 的表示，因为符号位可以取1和0,即对应于负零和整零，在高级应用层面对于正零和负零的判定各不相同，C++中负零和整零相等，并且布尔值都对应于 `false` ，在运算过程一个理论答案为零的结果既可能被计算为正零，也可能被计算为负零。\n\n### 逐渐溢出\n规格数的最小值为 $0(00000001)0\\cdots 0_2 = 2^{-126}$ \n非规格数的最大值为 $0(00000000)1\\cdots 1_2 = (1-2^{-23})2^{-126}$ ，基本可以看做 $2^{-126}$ 的开区间，从非规格数过渡到规格数时，相当于指数 $-126$ 不变，底数进位到隐藏的高位。从而实现了平稳的值域过渡，刚好覆盖了实数轴，这种特性叫做**逐渐溢出(gradual overflow)**\n\n而这也是前面非规约数使阶码值为 $1-\\rm Bias$ 而不是 $-\\rm Bias$ 的原因。\n\n当二进制码从 `0x00000000` 不断递增时，它表示的浮点数值也是逐渐递增的。这对于非规约数到规约数来说表现为\"逐渐溢出\"，而对于规约数来说，小数部分不全为1的时候显然; 而当小数部分全为1的时候，再下一个数是小数位清零，指数位加1。\n例如 $0(0..01)11..11$ 对应浮点数的下一个是 $0(0..10)00..00$ ，而 $0(0..01)11..11$ 对应整数的下一个也是 $0(0..10)00..00$ 。根据这个特性，可以像整数一样对浮点数进行基数排序。\n\n### 无穷(inf)\n用指数位全为1的状态表示无穷，根据符号位的不同有正无穷和负无穷之分。无穷支持一些数学意义上的运算:\n+ 同号无穷被认为相等，正无穷 > 所有规约数 > 负无穷\n+ 无穷与规约数进行四则运算仍是无穷\n\nC++ 中可以使用 `1/0.0` 或者 `1e1000` 等赋值来得到一个无穷，他们都是一样的无穷，本质上是表示\"超过存储范围\"。输出 `inf` 或者 `-inf` 。\n\n### 非数值(NaN)\n非数值与无穷一样使用全为1的指数位表示，为了区分开来，小数位全为0时表示无穷，其他所有情况表示非数值情况。\n\n### 浮点数的范围和精度\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/AIb4d.png\" width=\"\"></div>\n\n\n对于32位规约数来说，指数位包括 $[-127, 128]$ ，但是由于左右端点表示其他值，所以实际指数位为 $[-126,127]$ 。\n\n**范围:** 考虑正数，前面计算过最小的规约数为 $2^{-126}$ ，而最大的规约数为 $0(11111110)1...1_2 \\approx 2^{128}$ ，所以极限范围就是 $[2^{-126}, 2^{128})$ ，转换为十进制就大约是 $[1.175\\times 10^{-38}, 3.403\\times 10^{38}]$ 。如果算上非规约数，那下界可以达到 $2^{-149}\\approx 1.401\\times 10^{-45}$ 。\n\n**精度:** 精度即底数有效数字的位数，底数有23位，而换算成十进制下就大约是7位小数，双精度的话就是大约15位。   \n\n### 舍入\n因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算，因此，对于值 $x$，我们使用一种系统的方法，能够找到最接近的匹配值 $x'$，它可以用期望的浮点形式表示出来，这就是舍入运算的任务。\n\nIEEE浮点格式定义了四种不同的舍入方式，默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。\n+ 向偶数舍入: 它将数字向上或者向下舍入，使得结果的最低的有效数字是偶数。\n+ 向零舍入：把正数向下舍入，把负数向上舍入。\n+ 向下舍入：把正数和负数都向下舍入。\n+ 向上舍入：把正数和负数都向上舍入。\n\n","tags":["CSAPP"]},{"title":"机器学习与模式识别:手写数字识别","url":"/2023/10/26/机器学习与模式识别-手写数字识别/","content":"\n## 实验内容\n1. 数据集选择\n2. Bayes判别分类\n3. Fisher 线性判别\n4. SVM的线性与非线性分类\n5. 不同分类器之间的比较\n\n> 原始数据集上传至网盘: https://pan.baidu.com/s/1uqmJg7EGxpKR62j-Qbr1ow?pwd=jjrc\n\n## 实验数据特征提取方法\n手写数字样本。每个数字有 $50$ 张图片，选择其中 $40$ 个作为训练集，$10$ 个作为测试集。\n\n首先将含有全部特征信息的手写数字图像从坐标轴中提取出来，将提取出来的书写数字图像进行二值化处理; 将处理后的每个数字图像提取 $5\\times 5$ 块模板，每个模块中 1 值像素点与总像素点的比值就是这个模块的特征值。将所有特征值放入 $5\\times 5$ 的矩阵。设定阈值 $T = 0.05$，每块内所对应的元素白像素占有率大于 $T$ ，则该块特征取1;否则取0。\n\n选择minst手写数字数据集，因为图片尺寸为 $28\\times 28$ 不为5的倍数，使用中心裁剪法将图像裁剪为25x25的大小再进行分块操作与特征提取。\n\n数据处理(特征提取) `dataset.m` 代码如下:\n```matlab\n% ----------\n%\n% 数据集处理\n%\n% ----------\n\nfunction [train_X, train_Y, test_X, test_Y] = load_datasets(train_pc)\n    % 参数设置\n    T = 0.05;\n    kernelSize = 5;\n    imgSize = 28;\n    sub_counts = floor(imgSize / kernelSize);\n    newImgSize = kernelSize * sub_counts;\n    train_X = [];\n    train_Y = [];\n    test_X = [];\n    test_Y = [];\n    \n    for digit = 0:9\n        digitFolderPath = fullfile('./mnist', num2str(digit));\n        imageFiles = dir(fullfile(digitFolderPath, '*.png'));\n        % 读取当前数字的所有图像数据\n        images = length(imageFiles);\n        for i = 1:images\n            imgPath = fullfile(digitFolderPath, imageFiles(i).name);\n            % 读取图像\n            img = double(imread(imgPath)); \n            % 中心裁剪图像\n            croppedImg = centerCropImage(img, newImgSize);\n            % 提取图像特征\n            features = getFeatures(croppedImg, kernelSize, T);\n            %features = img(:);\n            if i <= images * train_pc\n                % 划分为训练集\n                train_X = [train_X; features'];\n                train_Y = [train_Y; digit];\n            else\n                % 划分为测试集\n                test_X = [test_X; features'];\n                test_Y = [test_Y; digit];\n            end\n        end\n    end\n    \n    end\n    \n    \n    function croppedImg = centerCropImage(img, newImgSize)\n        [rows, cols] = size(img);\n        startRow = floor((rows - newImgSize) / 2) + 1;\n        startCol = floor((cols - newImgSize) / 2) + 1;\n        croppedImg = img(startRow:startRow + newImgSize - 1, startCol:startCol + newImgSize - 1);\n    end\n    \n    function features = getFeatures(img, kernelSize, T)\n        [rows, cols] = size(img);\n        % 计算分块数目\n        numBlocksRow = round(rows / kernelSize);\n        numBlocksCol = round(cols / kernelSize);\n        % 初始化特征向量\n        features = zeros(1, numBlocksRow * numBlocksCol);\n    \n        blockIndex = 1;\n        for i = 1:numBlocksRow\n            for j = 1:numBlocksCol\n                % 计算分块的起始和结束位置\n                startRow = (i - 1) * kernelSize + 1;\n                endRow = i * kernelSize;\n                startCol = (j - 1) * kernelSize + 1;\n                endCol = j * kernelSize;\n                % 计算分块的总像素数\n                totalPixels = kernelSize * kernelSize;\n                % 计算分块内白像素的个数\n                whitePixels = sum(sum(img(startRow:endRow, startCol:endCol) >= 250));\n                \n                % 根据阈值T判断特征取值\n                if whitePixels / totalPixels > T\n                    features(blockIndex) = 1;\n                else\n                    features(blockIndex) = 0;\n                end\n                blockIndex = blockIndex + 1;\n            end\n        end\n        features = features';\n    end\n```\n\n## 朴素Bayes判别分类\n\n### 理论基础\n设 $B_i$ 表示事件: 图片为数字 $i$ ，则由 Bayes 公式有\n$$\n\\begin{align*}\nP(B_i|A) = \\frac{P(A|B_i)P(B_i)}{\\sum_{j=0}^{9} P(A|B_j)P(B_j)} \n\\end{align*}\n$$\n\n其中，$P(B_i)$ 在这里是先验概率，在这里等于 0.1。$P(B_i|A)$ 是后验概率，在这里是对于一张手写数字图片(事件 $A$)上的数字是 $d$ ($0\\sim 9$ 对应事件 $B_0\\sim B_9$)的概率，由于这里是设计基于最小错误率的贝叶斯分类器，故而认为该数字为后验概率最大的数字。\n\n令 $\\mathbf{X}$ 表示图片集合，$\\mathbf{Y}$ 表示标签集合，则训练数据集可以表示为:\n$$\n\\mathbf{T} = \\{(\\bar{x}_1, y_1), (\\bar{x}_2,y_2),\\cdots, (\\bar{x}_n,y_n)\\}\n$$\n其中，$\\bar{x}_1,\\cdots,\\bar{x}_n\\in \\mathbf{X}$ , $y_1,\\cdots,y_n\\in \\mathbf{Y}$ ，对于任意的 $\\bar{x}_i$ 有 $\\bar{x}_i = \\{x_i^1, x_i^2, \\cdots, x_i^m\\}$ 意为第 $i$ 张图片的 $m$ 个特征。\n\n对于训练数据集 $P(X,Y)$ 独立同分布，所以有\n$$\nP(X|Y) = \\frac{P(X,Y)}{P(Y)}\n$$\n又有先验概率 $P(Y = c_k) = 0.1$ , $k=0,1,\\cdots,9$ , 而条件概率\n$$\nP(X=x|Y=c_k) = P(X^1=x^1,X^2=x^2,\\cdots,X^m=x^m|Y=c_k)\n$$\n又因为这里数据的条件概率分布是特征条件独立，所以进一步地可以表示为\n$$\nP(X=x|Y=c_k) = \\prod_{j=1}^m P(X^j=x^j|Y=c_k)\n$$\n\n> 在这里问题里的实际含义是: 对于测试集的任意一张 $28\\times 28$ 大小的手写数字图片，最后得到 25 个特征，每一个特征对应于每一个模块的取值。在朴素贝叶斯的假设条件下，这张图片是 1 的概率就是每一个特征都是 1 的特征的概率的累乘。\n\n进一步得到后验概率的计算公式:\n$$\nP(Y=c_k|X=x) = \\frac{P(Y=c_k)\\prod_j^m P(X^j=x^j|Y=c_k)}{\\sum_kP(Y=c_k)\\prod_j^m P(X^j=x^j|Y=c_k)}\n$$\n\n因为是要取最大值，所以可以去掉公分母，得到朴素贝叶斯分类器的判别式\n$$\ny = f(x) = \\max_{c_k} P(Y=c_k)\\prod_j P(X^j=x^j|Y=c_k)\n$$\n\n对每一个实验样本，选取前 40 个作为训练集，后 10 个作为测试集。\n\n编写代码 `bayesClassifier.m`\n```matlab\n% ----------\n%\n% 贝叶斯判别代码\n%\n% ----------\n\nclc, clear;\n% 重新加载数据\nload('datasets.mat');\n\n% v = mnistData{8}{1, 2};\n% A = reshape(v, 5, 5)';\n% disp(A);\n\n% 从每个类别中选择40个样本作为训练集，10个样本作为测试集\ntrain_samples = cell(10, 40);\ntest_samples = cell(10, 10);\n\nerror_count = 0;\nfor digit = 1:10\n    % 从当前类别中随机选择40个样本作为训练集\n    all_samples = mnistData{digit};\n%     random_indices = randperm(length(all_samples), 40);\n%     % disp(random_indices);\n%     train_samples{digit} = all_samples(random_indices, :);\n    \n    train_samples{digit} = all_samples(1:40, :);\n    % 剩余的10个样本作为测试集\n%     test_indices = setdiff(1:length(all_samples), random_indices);\n%     test_samples{digit} = all_samples(test_indices, :);\n    test_samples{digit} = all_samples(41:50, :);\n    %(test_indices);\nend\n\n% 重新计算先验概率和类条件概率\nnum_classes = 10; % 数字类别数量\nnum_features = 25; % 特征数量\nnum_train = 40; % 训练样本的数量\nnum_test = 10; % 测试样本的数量\n\ntrue_positives = zeros(1, num_classes); % 正类别被正确分类的样本数量\nfalse_positives = zeros(1, num_classes); % 负类别被错误分类成正类别的样本数量\nfalse_negatives = zeros(1, num_classes); % 正类别被错误分类成负类别的样本数量\n\nfor x = 1:10\n    for y = 1:10\n        % 获取第i个测试样本的特征向量\n        test_sample = test_samples{x}{y, 2};\n        \n        prior_prob = zeros(1, num_classes); % 先验概率\n        class_cond_prob = zeros(num_features, num_classes); % 类条件概率\n        pij = []; % i类的样本第j个特征为1的概率\n        for i = 1:num_classes\n            % 计算先验概率\n            prior_prob(i) = 0.1;\n            for j = 1:num_features % 每个数字图片提取出来的特征数\n                sum = 0;\n                for k = 1:num_train % 每个类别下训练样本的个数\n                    i_feature = train_samples{i}{k, 2}; % 获取第k个训练样本的特征向量\n                    sum = sum + i_feature(j);\n                end\n                % disp(sum);\n                pij(i,j) = (sum + 1) / (num_train + 2); % 计算概率估计值即Pj(ωi)，注意拉普拉斯平滑处理\n            end\n        end\n        for i = 1:num_classes\n            multi = 1;\n            for j = 1:num_features % 每个数字图片提取出来的特征数\n                if(test_sample(j) == 1)\n                    multi = multi * pij(i,j);\n                else\n                    multi = multi * (1 - pij(i,j));\n                end\n            end\n            class_cond_prob(i) = multi;\n        end\n        %计算后验概率\n        p_class = []; % 后验概率\n        sum = 0;\n        for i=1:num_classes%数字类别个数\n            sum = sum + prior_prob(i) * class_cond_prob(i);\n        end\n        for i = 1:num_classes % 数字类别个数\n            p_class(i) = prior_prob(i) * class_cond_prob(i) / sum;\n        end\n        [maxval, maxpos] = max(p_class);\n        if maxpos == x\n            true_positives(x) = true_positives(x) + 1;\n        else\n            error_count = error_count + 1;\n            false_positives(maxpos) = false_positives(maxpos) + 1;\n            false_negatives(x) = false_negatives(x) + 1;\n        end\n    end\nend\n\n% 计算准确率（acc）、精确率（precision）、召回率（recall）、F1-score\nprecision = true_positives ./ (true_positives + false_positives);\nrecall = true_positives ./ (true_positives + false_negatives);\nf1_score = 2 * (precision .* recall) ./ (precision + recall);\n\n% 计算错误率和正确率\nerror_rate = error_count / 100;\naccuracy = 1 - error_rate;\n\ndisp(['Accuracy: ', num2str(accuracy)]);\ndisp(['Precision: ', num2str(mean(precision))]); % Changed here\ndisp(['Recall: ', num2str(mean(recall))]); % Changed here\ndisp(['F1 Score: ', num2str(mean(f1_score))]); % Changed here\n```\n\n得到结果:\nAccuracy: 0.66\nPrecision: 0.67991\nRecall: 0.66\nF1 Score: 0.65476\n\n\n## Fisher判别分类\n使用 Fisher 线性判别方法求分类器的步骤:\n1. 计算各类的均值向量: $\\mu_i = \\frac{1}{N_i}\\sum_{x\\in X_i}x$ ;\n2. 计算各类的类内离散矩阵: $S_{wi} = \\sum_{x\\in X_i}(x-\\mu_i)(x-\\mu_i)^T$ ;\n3. 计算类内总离散矩阵: $S_w = S_{w0}+S_{w1}+\\cdots$ ;\n4. 计算总离散矩阵的逆矩阵: $S_w^{-1}$ ;\n5. 求出向量 $w^* = S_w^{-1}(\\mu_1-\\mu_0)$ ;\n6. 判别函数为: $y=(w^*)^Tx$ ;\n7. 求出判别函数的阈值: $w_0 = \\frac{(w^*)^T(\\mu_0+\\mu_1+\\cdots)}{2}$ ;\n8. 比较 $y$ 值与阈值的大小得出分类。\n\n```matlab\n% ----------\n%\n% Fisher分类代码\n%\n% ----------\n\nclc,clear;\nload('datasets.mat');\n% 初始化\n\nnumClasses = 10; % 类别数\nnumImages = 50; % 每个类别的图像数\nnumFeatures = 25; % 特征数\ntrainingSize = 40; % 训练集大小\n\n% 创建训练集和测试集\ntrainingData = zeros(numClasses * trainingSize, numFeatures);\ntrainingLabels = zeros(numClasses * trainingSize, 1);\ntestData = zeros(numClasses * (numImages - trainingSize), numFeatures);\ntestLabels = zeros(numClasses * (numImages - trainingSize), 1);\n\nfor i = 1:numClasses\n    for j = 1:numImages\n        if j <= trainingSize\n            trainingData((i-1)*trainingSize + j, :) = mnistData{i,1}{j,2};\n            trainingLabels((i-1)*trainingSize + j) = i;\n        else\n            testData((i-1)*(numImages - trainingSize) + j - trainingSize, :) = mnistData{i,1}{51-j,2};\n            testLabels((i-1)*(numImages - trainingSize) + j - trainingSize) = i;\n        end\n    end\nend\n\n% 使用Fisher线性判别方法进行训练\nMdlLinear = fitcdiscr(trainingData, trainingLabels, 'DiscrimType', 'pseudoLinear');\n% 对测试集进行预测\n\npredictedLabels = predict(MdlLinear, testData);\n\n% 计算错误率\nerrorRate = sum(predictedLabels ~= testLabels) / length(testLabels);\nfprintf('Error Rate: %.2f%%\\n', errorRate * 100);\n\n% 初始化\nprior = ones(1, numClasses) / numClasses; % 先验概率\n\n% 使用Fisher线性判别方法进行训练\nMdlLinear = fitcdiscr(trainingData, trainingLabels, 'DiscrimType', 'pseudoLinear', 'Prior', prior);\n\n% 对测试集进行预测\npredictedLabels = predict(MdlLinear, testData);\n\n% 计算错误率\nerrorRate = sum(predictedLabels ~= testLabels) / length(testLabels);\nfprintf('Error Rate: %.2f%%\\n', errorRate * 100);\n\n% 计算混淆矩阵\nC = confusionmat(testLabels, predictedLabels);\n\n% 计算准确率（accuracy）\naccuracy = sum(diag(C)) / sum(C(:));\nfprintf('Accuracy: %.2f%%\\n', accuracy * 100);\n\n% 计算精确率（precision）\nprecision = diag(C) ./ sum(C, 2);\nfprintf('Precision: %.2f%%\\n', mean(precision) * 100);\n\n% 计算召回率（recall）\nrecall = diag(C) ./ sum(C, 1)';\nfprintf('Recall: %.2f%%\\n', mean(recall) * 100);\n\n% 计算F1-score\nf1score = 2 * (precision .* recall) ./ (precision + recall);\nfprintf('F1-score: %.2f%%\\n', mean(f1score) * 100);\n```\n\n## 多分类支持向量机\n### 二分类支持向量机介绍\n对于线性不可分情况引入惩罚因子 $C$ ，于是广义最优分类面问题模型如下:\n$$\n\\max_{a} \\sum_{j=1}^N a_j - \\frac{1}{2}\\sum_{i=1}^{N}\\sum_{j=1}^{N} y_iy_ja_ia_jK(x_i,x_j) , s.t.\\sum_{ i=1}^N y_ia_i=0\n$$\n\n其中 $0\\le a_i\\le C$ 。\n\n### 特征选择\n用于训练SVM的特征使用的是图像的完整像素特征，即一张 $28\\times 28$ 的图像，它的特征向量的大小为 $1\\times 784$ 。将该特征进行标准化处理后即可用于训练SVM。\n\n### ECOC编码与多分类SVM\nECOC(Error-Correcting Output Codes)编码是一种纠错输出编码用于将多分类任务高效地转换为多个二分类任务。Mnist数据集有0~9个数字共10分类。对应的ECOC编码如下图:\n\n![FBxr2.png](https://raw.githubusercontent.com/wxLiu925/blog-images/master/FBxr2.png)\n\n代码如下:\n```matlab\n% ----------\n%\n% 支持向量机代码\n%\n% ----------\n\nclc,clear;\n\n[train_X, train_Y, test_X, test_Y] = load_datasets(0.8);\n\n% 核函数选择，可选：'linear','gaussian','rbf','polynomial'\nKernelFunction = 'polynomial';\n% 惩罚参数C确认\nC = 1000;\n\ntemplate = templateSVM(...\n    'KernelFunction', KernelFunction, ...\n    'PolynomialOrder', 3, ...\n    'KernelScale', 'auto', ...\n    'BoxConstraint', C, ...\n    'Standardize', true);\nsvm_model = fitcecoc(...\n    train_X, ...\n    train_Y, ...\n    'Learners', template);\n\n% spy(svm_model.BinaryY(1:40:400,:));\n% title('ECOC编码');\n% yticks(1:10);\n% yticklabels(0:9);\n% xlabel('分类器数目');\n\npredicted_labels = predict(svm_model, test_X);\n\n% 计算混淆矩阵\nC = confusionmat(test_Y, predicted_labels);\n\n% 计算准确率（accuracy）\naccuracy = sum(diag(C)) / sum(C(:));\nfprintf('Accuracy: %.2f%%\\n', accuracy * 100);\n\n% 计算精确率（precision）\nprecision = diag(C) ./ sum(C, 2);\nfprintf('Precision: %.2f%%\\n', mean(precision) * 100);\n\n% 计算召回率（recall）\nrecall = diag(C) ./ sum(C, 1)';\nfprintf('Recall: %.2f%%\\n', mean(recall) * 100);\n\n% 计算F1-score\nf1score = 2 * (precision .* recall) ./ (precision + recall);\nfprintf('F1-score: %.2f%%\\n', mean(f1score) * 100);\n```\n\n下表为使用全部特征进行训练、测试得到的结果。\n\n| 核函数 | 惩罚参数C | 准确率(%) | 精确率(%) | 召回率(%) | F1-score(%) |\n| :----: | :----: | :----: | :----: | :----: | :----: | \n| 线性 | 1 | 86.00 | 86.00 | 87.83 | 85.77 |\n| 线性 | 100 | 82.00 | 82.00 | 84.35 | 81.44 |\n| 线性 | 1000 | 82.00 | 82.00 | 84.35 | 81.44 |\n| 高斯 | 1 | 71.00 | 71.00 | 83.30 | 73.64 |\n| 高斯 | 100 | 72.00 | 72.00 | 82.89 | 73.80 |\n| 高斯 | 1000 | 72.00 | 72.00 | 82.89 | 73.80 |\n| 三次多项式 | 1 | 87.00 | 87.00 | 87.18 | 86.58 |\n| 三次多项式 | 100 | 87.00 | 87.00 | 87.18 | 86.58 |\n| 三次多项式 | 1000 | 87.00 | 87.00 | 87.18 | 86.58 |\n\n由上表得，三次多项式作为核函数效果最佳，且乘法参数C取值对评估结果没有影响。但如果选取原始特征提取方法(图像被分为5x5个块，一共提取了25个特征)，准确率将有所下降，仅能达到 60% 左右。\n\n## 各分类器间的比较\n无论是贝叶斯判别还是Fisher分类，两者改为多分类方法比较容易。SVM是一个性能很好的二分类算法，然而在进行多分类任务时需要多个SVM才能进行，这导致SVM在多分类任务中的准确率下降。本次实验如果全部使用提取特征后的数据来训练模型，Fisher判别表现最好，准确率在74%；其次是贝叶斯判别，准确率在66%. SVM分类效果最差，准确率为61%.\n     \n总的来说，分类算法的选择更多取决于数据集。如果数据集规模较大，且基本线性可分，使用贝叶斯或是Fisher判别效率更高，反之应使用SVM处理更加复杂的非线性分类任务。","tags":["Bayes","Fisher","SVM","matlab"]},{"title":"C++面经Part1","url":"/2023/10/25/C-面经Part1/","content":"### const\n主要有以下作用:\n1. 修饰变量，说明该变量不可改变;\n2. 修饰指针，这里分为**指向常量的指针(指针常量，pointer to const)**和**自身是常量的指针(常量指针，const pointer)**\n```cpp\nint a = 0, b = 10;\nconst int *p1 = &a; // 指针常量，指向的值不可以使用*p修改，*p = 10 错误，可以修改指向的地址\nint *const p2 = &a; // 常量指针，指针指向的地址不可改变，p2 = &b 错误，可以修改该地址的变量值\n```\n3. 修饰引用，指向常量的引用，用于形参类型，既避免了拷贝，又避免了函数对值进行修改\n4. 类内修饰成员函数，说明该成员函数内不能修改成员变量\n\n```cpp\n#include <iostream>\n\nclass A {\nprivate:\n    const int a;\npublic:\n    // 构造函数\n    A() : a(0) { };\n    A(int x) : a(x) { };\n\n    // const可用于对重载函数的区分\n    // 普通成员函数\n    void func() {\n        std::cout << \"这是一个普通函数\" << std::endl;\n    }\n    // 常成员函数，不得修改类中任何数据的值\n    void func() const {\n        std::cout << \"这是一个常函数\" << std::endl;\n    }\n};\n\nint main() {\n    A obj1;\n    const A obj2;\n    obj1.func(); // \"这是一个普通函数\"\n    obj2.func(); // \"这是一个常函数\"\n    return 0;\n}\n```\n需要注意的是，普通对象可以调用普通函数也可以调用常函数，前者优先，如果是常量对象的话，只能调用常函数，如果调用普通函数会导致报错。\n\n进一步地\n```cpp\n// 函数\nvoid function1(const int Var);           // 传递过来的参数在函数内不可变\nvoid function2(const char* Var);         // 参数指针所指内容为常量\nvoid function3(char* const Var);         // 参数指针为常量\nvoid function4(const int& Var);          // 引用参数在函数内为常量\n// 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰\n\n// 函数返回值\nconst int function5();      // 返回一个常数\nconst int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();\nint* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();\n```\n\n### static\n主要有以下作用:\n1. **修饰普通变量:** 修改变量的存储区域和生命周期，使变量存储在静态区域，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。需要注意的是: 在函数内部定义了一个静态变量，生命周期到程序结束，但是这个变量的作用域仅限于声明它的函数内部。\n```cpp\nvoid myFunction() {\n    static int count = 0; // 静态局部变量\n    count++;\n    std::cout << \"Count: \" << count << std::endl;\n}\n\nint main() {\n    myFunction(); // 输出 Count: 1\n    myFunction(); // 输出 Count: 2\n    // 这里无法直接访问 count\n    return 0;\n}\n```\n2. **修饰普通函数:** 表明函数的作用范围，仅在定义该函数的文件内才能使用，它的作用域被限制在声明它的文件中，即它变成了一个“内部链接”的函数，只能在当前文件内部访问。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n```cpp\n// File1.cpp\nstatic void myFunction() {\n    std::cout << \"这是一个静态函数\" << std::endl;\n}\n// File2.cpp\nvoid anotherFunction() {\n    myFunction(); // 错误，无法访问静态函数\n}\n```\n3. **修饰成员变量:** 修饰成员变量时该变量将被所有该类的对象共享，而不是每个对象拥有一份副本，而且不需要生成对象就可以访问该成员。\n```cpp\nclass MyClass {\npublic:\n    static int count; // 静态成员变量\n};\n\nint MyClass::count = 0; // 静态成员变量的初始化\n\nint main() {\n    MyClass obj1;\n    MyClass obj2;\n\n    obj1.count = 5;\n    std::cout << obj2.count << std::endl; // 输出 5\n\n    return 0;\n}\n```\n4. **修饰成员函数:** 修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内只能访问 static 成员。\n\n### this 指针\n`this` 指针是一个特殊的指针，它指向当前对象的地址。在 C++ 中，每个类的非静态成员函数都有一个隐含的 `this` 指针，它指向调用该成员函数的对象。\n\n当一个类对象调用成员函数时，编译程序先将对象的地址赋给了 `this` 指针，然后调用该成员函数，每次成员函数存取数据成员时，都其实是在隐式地使用 `this` 指针。\n\n`this` 指针是一个常量指针，被隐含地声明为: `ClassName *const this` ，这意味着不能给 `this` 指针赋值，而在 `const` 成员函数里被声明为 `const ClassName* const`\n\n最后还需要注意的是，`this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址(不能 `&this`)\n\n### 左值和右值(引用)\n1. 左值(lvalue)\n+ 左值既能够出现在等号左边，也能出现在等号右边\n+ 左值可以被赋值，可以作为赋值语句的目标\n+ 左值是可寻址的变量，有持久性\n+ 具体来说，变量、对象或者通过解引用获得的指针都属于左值\n```cpp\nint x = 5; // x 是左值，因为它代表一个内存位置，可以被赋值\nint* ptr = &x; // &x 是左值，因为它是变量 x 的地址\n```\n\n2. 右值(rvalue)\n+ 右值是不能被赋值的表达式，它们代表的是一个数值或者临时值，通常在赋值语句的右侧\n+ 右值可以是一个常数、一个临时的计算结果或者一个表达式的返回值。\n+ 右值在使用后就失去意义，因此不能被取地址\n```cpp\nint y = 10; // 10 是右值，因为它代表一个数值，不能被赋值\nint z = x + y; // x + y 是右值，因为它代表一个临时计算结果\n```\n\n> C++ Primer:\" 当一个对象被用作右值的时候，用的是对象的值(内容);当对象被用作左值时，用的是对象的身份(在内存中的位置)\"\n\n左值引用(lvalue reference)和右值引用(rvalue reference)是C++中引入的两种不同类型的引用。\n\n3. **左值引用:** 左值引用是最常见的引用类型。它们使用 `&` 符号声明，并且只能绑定到左值(可以取地址的表达式)。\n4. **右值引用:** 右值引用是在C++11中引入的新特性，用 && 符号表示。它们可以绑定到临时值、表达式结果或具有名称的右值。\n```cpp\nint x = 6; // x是左值，6是右值\nint &y = x; // 左值引用，y引用x\n\nint &z1 = x * 6; // 错误，x*6是一个右值\n\nint &&z2 = x * 6; // 正确，右值引用\nint &&z3 = x; // 错误，x是一个左值\n```\n> 可以引用右值的除了右值引用外还有 const 左值引用，例如 `const int &z4 =  x * 6;` 正确，可以将一个const引用绑定到一个右值。例如 `std::vector` 的 `push_back` 函数就使用了 const 左值引用(`void push_back (const value_type& val);`) ，这样能让我们使用 `v.push_back(1)` 这样的代码。\n\n`std::move` 可以实现将左值转换成右值以实现对左值进行右值引用\n```cpp\nint i = 3, j;\nj = std::move(2); // 合法，从一个右值移动数据\nj = std::move(i); // 合法，从一个左值移动数据，i的值之后是不确定的。\n```\n\n### inline 内联函数\n主要有以下特征:\n+ 相当于把内联函数里面的内容写在调用内联函数处;\n+ 相当于不用执行进入函数的步骤，直接执行函数体;\n+ 相当于宏，却比宏多了类型检查，真正具有函数特性;\n+ 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数;\n+ 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。\n\n```cpp\n// 一般在类内定义的成员函数会隐式成为inline，而在类外定义的成员函数不会(当然是否内联完全取决于编译器)\n// 类内定义，隐式内联\nclass A {\n    int doA() { return 0; }         // 隐式内联\n}\n// 类外定义，需要显式内联\nclass A {\n    int doA();\n}\ninline int A::doA() { return 0; }   // 需要显式内联\n```\n\n虚函数可以是内联函数吗？\n[Standard C++: Are “inline virtual” member functions ever actually “inlined”?](https://isocpp.org/wiki/faq/value-vs-ref-semantics#:~:text=Therefore%20the%20only%20time%20an,or%20reference%20to%20an%20object.)\n[Stackoverflow: Can virtual functions be inlined [duplicate]](https://stackoverflow.com/questions/18432040/can-virtual-functions-be-inlined)\n\n虚函数可以是内联函数，但是当虚函数表现出多态性的时候不能内联，因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性的时候不可以内联。\n\n下面是虚函数内联使用例子\n```cpp\n#include <iostream>\n\nclass Base {\npublic:\n    inline virtual void who() {\n        std::cout << \"I am Base\" << std::endl;\n    }\n    virtual ~Base() { }\n};\n\nclass Derived: public Base {\npublic:\n    // // 不写 inline 时会隐式内联\n    inline void who() {\n        std::cout << \"I am Derived\" << std::endl;\n    }\n};\n\nint main() {\n    Base fa;\n    fa.who(); // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。\n\n    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。\n    Base *ptr = new Derived();\n    ptr->who();\n\n    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。\n    delete ptr;\n    ptr = nullptr;\n\n    return 0;\n}\n```\n\n具体来说，就是\n1. 当使用类的对象来调用时，则虚函数可以当做是内联的，因为编译器在编译时就确切知道对象是哪个类的;\n2. 当使用基类指针或引用来调用虚函数时，它都不能是内联函数，因为调用发生在运行时，是动态绑定的。\n\n","tags":["C++"]},{"title":"CSAPP-计算机系统漫游","url":"/2023/10/23/CSAPP-计算机系统漫游/","content":"之前在读 xv6-book 的时候，发现自己对一些计算机底层的知识了解的太少，导致看到虚拟内存映射、物理地址这些东西的时候就很头大。在一个群友的推荐下，我决定先来看一下CSAPP的1、2、3、6、7、8、9章(当然，还有一种方案是学习CS61C)，于是有了这个系列。\n\ngitbook: https://hansimov.gitbook.io/csapp/\n\n## 系统的硬件组成\n### 1.总线\n总线是贯穿整个系统的一组电子管道。它们携带者信息字节在各个部件之间传递，传送定长的字节块(字)。字中的字节数(字长)是一个基本的系统参数，通常是4个字节(32位)、8个字节(64位)。\n\n### 2.I/O 设备\n示例有作为用户输入的键盘和鼠标，作为用户输出的显示器，用于长期存储数据和程序的磁盘驱动器(磁盘)。每个 I/O 设备都通过一个**控制器**或者**适配器**与 I/O 总线相连。\n> 控制器和适配器之间的区别在于它们的封装方式: 控制器是 I/O 设备本身或系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。功能都是在 I/O 总线和 I/O 设备之间传递信息。\n\n### 3.主存\n主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组 **动态随机获取存储器(DRAM)** 芯片组成;从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。\n\n### 4.处理器\n**中央处理单元(CPU)**简称为处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或**寄存器**)，称为**程序计数器(PC)**。在任何时刻，PC都指向主存中的某条机器语言指令(该指令的地址)\n\n处理器从通电到系统断电一直在不断从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令。\n\n这样的操作围绕着主存、寄存器文件(register file)和算数/逻辑单元(ALU)进。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。\n\nCPU在指令的要求下可能会执行如下操作:\n+ **加载:** 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容;\n+ **存储:** 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容;\n+ **操作:** 把两个寄存器的内容复制到ALU，ALU对这两个字做算数运算，并将结果存放到一个寄存器中;\n+ **跳转:** 从指令本身抽取一个字，并将这个字复制到PC中，以覆盖PC中原先的值。\n\n## 操作系统管理硬件\n操作系统有两个基本功能∶ \n1. 防止硬件被失控的应用程序滥用;\n2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。\n\n操作系统通过几个基本的抽象概念(**进程、虚拟内存和文件**)来实现。\n\n> 文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。\n\n### 进程\n进程是操作系统对一个正在运行的程序进行的一种抽象。一个CPU在同一时间只能执行一个进程，但是可以**并发运行**，即一个进程的指令和另一个进程的指令是交错执行，操作系统实现这种交错执行的机制称为**上下文切换**，而上下文就是操作系统保持跟踪进程运行所需的所有状态信息。\n\n### 线程\n在现代操作系统中，一个进程实际上可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。\n\n### 虚拟内存\n使用 xv6 里的解释\n\n虚拟内存是每个进程都会有自己独立的 page table，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的 page table 中。\n> 就比如 ls 程序会有一个内存地址 0，echo 程序也会有一个内存地址 0，但是操作系统会将两个程序的内存地址0映射到不同的物理内存地址，所以ls程序不能访问echo程序的内存，同样echo程序也不能访问ls程序的内存。\n\n### 文件\n文件就是字节序列。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。\n\n## 系统之间利用网络通信\n从一个单独的系统来看，网络可视为一个 I/O 设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。","tags":["CSAPP"]},{"title":"微信Robot使用手册","url":"/2023/10/22/微信Robot使用手册/","content":"\n> bot wechat id: liuwx_robot\n\n该机器人依赖于 [chatgpt-on-wechat](https://github.com/zhayujie/chatgpt-on-wechat) 项目进行开发\n\n主要在私聊和群聊中使用，私聊需要使用 bot 作为前缀，比如发送:\"bot 你是谁？\"，如果没有前缀将会被视为普通消息而不予回复。群聊直接 @ 即可。\n\n## 角色功能如下:\n\n以下示例指令都使用 `bot` 为前缀，这是在私聊场景中的使用方法，在群聊中，你只需要将 `bot` 前缀更换为 @ bot 即可。\n\n### 1.Chatgpt3.5\nbot 接入了 chatgpt3.5 ，可以回复你想问的任何问题，即你可以直接将该 bot 当作一个不需要挂代理的 chatgpt 使用，需要注意的是，问题回复的时间将由此时的网络代理环境和回复答案的字数而定，请耐心等待。\n\n### 2.语音识别\nbot 可以进行语音识别，你可以直接发送语音消息进行提问，bot 会对私聊和群聊中所有的语音消息进行识别并且作出回复，需要注意的是，你应该尽量使用标准的普通话。\n\n### 3.AI绘画\nbot 接入了基于 LinkAI 提供的 Midjourney 绘画，提问时只需要以为 \"画\" 为开头即可完成绘画，比如在私聊场景下你可以发送 \"bot 画一只青蛙\" 来进行绘画。\n\n### 4.文档总结\nbot 接入了基于 LinkAI 提供的文档总结对话，你向机器人发送 **文件** 或 **分享链接卡片** 即可生成摘要，进一步可以与文件或链接的内容进行多轮对话。\n> 值得注意的是，目前 bot 仅支持 txt, docx, pdf, md, csv 格式的文件，同时文件大小不能超过 5M ，文件字数最多可支持百万字的文件。分享链接 目前仅支持 公众号文章，后续会支持更多文章类型及视频链接等。\n\n### 5.角色预设\nbot 可以进行角色设定，具体使用方法以及可用角色设定可以使用 `bot $role help` 即可进行查看。\n\n### 6.冒险游戏\n使用 `bot $开始冒险 <故事背景>` ，如果不填写故事背景则会使用默认故事背景，bot 回复后你需要继续告诉 bot 后续发展，这样在你的引导下 bot 会慢慢完善这个完整的冒险游戏。\n\n### 7.管理员指令\n可以根据 `@bot #help` 进行查看，设置管理员需要在私聊中设置，具体方法为 `#auth <口令>` ，口令仅有我本人知晓。\n\n目前该机器人部署在我的个人电脑上，因此仅在开机时可以使用，后续会考虑将其部署至服务器上。\n\n该 bot 使用日期为即日起至 bot 被腾讯风控或者本人无力继续维护时，且用且珍惜。","tags":["Robot"]},{"title":"Hello World","url":"/2023/10/19/hello/","content":"\n> 你好, 世界!\n\n本博客搭建于2023年10月18日，使用 github pages + hexo 进行搭建，使用 aircloud 主题，这是一个简洁轻量的 hexo 博客主题。\n\n这是笔者第三次搭建博客，第一次也是使用 hexo 搭建的一个静态博客，可惜后来在维护过程中遇到了一些当时无法解决的问题，于是放弃。第二次是使用腾讯云服务器，基于 wordpress 框架搭建的一个动态网站，还给它取了一个响亮的名字 —— 「牛牛网」，只是可惜在使用几个月之后因为一直忙于其他事没有管理，又刚好被人注入赌博网站的暗链，导致网站被查封了。\n\n大概快一个月前，我在知乎上发布了这样一条想法:\n> \"感觉简中互联网环境下很难找到一个可以随便分享东西的平台，微信朋友圈发东西需要考虑一些微信好友的感受(浏览很多知乎问题可以看出来大家对朋友发pyq的戾气)，小红书和vb环境太差，知乎里发想法没试过，但是感觉应该也不怎么好用，其实tt是一个很合适的平台，但是感觉海外的中文互联网是一个很小的圈子大部分都是中国留学生和一些出去释放压力的非正常人完全融入不进去，而且也不想发的东西完全没人看(是的，我就是这么矛盾，想让别人看又不想让别人看)\"\n\n今天突然想到，自己搭一个网站或许是一个不错的选择，于是就有了现在的这个网站。换句话说，搭建这个网站的初衷其实不是作为一个知识分享的平台，而且作为一个个人生活分享平台，平时也许会发布一些碎碎念、一些随想随记，又或者是一些学习笔记，总而言之，这将会是一个独属于我自己的小世界，发布的内容完全随机，所以，如果某些文章内容对你造成了一些不好的影响，在此我深表歉意。\n\n我其实是一个分享欲比较强烈的人，但是从广义上来看，人生本来就是一场孤独的旅行，所以，我总是需要写点什么东西来聊以慰藉。也希望大家都能多多记录一下自己，不为被看见，只为留下痕迹。每一个当下，每一刻的感受，都是我们活着的证据。更重要的是，每一分、每一秒都是倒计时，请务必为自己而活。\n\n2023年10月19日，于湖北武汉记。"}]