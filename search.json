[{"title":"万物的开始:Riemann积分","url":"/2023/11/15/万物的开始-Riemann积分/","content":"\n> *“微积分是近代数学中最伟大的成就，对它的重要性无论做怎样的估计都不会。”*\n\n在现代数学体系里，「微积分」是及其重要的组成部分，而积分又由不定积分和定级分组成，后者又被称作「黎曼积分」(Riemann integral)。微积分发展至今，黎曼积分首次对函数在给定区间上的积分给出了一个精确定义。\n\n### Riemann积分定义\n设函数 $f$ 在区间 $[a,b]$ 上有定义\n\n$\\rm \\textbf{Definition 1.}$ 如果点集 $P=\\{x_0,x_1,\\cdots,x_n\\}$ 满足 $a=x_0<x_1<\\cdots<x_{n-1}<x_n=b$ , 则称 $P$ 为 $[a,b]$ 的一个**分划**. 设 $\\Delta x_i = x_i-x_{i-1},i=1,2,\\cdots,n$ , 则称 $||P|| = \\max\\limits_{1\\le i\\le n} \\{\\Delta x_i\\}$ 为分划 $P$ 的**细度** . 如果 $\\Delta x_i=\\frac{b-a}{n},i=1,2,\\cdots,n$ , 则称 $P$ 为**等距分划**\n\n$\\rm \\textbf{Definition 2.}$ 设 $P$ 是区间 $[a, b]$ 的一个分划，对每个子区间 $[x_{i-1},x_i]$ , 任取 $\\xi_i\\in [x_{i-1},x_i]$ , 则称 $\\xi = \\{\\xi_i|i=1,2,\\cdots,n\\}$ 为从属于 $P$ 的一个**介点集**; 并称和式 $\\sum\\limits_{i=1}^n f(\\xi_i)\\Delta x_i$ 为 $f$ 在区间 $[a,b]$ 上的一个**Riemann和**.\n\n$\\rm \\textbf{Definition 3.}$ 设 $I$ 为实数，且有 $\\lim\\limits_{||P||\\to 0}\\sum\\limits_{i=1}^n f(\\xi_i)\\Delta x_i = I$ , 即 $\\forall \\varepsilon >0$ , $\\exists \\delta > 0$ , 对 $||P||<\\delta$ 的每个分划 $P$, 以及对从属于 $P$ 的每个介点集 $\\xi$ , 成立 $|\\sum\\limits_{i=1}^n f(\\xi_i)\\Delta x_i - I|<\\varepsilon$ , 则称函数 $f$ 在区间 $[a,b]$ 上**Riemann可积**或简称**可积**, 记为 $f\\in R[a,b]$ . 并称 $I$ 为 $f$ 在区间 $[a,b]$ 上的**Riemann积分**或**定积分**, 简称积分, 记为 $\\int_a^b f = I$ .\n\n### Riemann可积条件\n\n$\\rm \\textbf{Definitions 4.}$ 设函数 $f$ 在 $[a,b]$ 上有界, $P$ 为 $[a,b]$ 的一个分划, 对 $i=1,2,\\cdots,n$ , 记\n$$\n\\begin{align*}\nM_i &= \\sup\\{f(x)|x\\in [x_{i-1},x_i]\\}\\\\\nm_i &= \\inf\\{f(x)|x\\in [x_{i-1},x_i]\\}\\\\\n\\end{align*}\n$$\n称 $w_i = M_i-m_i$ 为 $f$ 在 $[x_{i-1},x_i]$ 上的**振幅**, $\\sum\\limits_{i=1}^n w_i\\Delta x_i$ 为 $f$ 的**振幅面积**.\n\n$\\rm \\textbf{Proposition 1.}$(可积的第一充要条件): 有界函数 $f\\in R[a, b]$ 的充分必要条件是\n$$\n\\begin{align}\n\\lim_{||P||\\to 0}\\sum_{i=1}^n w_i \\Delta x_i = 0\n\\end{align}\n$$\n\n$\\rm \\textbf{Proposition 2.}$(可积的第二充要条件): 有界函数 $f\\in R[a, b]$ 的充分必要条件是对每个 $\\varepsilon > 0$ , 存在区间 $[a,b]$ 的一个分划 $P$ 使得\n$$\n\\begin{align}\n\\sum_{P}w_i\\Delta x_i< \\varepsilon\n\\end{align}\n$$\n\n$\\rm \\textbf{Proposition 3.}$(可积的第三充要条件): 有界函数 $f\\in R[a, b]$ 的充分必要条件是 $\\forall \\varepsilon, \\eta >0$, 存在 $[a,b]$ 的分划 $P$ , 使振幅不小于 $\\eta$ 的子区间的长度之和小于 $\\varepsilon$ .\n\n利用定级分定义以及三个充分必要条件可以得到一些推论:\n1. 设 $f\\in R[a, b]$ , 则 $f$ 在 $[a, b]$ 上有界\n2. 设 $f\\in C[a, b]$ , 则 $f\\in R[a, b]$\n3. 设 $f$ 在 $[a, b]$ 上有界且只有有限个间断点，则 $f\\in R[a, b]$\n4. 设 $f$ 在 $[a, b]$ 上单调, 则 $f\\in R[a, b]$\n\n下面对这四个结论一一进行证明\n\n$\\rm \\textbf{Corollary 1.1} \\quad Proof.$ 记 $\\int_a^b f = I$ , 由定积分定义知, 对于 $\\varepsilon = 1$, 存在一个分划 $P$ , 使得对于从属于这个 $P$ 的任何介点集 $\\xi$ 均成立\n$$ \n\\left|\\sum_{i=1}^n f(\\xi_i)\\Delta x_i - I\\right| < 1\n$$\n对于确定的子区间 $[x_{i-1},x_i]$ , 固定所有的 $\\xi_k$($k\\ne i$) 对 $f(\\xi_i)$ 作出如下估计\n$$\n\\frac{1}{\\Delta x_i}(I-1-\\sum_{k\\ne i}f(\\xi_{k}\\Delta x_k)) < f(\\xi_i)<\\frac{1}{\\Delta x_i}(I+1-\\sum_{k\\ne i}f(\\xi_k)\\Delta x_k)\n$$\n由于 $\\xi_i \\in I_i = [x_{i-1},x_i]$ 的任意性, 可得 $f$ 在 $[a, b]$ 上有界.\n\n$\\rm \\textbf{Corollary 1.2} \\quad Proof.$\n","tags":["数学分析","积分"]},{"title":"数字图像处理Lab1-图像增强的空域方法","url":"/2023/11/11/数字图像处理Lab1-图像增强的空域方法/","content":"\n这个系列是针对数学图像处理课程的实验以及大作业写的手册。原始代码已上传至github。四次实验的内容分别为:\nLab1: 图像增强的空域方法\nLab2: 图像增强的频域方法\nLab3: 图像压缩编码实现\nLab4(大作业): 美颜算法原理及其实现\n\n地址: https://github.com/wxLiu925/Whut-ExperimentProject/tree/main/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80\n\n## 实验内容(Lab1)\n1. 读入一副彩色图像(非卡通), 大小为256*256, 观察它的每个点象素;将该彩色图像变成灰度图像; 将该图像的直方图画出来, 要求自己编写函数绘制直方图的函数。\n2. 自己编写函数，进行直方图均衡化，并显示均衡化后的图像。\n3. 将该彩色图像使用 imnoise 函数加入各种噪声，显示图像；或者读入一副低\n质量被噪声污染的图像。\n4. 分别使用 conv2 函数、fspecial 函数和 imfilter 函数，对受噪声污染的图像进行均值滤波和中值滤波、高斯滤波。要求设置不同大小的均值滤波模板，改变权值，测试试验结果。中值滤波要求能设置不同的滤波窗口大小，显示结果。请尽量使用矩阵的整体运算，来代替循环计算。\n5. 读入另外一副图像，对其采取不同的 roberts/laplace/sobel/priwitt 边缘锐化算子进行边缘增强和锐化，并显示不同算子的计算结果。对原始图像加入噪声，观察锐化后的效果。要求：请尽量避免循环运算，而使用矩阵整体运算。\n6. 结合试验结果，对不同图像空域增强方法进行分析和比较，写出你的实验体会。\n7. 对锐化算子的处理结果中，如果计算得到小于零的值，对小于 0 的部分，采用不同的方法标准化到[0,255]时，图像的显示效果有什么不同？为什么？\n\n## 实验原理\n这个实验没什么好讲的，实验内容比较简单，也比较繁杂，更多细节请看代码注释。\n### T6\n1. 均值滤波和高斯滤波：这两种方法都是线性滤波器，主要用于减少图像中的噪声。均值滤波器简单易用，但可能会使图像变得模糊。高斯滤波器可以更好地保留图像的细节，但计算复杂度较高。\n2. 中值滤波：中值滤波是一种非线性滤波器，特别适合于去除椒盐噪声。它可以保留图像的边缘信息，但可能会导致图像的纹理信息丢失。\n3. Sobel、Laplace、Prewitt和Roberts边缘检测：这些方法都是用于图像的边缘检测和锐化。Sobel和Prewitt操作符可以更好地保留边缘信息，但对噪声敏感。Laplace操作符可以检测所有方向的边缘，但可能会导致边缘变得较薄。Roberts操作符简单易用，但可能会错过一些细微的边缘信息。\n\n总的来说，如果图像中存在大量的高斯噪声，应该选择使用高斯滤波器。如果需要检测图像的边缘，则应该选择使用Sobel或Laplace操作符。\n\n### T7\n在图像处理中，像素值通常被标准化或缩放到[0,255]的范围。当我们应用锐化算子后，有可能得到小于0的值。对于这些小于0的值，我们需要进行处理以便能在[0,255]的范围内表示。以下是两种常用的处理方法：\n1. 截断处理：这种方法将所有小于0的值设为0。这是最直接的方法，但可能会导致一些信息丢失，因为所有小于0的值都变成了同样的值（即0）。\n2. 缩放处理：这种方法将所有的值（包括大于0的值）线性缩放到[0,255]的范围。这种方法可以保留更多的信息，因为它保持了原始数据中的相对差异。但这种方法可能会使图像看起来较暗，因为所有的值都被缩小了。\n这两种方法会导致不同的显示效果。截断处理可能会导致图像在某些地方看起来有\"断裂\"，因为所有小于0的值都变成了0，可能会造成边缘信息的丢失。而缩放处理则能保留更多的边缘信息，但可能会使整个图像看起来较暗。","tags":["C++","OpenCV"]},{"title":"CSAPP-第二章(Homework)","url":"/2023/11/01/CSAPP-第二章-Homework/","content":"### 2.57\n> 编写程序 `show_short` 、`show_long` 、`show_double`，它们分别打印类型为 `short`、`long` 和 `double` 的字节表示。\n\n`char` 是字符型，但也是属于整形的，因为 `char` 最终存储的是 ASCLL 码值到内存的。一个 `char` 有 8 个位，所以能存储的范围为 $-128\\sim 127$ ，而 `unsigned char` 存储的范围为 $0\\sim 255$ 。因为它占用一个字节，所以 `unsigned char` 可以精确地表示一个字节的所有可能值，所以它通常用于存储和处理字节数据。\n\n```c\n#include <stdio.h>\n\ntypedef unsigned char *byte_pointer;\n\n// 大端\nvoid show_byte(byte_pointer start, size_t sz) {\n    // 展示十六进制\n    for(int i = 0; i < sz; i ++) {\n        printf(\"%.2x\", start[i]);\n    }\n    printf(\"\\n\");\n    // 展示二进制(大端)\n    for(int i = 0; i < sz; i ++) {\n        for(int j = 7; j >= 0; j --) {\n            printf(\"%d\", (start[i] >> j) & 1);\n            if(j % 4 == 0) printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}\n\nvoid show_short(short num) {\n    printf(\"short: \\n\");\n    show_byte((byte_pointer)&num, sizeof(short));\n}\n\nvoid show_long(long num) {\n    printf(\"long: \\n\");\n    show_byte((byte_pointer)&num, sizeof(long));\n}\n\nvoid show_float(float num) {\n    printf(\"float: \\n\");\n    show_byte((byte_pointer)&num, sizeof(float));\n}\n\nvoid show_double(double num) {\n    printf(\"double: \\n\");\n    show_byte((byte_pointer)&num, sizeof(double));\n}\n\nint main() {\n    int num = 365;\n    show_short((short)num);\n    show_long((long)num);\n    show_float((float)num);\n    show_double((double)num);\n    return 0;\n}\n```\n\n### 2.58\n> 编写过程 `is_little_endian` ，当在小端法机器上编译和运行时返回1，在大端法机器上编译运行时则返回0。这个程序应该可以运行在任何机器上，无论机器的字长是多少。\n\n计算机存储数据在地址上都是由低到高，大小端的区别为小端法存储数据由低位到高位，而大端法则是由高位到低位，例如数据 `0x12345678` 小端法存储就是 `78 56 34 12`，而大端法存储则是 `12 34 56 78` 。\n可以使用 `union` 来实现，在 `union` 中存放两个数据，一个 `int` 一个 `char` ，`char` 占的地址为 `int` 数据的第一个字节，修改 `int` 值为1，这样就只需要判断 char 数据是否为 1 即可。\n\n```c\nint is_little_endian() {\n    union {\n        int i;\n        char c;\n    } test;\n    test.i = 1;\n    return (int)test.c;\n}\n```\n\n### 2. 59\n> 编写一个 C 表达式，它生成一个字，由 $x$ 的最低有效字节和 $y$ 中剩下的字节组成。对于运算数 `x = 0x89ABCDEF` 和 `y = 0x76543210` 得到 `0x765432EF`。\n\n+ **位(bit)是计算机内部数据存储的最小单位**，只能取0或者取1;\n+ **字节(byte)是计算机数据处理的最小单位**，每个字节有8个二进制位，其中最右边的一位为最低位，最左边的一位为最高位;\n+ **字是计算机进行数据处理和运算的单位**，即cpu一次处理二进制代码的位数，字的位数叫做字长，字长的大小与计算架构有关，通常说的32位机就是一个字有4个字节，32个位。\n\n`x & 0xFF`, 得到 x 最低有效位，`y & ~0xFF` 得到 y 最低有效位之外的位，两者进行或运算，得到组合结果\n```c\ntypedef unsigned char *byte_pointer;\n...\nsize_t x = 0x89ABCDEF;\nsize_t y = 0x76543210;\nsize_t mask = 0xff;\nsize_t res = ((x & mask) | (y & ~mask));\nbyte_pointer start = (byte_pointer)& res;\nfor(int i = 0; i < sizeof(size_t); i ++) {\n    printf(\"%.2x\", start[i]);\n}\n/*\n输出: ef32547600000000 (小端法机器)\n*/\n```\n\n### 2.60\n> 假设我们将一个 $w$ 位的字中的字节从 0(最低位)到 $\\frac{w}{8} - 1$(最高位)编号。写出下面C函数代码，它会返回一个无符号值，其中参数 $x$ 的字节 $i$ 被替换成字节 $b$ :\n`unsigned replace_byte (unsigned x, inti, unsigned char b);`\n以下示例说明其如何工作:\n`replace_byte(Ox12345678, 2, OxAB) --> Ox12AB5678`\n`replace_byte(Ox12345678, 0, OxAB) --> Ox123456AB`\n\n\n按要求模拟就好了\n```c\n#include <stdio.h>\n\ntypedef unsigned char *byte_pointer;\n\n/*\n* @brief 参数 x 的字节 i 被替换成字节 b\n*/\nunsigned replace_byte (unsigned x, int i, unsigned char b) {\n    byte_pointer start = (byte_pointer)& x;\n    start[i] = b;\n    return *(unsigned*)start;\n}\n\nvoid show_byte(byte_pointer start, size_t sz) {\n    for(int i = 0; i < sz; i ++) {\n        printf(\"%.2x\", start[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    unsigned res1 = replace_byte(0x12345678, 2, 0xAB);\n    unsigned res2 = replace_byte(0x12345678, 0, 0xAB);\n    show_byte((byte_pointer)&res1, sizeof(unsigned));\n    show_byte((byte_pointer)&res2, sizeof(unsigned));\n    return 0;\n}\n/*\noutput:\n7856ab12\nab563412\n*/\n```\n这里提一下最后为什么返回 `*(unsigned*)start` ，这里先要将 `unsigned char *` 类型的 `start` 转变为 `unsigned*` ，即先转换指针类型，再去指针指向地址的值，而如果使用 `(unsigned)(*start)` 的话，`*start` 由于是 `unsigned char` 类型的指针，所以只会取出第一个地址的值，而不是所有的内存单元。\n\n\n在接下来的作业中，我们特意限制了你能使用的编程结构，来帮你更好地理解 C 语言的位级、逻辑\n和算术运算。在回答这些问题时，你的代码必须遵守以下规则:\n+ 假设:\n    + 整数用补码形式表示;\n    + 有符号数的右移是算术右移;\n    + 数据类型 `int` 是 $w$ 位长的。对于某些题目，会给定 $w$ 的值，但是在其他情况下，只要 $2$ 是 8 的整数倍，你的代码就应该能工作。你可以用表达式 `sizeof(int)<<3` 来计算 $w$。\n+ 禁止使用\n    + 条件语句、循环、分支语句、函数调用和宏调用;\n    + 除法、模运算和乘法;\n    + 相对比较运算($>$ 、$<$ 、$\\le$ 和 $\\ge$)。\n+ 允许的运算\n    + 所有的位级和逻辑运算;\n    + 左移和右移，但是位移量只能在 $0$ 到 $w-1$ 之间;\n    + 加法和减法;\n    + 相等(==)和不等(!=)测试。(有些题目里也不允许这些运算);\n    + 整型常数 `INT_MAX` 和 `INT_MIN`;\n    + 对 `int` 和 `unsigned` 进行强制类型转换，无论是显式的还是隐式的。\n\n### 2.61\n> 写一个C表达式，在下列描述的条件下产生1, 而在其他情况下得到 0。假设 $x$ 是 `int` 类型。\nA. $x$ 的任何位都等于 1\nB. $x$ 的任何位都等于 0\nC. $x$ 的最低有效字节中的位都等于1\nD. $x$ 的最高有效字节中的位都等于0\n\n```c\n#include <stdio.h>\n#include <assert.h>\n\ntypedef unsigned char *byte_pointer;\n\nvoid show_byte(int x) {\n    unsigned mask = 1u << 31;\n\tfor(int cnt = 1; mask; mask >>= 1, cnt ++) {\n\t\tprintf(\"%d\", x & mask ? 1: 0);\n        if(cnt % 4 == 0) printf(\" \");\n\t}\n\tprintf(\"\\n\");\n}\n\nint A(int x) {\n    return !~x;\n}\n\nint B(int x) {\n    return !x;\n}\n\nint C(int x) {\n    return !~(x | ~0xFF);\n}\n\nint D(int x) {\n    return !(x >> ((sizeof(int) - 1) << 3));\n}\n\nint main() {\n    int all_bit_one = ~0;\n\tint all_bit_zero = 0;\n\t\n\tassert(A(all_bit_one));\n\tassert(!B(all_bit_one));\n\tassert(C(all_bit_one));\n\tassert(!D(all_bit_one));\n\t\n\tassert(!A(all_bit_zero));\n\tassert(B(all_bit_zero));\n\tassert(!C(all_bit_zero));\n\tassert(D(all_bit_zero));\n\t\n\tassert(!A(0x1234FF));\n\tassert(!B(0x1234FF));\n\tassert(C(0x1234FF));\n\tassert(D(0x1234FF));\n\t\n\tassert(!A(0x1234));\n\tassert(!B(0x1234));\n\tassert(!C(0x1234));\n\tassert(D(0x1234));\n    return 0;\n}\n```\n\n解释:\n1. `~` 是对每一位取反\n2. `!` 是对值取反\n\n而 C 部分，首先是和 `~0xFF` (亦即 `0xFFFFFF00`) 做或运算，前 3 个字节都为 1，最后一个字节为 $x$ 本来的最低字节，要判断是否为全 1 只需要全部取反再判断是否为0即可\n\nD 部分，`(x >> ((sizeof(int) - 1) << 3))` 会得到最高位字节右移后的结果，例如`0011 1011 1001 1010 1100 1010 0000 0000` 会变为 `0000 0000 0000 0000 0000 0000 0011 1011` ，最后判断即可。\n\n### 2. 62\n> 编写一个函数 `int_shifts_are_arithmetic()` 在对 `int` 类型的数使用算术右移的机器上运行时这个函数生成 1, 而其他情况下生成 0 。你的代码应该可以运行在任何字长的机器上。在几种机器上测试你的代码。\n\n```c\nint int_shifts_are_arithmetic() {\n    int x = -1;\n    return !(x ^ (x >> 1));\n}\n```\n\n后面的有时间慢慢做...","tags":["CSAPP"]},{"title":"CSAPP-程序的机器级表示","url":"/2023/11/01/CSAPP-程序的机器级表示/","content":"\n历史上出现过很多知名的指令集架构，比如Alpha， SPARC，PowerPC，MIPS等，而在今天最流行的则是x86(-64)，ARM，RISC-V。这一章以x86-64为重点。\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/isa.png\" width=\"\"></div>\n\n\n> 指令集体系结构或指令集架构(nstruetion Set Arehiteeture, ISA)，定义机器级程序的\n格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA, 包括 x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的。\n\n虽然我们日常使用的编程语言多种多样，但对于计算机来说，其唯一能理解的无非就是二进制，即0和1而已。 CPU的工作流程基本可以看作为控制器从计数器(PC)取出下一条指令并执行，同时更新程序计数器的值。下面是一些基本概念:\n\n+ **Instructure Set Architecture:** 指令集架构 (包括指令规格，寄存器等)，简称ISA，它是软硬件之间的“合同”\n+ **Mircoarchitecture:** 指令集架构的具体实现方式 (比如流水线级数，缓存大小等)，它是可变的\n+ **Machine Code:** 机器码，也就是机器可以直接执行的二进制指令\n+ **Assembly Code:** 汇编码，也就是机器码的文本形式 (主要是给人类阅读)\n\n\n\n## 程序编码\n### C编译过程\nC程序的编译过程: 源代码 `->` 编译 `->` 汇编 `->` 链接 `->` 可执行文件 `->` 装载 `->` 执行\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/05AFB7EEA96F9F7EEC5ADE1BEA97CC09.png\" width=\"\"></div> \n\n更具体的是:\n1. 预处理器(preprocessor) 把诸如 `#include`、`#define`、`#if`、`#else`、`#elif`、`#ifdef`、`#endif` 等预编译指令替换掉\n2. 编译器(compiler)把.c源文件编译成.s的汇编代码文件\n3. 汇编器(assembler)把汇编代码文件转换成相应的二进制目标文件.o，目标文件已经是机器码了，只是没有填入全局变量的地址\n4. 链接器(linker)，把多目标文件和库函数链接在一起，形成可执行文件\n\n在整个编译过程中，编译器会完成大部分工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。\n\n+ 程序计数器(\"PC\")，在 x86-64 中用 `%rip` 表示，给出将要执行的下一条指令在内存中的地址;\n+ 整数寄存器文件包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址或整数数据，有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值;\n+ 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，可以用来实现条件控制代码比如 `if` 和 `while`\n+ 向量寄存器可以存放一个或多个整数或浮点数值。\n\n\n> 以下并不严格按照CSAPP的内容\n\n例如有如下 C 代码 `mstore.c`\n```c\nlong mult2(long, long);\nvoid multstore(long x, long y, long *dest) {\n    long t = mult2(x, y);\n    *dest = t;\n}\n```\n\n在命令行使用 `gcc -Og -S mstore.c` , `-S` 选项会使GCC运行编译器,产生一个汇编文件 `mstore.s` , 但是不做进一步工作\n\n查看该汇编文件，内容如下:\n```c\n\t.file\t\"mstore.c\"\n\t.text\n\t.globl\tmultstore\n\t.type\tmultstore, @function\nmultstore:\n.LFB0:\n\t.cfi_startproc\n\tendbr64\n\tpushq\t%rbx\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 3, -16\n\tmovq\t%rdx, %rbx\n\tcall\tmult2@PLT\n\tmovq\t%rax, (%rbx)\n\tpopq\t%rbx\n\t.cfi_def_cfa_offset 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmultstore, .-multstore\n\t.ident\t\"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\t.section\t.note.gnu.property,\"a\"\n\t.align 8\n\t.long\t1f - 0f\n\t.long\t4f - 1f\n\t.long\t5\n0:\n\t.string\t\"GNU\"\n1:\n\t.align 8\n\t.long\t0xc0000002\n\t.long\t3f - 2f\n2:\n\t.long\t0x3\n3:\n\t.align 8\n4:\n```\n\n我们其实只需要关注其中的\n```c\nmultstore:\n.LFB0:\n\t.cfi_startproc\n\tendbr64\n\tpushq\t%rbx\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 3, -16\n\tmovq\t%rdx, %rbx\n\tcall\tmult2@PLT\n\tmovq\t%rax, (%rbx)\n\tpopq\t%rbx\n\t.cfi_def_cfa_offset 8\n\tret\n\t.cfi_endproc\n```\n\n### 寄存器文件(x86-64)\n16个64位的寄存器，构成了寄存器文件。\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/5948E8CF263182DEE3C28521452B4405.png\" width=\"\"></div> \n\n16个寄存器文件，但是有64个命名，这是因为字节数量的不同。比如 `%rax` ，存储 `char` 类型的变量时只会用到低八位，即 `al` ，存储 `short` 类型的变量则需要用到低16位，即 `%ax` ，而 `int` 类型的变量需要用到32位，即 `%eax` 。\n\n### 栈\n在 x86-64 中存在着栈空间，它存储着临时变量，担任过程调用的中转站，即保留返回地址、参数等。栈遵循先进后出原则(LIFO)。栈空间有一个栈顶指针，也就是十六个寄存器里的 `%rsp` ，在 x86-64 中，程序栈存放在内存中某个区域，栈向下增长，这样可以使得栈顶元素的地址是所有栈中元素地址最低的。栈指针 `%rsp` 保存着栈顶元素的地址，如下图\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/4F2CBA99F7FB1F479FC93BC217889736.png\" width=\"\"></div> \n\n栈有两个操作:\n+ 压入栈(push): 将栈顶指针往下移动若干个字节，使得栈的容量增大，再把新的数据填入栈顶;\n+ 弹出栈(pop): 将栈顶指针上移若干字节，随着栈顶指针的上移，原来的栈顶已经被排除在栈的范围之外。\n\n### PC寄存器\nPC(Program counter)寄存器，也就是前面说的程序计数器，用 `%rip` 表示，它并不是通用寄存器的一员，它存储着下一条要执行的指令的地址。此外，PC寄存器并不会显式地出现在汇编代码中，其值的变化都是暗地里进行的。\n\n## 汇编语言(AT&T)\n### 指令\n汇编代码是由多条指令组成的序列，指令序列存在内存里，PC指向下一条指令的地址，一个指令可以完成一个CPU操作。一条指令由**操作码**和 $0\\sim 2$ 个**操作数**组成，操作码指定了当前指令要执行的操作，例如两数相加，操作数则是操作码的作用对象。由此可见，指令的长度并不固定。\n\n### 操作数\n操作数可以是**立即数、寄存器、内存地址**，以下是三种操作数的表示方法\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/9812E8E00347A8E30C20E1A2635EC8D1.png\" width=\"\"></div> \n\n举例子对上图进行说明:\n1. `$5` 是立即数，它的值为 5;\n2. `%rax` 是寄存器，它的值是寄存器 `%rax` 中的值;\n3. `0x07` 是内存地址，它的值是内存中地址为 `0x07` 的某种类型的值;\n4. `(%rax)` 是内存地址，该地址保留在寄存器 `%rax` 中;\n5. `0xf7(%rax, %rbp, 4)` 是内存地址，所有的内存寻址方式都可以写成这种类型。\n\n最后一种表示一个基址寻址，寻址方式是: `displacement(base register, index register, scale factor)` ，在上面个例子中:\n+ displacement(偏移)是 `0xf7`，即十六进制的偏移值F7\n+ base register(基址寄存器)是 `%rax`\n+ index register(索引寄存器)是 `%rbp`\n+ scale factor(倍数因子)是 4\n\n也就是说，该表达式表示的内存地址是: `0xf7 + (%rax) + 4 * (%rbp)`\n\n### 操作码\n操作码分为**算数逻辑类、数据传输类、控制类**等。\n\n1. 算术和逻辑指令操作码\n```c\naddq $3, %rdi\n```\n`add` 表示相加，第一个操作数是源操作数，第二个操作数是目标操作数，表示将立即数 3 加到寄存器 `%rdi` 中。而 `add` 的后缀表示操作数的大小，分别为:\n+ `b` —— 字节(byte, 8bit);\n+ `w` —— 字(word, 16bit);\n+ `l` —— 双字(doubleword, 32bit);\n+ `q` —— 四字(quadword, 64bit)\n\n算数和逻辑类指令操作码被分为四组: **加载有效地址、一元操作、二元操作和移位**，二元操作有两个操作数，而一元操作有一个操作数。如下图所示\n\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/E1D9A89ED6FD8CBE5E3D5B4CD9FFCAF7.png\" width=\"\"></div> \n\n2. 数据传输指令操作码\n```c\nmovb %bl, %al\n```\n将 `%bl` 寄存器中的值赋给`%al` 寄存器。\n\n```c\npushq %rbp\n```\n表示将 `%rbp` 的值压入栈中，即先使栈顶指针寄存器`%rsp`的值减少8个字节，再将`%rbp`的值赋值给`%rsp`所指的内存单元。\n\n```c\npopq %rsi\n```\n将栈顶的8个字节的值弹出，并赋给 `%rsi`\n\n除此之外，还有诸如控制类、比较和测试类操作码。\n\n### 条件码\n除了整数寄存器，CPU还维护了一组单个位的条件码(condition code)寄存器，它们\n描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用\n的条件码有:\n+ `CF` : 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出;\n+ `ZF` : 零标志。最近的操作得出的结果为 0;\n+ `SF` : 符号标志。最近的操作得到的结果为负数;\n+ `OF` : 溢出标志。最近的操作导致一个补码溢出正溢出或负溢出。\n\n比如说，当使用一条 `add` 指令来完成等价于 C 表达式 `t = a + b` 的功能后，这里的变量都是整型的。然后由下面的 C 表达式来设置条件码\n+ CF —— (unsigned) t < (unsigned) a —— 无符号溢出\n+ ZF —— (t == 0) —— 零\n+ SF —— (t < 0) —— 负数\n+ OF —— (a < 0 == b < 0) && (t < 0 != a < 0) —— 有符号溢出\n\n### 实例\n准备一个 `test.c` 文件，写入如下代码\n```c\nvoid foo(){\n    return;\n}\n```\n\n使用 `gcc -Og -S test.c` 命令可以得到 *.s 的汇编语言文件，加入 `-Og` 的目的是使得到的汇编代码与源代码尽可能的对应。更好的办法是:\n\n首先编译源代码得到目标文件test.o\n```c\ngcc -c -Og test.c\n```\n\n然后用反汇编命令\n```c\nobjdump -d test.o\n```\n\n得到如下:\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/521877CBD05A3E6B85EAAA99A1A59C92.png\" width=\"\"></div> \n\n首先 `0000000000000000 <main>` ，前面的 16 个 0 是十六进制下的 0，也就是二进制下的 64 个 0, 表示该函数所在的虚拟地址，而 `<main>` 则是函数名。接下来是函数体，0、4、8、f...是各指令的地址，也是十六进制，因为第一条指令有4个字节(f3、0f、1e、fa)所以第二条指令的地址和第一条指令地址相差 4。\n\n","tags":["CSAPP"]},{"title":"CSAPP-信息的表示和处理","url":"/2023/10/26/CSAPP-信息的表示和处理/","content":"\n> 人总是对记忆有一种放不下的假清高，渴望在过去里找一点存在感，却因此而陷入更深的纠结。这并不能减少人的迷茫彷徨，反而会加剧内心的动荡。\n> 理解和接受过去的自己，这很重要。同时也要带着乐观派、理想主义和克制活着。\n> —— 2023.10.31记。\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/Fq8hp.png\" width=\"\"></div>\n\n## 信息存储\n大多数计算机使用 8 位的块，或者字节作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存(virtual memory)**。内存的每个字节都由一个唯一的数字来标识，称为它的**地址(address)**，所有可能地址的集合就称为**虚拟地址空间(virtual address space)**。\n\n+ 无符号编码基于传统的二进制表示法，表示大于或者等于零的数字;\n+ **补码(two’s-complement)** 编码是表示有符号整数的最常见的方式;\n+ **移码(增码)** 是符号位取反的补码，一般用指数的移码减去1来做浮点数的阶码，引入的目的是为了保证浮点数的机器零为全0;\n+ **原码(true form)** 是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位(即最高位为符号位):正数该位为0，负数该位为1(0有两种表示:+0和-0)，其余位表示数值的大小;\n+ **浮点数(floating-point)** 编码是表示实数的科学计数法的以2为基数的版本。\n\n### 十六进制(hex)\n使用 $0\\sim 9$ 和 $A\\sim F$ 来表示 `0000` 到 `1111` ，在 C 语言中，以 `0x` 或 `0X` 开头的数字常量通常被认为是十六进制的值，字符 $A\\sim F$ 可以是大写也可以是小写，也可以大小写混合。将一个二进制的数转换为十六进制需要将该数划分为每4个为一组，如果不是4的倍数则在最左边补0 \n\n而十进制转换为十六进制的话，可以使用辗转相除法，即不断除以16得到余数，再从下往上取。例如\n$$\n\\begin{align*}\n314156 &= 19634 \\times 16 + 12 \\tag{C}\\\\\n19634 &= 1227\\times 16+2 \\tag{2}\\\\\n1227 &= 76\\times 16+11 \\tag{B}\\\\\n76 &= 4\\times 16 + 12 \\tag{C}\\\\\n4 &= 0\\times 16 + 4 \\tag{4}\n\\end{align*}\n$$\n\n所以 314156 的十六进制表示就是 0x4CB2C 。反过来，将16进制转换为10进制只需要不断乘上16的幂次相加即可，例如 $314156 = 4\\times 16^4 + 12\\times 16^3 + 11\\times 16^2 + 2\\times 16^1 + 12$ .\n\n### 字数据大小\n每台计算机都有一个**字长(word size)**，指明指针数据的**标称大小(nominal size)**，字长决定了虚拟地址空间的最大大小: 对于一台字长为 $\\omega$ 位的机器，虚拟地址的范围为 $0\\sim 2^{\\omega}-1$\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/FgDwe.png\" width=\"\"></div>\n\n### 寻址和字节顺序\n基本上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。\n\n排列表示一个对象的字节有两个通用的规则:\n+ **小端法(little ending)**: 最低有效字节在前面的方式(低位放在低地址)\n+ **大端法(big ending)**: 最高有效字节在前面(高位放在低地址)\n\n> CSAPP里关于大小端之争记录的一个有趣故事: \" ‘……我下面要告诉你的是， Lilliput 和 Blefuscu 这两大强国在过去 36 个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由 Ble­fuscu 的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有 11000 人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。’(此段译文摘自网上蒋剑锋译的 《 格利佛游记 》 第一卷第 4 章。)\n在他那个时代，Swift 是在讽刺英国(Lilliput)和法国(Blefuscu)之间持续的冲突。Danny Cohen, 一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序, 后来这个术语被广泛接纳了 。“\n\n### 字符串\nC语言中字符串被编码为一个以 `null` 字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。\n\n### 布尔代数\n位向量是固定长度为 $\\omega$ 由 0 和 1 组成的串，位向量的运算可以定义成参数的每个对应元素之间的运算。\n\n位向量一个很有用的应用就是表示有限集合: 我们可以用位向量 $[a_{\\omega-1}, a_{\\omega-2}, \\cdots, a_0]$ 编码任何子集 $A\\in 0, 1, \\cdots, \\omega-1$ ，其中 $a_i=1$ 当且仅当 $i\\in A$ 。\n\n+ 对于任意整数 $\\omega>0$ ，长度为 $\\omega$ 的位向量上的布尔运算 `|`、`&`、`~` 形成了一个布尔代数。\n+ 对于任意整数 $\\omega>0$ ，长度为 $\\omega$ 的位向量上的布尔运算 `^`、`&`、`~` 形成了一个布尔环。\n\n## 整数表示\n### 无符号数的编码\n假设有一个整数数据类型有 $w$ 位，定义向量 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ 。那么 $B2U_w$(Binary to Unsigned) 为:\n$$\nB2U_w(\\vec{x}) := \\sum_{i=0}^{w-1}x_i2^i\n$$\n表示的最大整数值为 $\\sum_{i=0}^{w-1}2^i=2^w-1$ 。无符号数和二进制编码一一对应，函数 $B2U_w$ 是一个双射。\n\n### 补码编码(two's-complement)\n补码是表示有符号数最常见的方式: 将字的最高有效位解释为负权，用函数 $B2T_w$(Binary to Two's-complement) 来表示。定义向量 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ 。那么 $B2T_w$ 为:\n$$\nB2T_w(\\vec{x}):=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\n$$\n\n补码能表示的范围为: $[-2^{w-1}, 2^{w-1}-1]$ ，补码同样构成一一对应，函数 $B2T_w$ 也是一个双射。\n\n### 反码(Ones'Complement)和原码(Sign-Magnitude)\n除了补码之外，还有反码和原码可以用来表示有符号数。\n\n+ 反码: 除了最高有效位的权是 $-(2^{w-1}-1)$ 而不是 $-2^{w-1}$，它和补码是一样的\n$$\nB2O_w(\\vec{x}) := -x_{w-1}(2^{w-1}-1)+\\sum_{i=0}^{w-2}x_i2^i\n$$\n+ 原码: 最高有效位是符号位，用来确定剩下的位应该取负权还是正权\n$$\nB2S_w(\\vec{x}) := (-1)^{x_{w-1}}\\times \\sum_{i=0}^{w-2}x_i2^i\n$$\n> 反码和原码对于 0 都有两种表示方式，对于 +0 两者都表示为 $[00\\cdots 0]$ ，而 -0 在原码中表示为 $[10\\cdots 0]$ 在反码中表示为 $[11\\cdots 1]$\n\n### 有符号数和无符号数之间的转换\n考虑下面这段代码\n```c\nshort int v = -12345;\nunsigned short uv = (unsigned short) v;\nprintf(\"v = %d, uv = %u\\n\", v, uv);\n```\n输出: `v = -12345, uv = 53191` ，其含义是强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。\n\n> C语言中执行一个运算时，它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数来执行运算。例如 `-1 < 0u` 会返回 false，因为左边的操作数将被隐式地转换为无符号数: $-1\\to -1+2^{w}$\n\n### 扩展一个数的位表示\n即从一个较小的数据类型转换到一个较大的类型同时又保持数值不变。\n\n+ 要将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头加0，这种运算被称为**零扩展(zero extension)**;\n+ 要将一个补码转换为更大的数据类型，可以执行一个**符号扩展(sign extension)**，在表示中添加最高有效位的值: \n    + 将原始位 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ 扩展为 $\\vec{x}'=[x_{w-1},x_{w-1},\\cdots, x_{w-1}, x_{w-2}, \\cdots, x_0]$\n\n即 $B2T_{w}(\\vec{x}) = B2T_{w'}(\\vec{x}')$ 。要证明这个，其实只需证明扩展1位时成立即可，即要证明 \n$$\nB2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\\cdots,x_0])=B2T_{w}([x_{w-1},x_{w-2},\\cdots,x_0])\n$$\n由于\n$$\n\\begin{align*}\nB2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\\cdots,x_0])&=-x_{w-1}2^w+\\sum_{i=0}^{w-1}x_i2^i\\\\\n&=-x_{w-1}2^w+x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\\\\\n&=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\\\\\n&=B2T_{w}([x_{w-1},x_{w-2},\\cdots,x_0])\n\\end{align*}\n$$\n这就证得了上结论。\n\n观察下面的代码:\n```c\nshort sx = -12345;\nunsigned uy = sx;\nprintf(\"uy = %u\\n\", uy);\n```\n在一台大端法机器中输出 `uy = 4294954951` ，这表明当把 short 转换成 unsigned 时会先改变大小，再完成从有符号到无符号的转换，也就是说 `(unsigned) sx` 等价于 `(unsigned) (int) sx`\n\n### 截断数字\n即不用额外的位来扩展一个数值，而是减少表示一个数字的位数。截断一个数字可能会改变它的值，溢出的一种形式。\n+ 截断无符号数: 令 $\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_0]$ ，而 $\\vec{x}' = [x_{k-1},x_{k-2},\\cdots,x_0]$ 为将 $\\vec{x}$ 截断为 $k$ 位的结果，令 $x=B2U_w(\\vec{x})$ ，$x'=B2U_k(\\vec{x}')$ ，则 $x' = x\\bmod{2^k}$ 。(直接带入即可证明)\n+ 截断补码数值: 令 $x=B2U_w(\\vec{x})$，$x'=B2T_k(\\vec{x}')$ ，则 $x'=U2T_k(x\\bmod{2^k})$\n\n## 整数运算\n### 无符号加法\n考虑两个非负整数 $x$ 和 $y$ 满足 $0\\le x, y< 2^w$ ，表示它们的和可能需要 $w+1$ 位，这样就会造成字节膨胀。\n\n定义运算 $+^u_w$ ，该运算把整数和 $x+y$ 截断为 $w$ 位得到的结果，再把这个结果看作一个无符号数，即取 $(x+y)\\bmod{2^w}$ 。\n\n检测无符号数加法中的溢出: 对在范围 $0\\le x$ ，$y\\le UMax_w$ 中的 $x$ 和 $y$ ，令 $s = x +_{w}^{u} y$ , 则对计算 $s$ ，当且仅当 $s<x$ 或者等价地 $s<y$ 时发生了溢出。\n\n$Proof.$ 首先需要注意到 $x+y\\ge s$ ，如果 $s$ 没有发生溢出，则 $s\\ge x$ 。另一方面，如果 $s$ 发生了溢出，则有 $s = x+y-2^w=x+(y-2^w)< x$\n\n### 补码加法\n对整数 $x$ 和 $y$ 满足 $-2^{w-1}\\le x, y\\le w^{w-1}-1$ ，定义 $x+_w^t y$ 为整数和 $x+y$ 被截断为 $w$ 位的结果，并将这个结果看作补码数。有:\n$$\nx+_w^t y = \\begin{cases}\nx+y-2^w, &2^{w-1}\\le x+y\\\\\nx+y, &-2^{w-1}\\le x+y< 2^{w-1}\\\\\nx+y+2^w, &x+y<-2^{w-1}\n\\end{cases}\n$$\n\n检测补码加法溢出: 对在范围 $TMin_w\\le x$ ，$y\\le TMax_w$ 中的 $x$ 和 $y$ ，令 $s = x +_{w}^{t} y$ , 则对计算 $s$ :\n+ 当且仅当 $x>0$ ，$y>0$ 但 $s\\le 0$ 时发生了正溢出;\n+ 当且仅当 $x<0$ ，$y<0$ 但 $s\\ge 0$ 时发生了负溢出.\n\n### 补码的非\n对满足 $TMin_w\\le x\\le TMax_w$ 中的 $x$ ，其补码的非 $-^t_w x$ 由下式给出\n$$\n-^t_w x = \\begin{cases}\nTMin_w , &x=TMin_w\\\\\n-x, &x> TMin_w\n\\end{cases}\n$$\n\n也就是说，对 $w$ 位的补码加法来说，$TMin_w$ 是自己的加法的逆，而其他任何数值的 $x$ 都有 $-x$ 作为其加法的逆。\n\n**求补码非的简便方法**:\n\n1. 对每一位求补(取反)，再对结果+1，也就是 `-x` 和 `~x+1` 等价。\n2. 假设 $k$ 是最右边 1 的位置，即将 $x$ 的位级表示为: $[x_{w-1},\\cdots, x_{k+1},1,0,\\cdots, 0]$ ，然后对 $k$ 左边的所有位取反(01110 $\\to$ 10010)\n\n### 补码乘法\n对整数 $x$ 和 $y$ 满足 $-2^{w-1}\\le x, y\\le w^{w-1}-1$ ，定义 $x*^t_w y$ 为整数和 $x*y$ 被截断为 $w$ 位的结果，并将这个结果看作补码数。将一个补码数截断为 $w$ 位相当于先计算该值模上 $2^w$ 再将无符号数转换为补码，即\n$$\nx*^t_w y = U2T_w((x\\times y)\\bmod{2^w})\n$$\n\n> 无符号和补码乘法的位级等价。\n\n### 乘以常数\n对于大多数机器来说整数乘法指令都相当慢，而加法、减法、位级运算和移位等运算很快，因此编译器使用了用移位和加法运算的组合来对乘法指令进行优化。\n\n首先考虑乘以 2 的幂次，$x\\times 2^k$ 只需要将 $x$ 的位级表示左边加 $k$ 个 0 即可。如果是固定字长，则其高 $k$ 位被舍弃，可以发现左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法。而乘一个常数 $C$ 只需要将 $C$ 改写为 2 的幂次的和或者差，例如执行 $x*14$ 编译器会将乘法重写为 $(x<<3)+(x<<2)+(x<<1)$ 或者更优地改为 $(x<<4)-(x<<1)$\n\n### 除以2的幂\n整数除法总是舍入到 0，即对于 $x\\ge 0, y>0$ ，结果是 $\\lfloor\\frac{x}{y}\\rfloor$ ，而对于 $x\\le 0, y>0$ ，结果是 $\\lceil \\frac{x}{y}\\rceil$ 。无符号数的右移一定是逻辑右移。\n\n**除以 2 的幂的无符号除法原理**: C 变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$ ，且 $0\\le k<w$ ，则 C 表达式 `x >> k` 产生数值 $\\lfloor \\frac{x}{2^k}\\rfloor$\n\n**除以 2 的幂的补码除法向下舍入原理**: C 变量 $x$ 和 $k$ 有补码值 $x$ 和无符号数值 $k$ ，且 $0\\le k<w$ ，则 C 表达式 `x >> k` 产生数值 $\\lfloor \\frac{x}{2^k}\\rfloor$\n\n## 浮点数\n### 二进制小数\n考虑一个形如 $b_mb_{m-1}\\cdots b_1b_0b_{-1}b_{-2}\\cdots b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值为 0 或 1 ，这种表示方法定义如下:\n$$\nb = \\sum_{i=-n}^{m} 2^i\\times b_i\n$$\n\n二进制小数点向左移动一位相当于这个数除以 2 ，向右移动一位相当于这个数被乘以 2。但是定点表示法不能很有效地表示非常大的数字。\n\n1. 将二进制小数转换为十进制小数: $110.101_2 = 2^2 + 2^1 + 2^{-1} + 2^{-3} = 6.625$\n2. 将十进制小数转换为二进制小数: 整数部分：除 2 取余数，直到商为 0 ，小数部分：乘 2 取整数，直到小数部分为 0 。比如表示 0.1 :\n$$\n\\begin{align*}\n0.1 \\times 2 = 0.2 \\tag0\\\\\n0.2\\times 2 = 0.4 \\tag0\\\\\n0.4\\times 2 = 0.8 \\tag0\\\\\n0.8\\times 2 = 1.6 \\tag1\\\\\n0.6\\times 2 = 1.2 \\tag1\\\\\n0.2\\times 2 = 0.4 \\tag0\\\\\n\\cdots\n\\end{align*}\n$$\n\n如此就可以将 0.1 表示为 $0.000110...$ ，如此循环，所以需要四舍五入存储到计算机当中，这就造成了误差。除此之外还比如 $0.875=0.111_2$ 。\n\n### IEEE浮点表示\nIEEE浮点标准用 $V = (-1)^s\\times M\\times 2^E$ 的形式来表示一个数:\n+ 符号(sign) $s$ : 决定 $V$ 是整数( $s=0$ ) 还是负数( $s=1$ ) ，而对于数值 0 的符号位解释作为特殊情况处理;\n+ 尾数(significand) $M$ : $M$ 是一个二进制小数，范围是 $1\\sim 2-\\varepsilon$ 或者 $0\\sim 1-\\varepsilon$ ;\n+ 阶码(exponent) $E$ : 作用是对浮点数加权，这个权重是 2 的 $E$ 次幂(可能是负数)。将浮点数的位表示划分为 三 个字段，分别对这些值进行编码:\n    + 一个单独的符号位 $s$ 直接编码符号 $s$ ;\n    + $\\rm{exp}$: 阶码位，以移码形式存储，位数决定数据的范围，用 $\\rm{e}$ 表示，其阶码值为 $\\rm{E}$ 。$\\rm{k}$ 位的阶码字段 $\\rm exp =$ $e_{k-1}\\cdots e_{1}e_0$ 编码阶码值 $\\rm E$ ;\n    + $\\rm frac$ : 尾数位，以原码形式存储，小数部分，其尾数决定小数的精度。$n$ 位小数字段 $\\rm frac= $ $f_{n-1}\\cdots f_1f_0$ 编码尾数 $M$ ，但是编码出来的值也依赖于阶码字段的值是否等于0。\n\n在单精度浮点格式(C语言中的 `float` ) 中，$\\rm s$、$\\rm exp$ 和 $\\rm frac$ 的字段分别为 1 位，$k=8$ 位和 $n = 23$ 位，得到一个 32 位的表示。\n在双精度浮点格式(C语言中的 `double` ) 中，$\\rm s$、$\\rm exp$ 和 $\\rm frac$ 的字段分别为 1 位，$k=11$ 位和 $n = 52$ 位，得到一个 64 位的表示。\n\n以一个 32 位的 `float` 为例，由符号位、指数位和小数位组成，如图所示\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/ALnuv.png\" width=\"\"></div>\n\n\n+ 符号位: 1 位，0 表示正数，1 表示负数;\n+ 指数位: 8/11(float/double) 位表示指数，可以表示 256/2048 种状态;\n> 因为指数可正可负，在 IEEE 标准里并没有选择用补码来表示负数，而是选择了直接向左平移(又叫**阶码**)，8 位的范围是 $[0, 255]$ ，我们将它向左平移一半(取127)，范围就变成了 $[-127, 128]$ ，也就是说指数位减去127才是真实的指数，比如 12(00001100) 代表 12-127 = -115 。这里减去的数叫**偏移量(biase)**，对单精度来说是127，对双精度来说是1023。\n+ 小数位: 23/52位，表示底数。显然底数的长度决定了类型的精度，决定了到底能存几位有效数字，而指数位只是表示小数点的位置;\n\n**Q.** 将 $78.625$ 转化为单浮点数形式。\n\n**A.** 首先将 $78.625$ 转化为二进制表示，为 $1001110.101$ ，即 $1.001110101\\times 2^6$ 。\n考虑指数位为 $6+127=133=10000101_2$ ，并将底数的小数点后面添加0补到23位，得到结果为:\n$$\n\\color{red}{0}\\color{green}{10000101}\\color{blue}{00111010100000000000000}\n$$\n\nIEEE-754浮点转换器: https://www.h-schmidt.net/FloatConverter/IEEE754.html\n\n> 注意到，由于第一位总是1，所以就不需要显式地表示它，这就获得了一个额外的精度位。\n\n### 非规约数 & 正零和负零\n考虑到指数范围为 $[-127, 128]$ ，也就是说能表示最大精度(`0x00000000`)为 $\\pm2^{-127}$ 。\n\n为了表示更小的数，在指数位全为0时，丢弃掉最高位为1的束缚，将最高位规定为0,将\"全0指数位\"规定为-126而不是本来的-127，用于表示绝对值小于 $2^{-126}$ 的数，这样的数就可以叫做**非规约数(denormal number)**\n\n比如 $\\color{red}{0}\\color{green}{00000000}\\color{blue}{00111010100000000000000}$ 表示的数为 $0.001110101\\times 2^{-126}=1.110101\\times 2^{-129}$ ，这样就可以表示 $\\pm 2^{-126-23} = \\pm2^{-149}$ 。\n\n而对于 0 的表示，因为符号位可以取1和0,即对应于负零和整零，在高级应用层面对于正零和负零的判定各不相同，C++中负零和整零相等，并且布尔值都对应于 `false` ，在运算过程一个理论答案为零的结果既可能被计算为正零，也可能被计算为负零。\n\n### 逐渐溢出\n规格数的最小值为 $0(00000001)0\\cdots 0_2 = 2^{-126}$ \n非规格数的最大值为 $0(00000000)1\\cdots 1_2 = (1-2^{-23})2^{-126}$ ，基本可以看做 $2^{-126}$ 的开区间，从非规格数过渡到规格数时，相当于指数 $-126$ 不变，底数进位到隐藏的高位。从而实现了平稳的值域过渡，刚好覆盖了实数轴，这种特性叫做**逐渐溢出(gradual overflow)**\n\n而这也是前面非规约数使阶码值为 $1-\\rm Bias$ 而不是 $-\\rm Bias$ 的原因。\n\n当二进制码从 `0x00000000` 不断递增时，它表示的浮点数值也是逐渐递增的。这对于非规约数到规约数来说表现为\"逐渐溢出\"，而对于规约数来说，小数部分不全为1的时候显然; 而当小数部分全为1的时候，再下一个数是小数位清零，指数位加1。\n例如 $0(0..01)11..11$ 对应浮点数的下一个是 $0(0..10)00..00$ ，而 $0(0..01)11..11$ 对应整数的下一个也是 $0(0..10)00..00$ 。根据这个特性，可以像整数一样对浮点数进行基数排序。\n\n### 无穷(inf)\n用指数位全为1的状态表示无穷，根据符号位的不同有正无穷和负无穷之分。无穷支持一些数学意义上的运算:\n+ 同号无穷被认为相等，正无穷 > 所有规约数 > 负无穷\n+ 无穷与规约数进行四则运算仍是无穷\n\nC++ 中可以使用 `1/0.0` 或者 `1e1000` 等赋值来得到一个无穷，他们都是一样的无穷，本质上是表示\"超过存储范围\"。输出 `inf` 或者 `-inf` 。\n\n### 非数值(NaN)\n非数值与无穷一样使用全为1的指数位表示，为了区分开来，小数位全为0时表示无穷，其他所有情况表示非数值情况。\n\n### 浮点数的范围和精度\n\n<div align=center><img src=\"https://raw.githubusercontent.com/wxLiu925/blog-images/master/AIb4d.png\" width=\"\"></div>\n\n\n对于32位规约数来说，指数位包括 $[-127, 128]$ ，但是由于左右端点表示其他值，所以实际指数位为 $[-126,127]$ 。\n\n**范围:** 考虑正数，前面计算过最小的规约数为 $2^{-126}$ ，而最大的规约数为 $0(11111110)1...1_2 \\approx 2^{128}$ ，所以极限范围就是 $[2^{-126}, 2^{128})$ ，转换为十进制就大约是 $[1.175\\times 10^{-38}, 3.403\\times 10^{38}]$ 。如果算上非规约数，那下界可以达到 $2^{-149}\\approx 1.401\\times 10^{-45}$ 。\n\n**精度:** 精度即底数有效数字的位数，底数有23位，而换算成十进制下就大约是7位小数，双精度的话就是大约15位。   \n\n### 舍入\n因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算，因此，对于值 $x$，我们使用一种系统的方法，能够找到最接近的匹配值 $x'$，它可以用期望的浮点形式表示出来，这就是舍入运算的任务。\n\nIEEE浮点格式定义了四种不同的舍入方式，默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。\n+ 向偶数舍入: 它将数字向上或者向下舍入，使得结果的最低的有效数字是偶数。\n+ 向零舍入：把正数向下舍入，把负数向上舍入。\n+ 向下舍入：把正数和负数都向下舍入。\n+ 向上舍入：把正数和负数都向上舍入。\n\n","tags":["CSAPP"]},{"title":"机器学习与模式识别:手写数字识别","url":"/2023/10/26/机器学习与模式识别-手写数字识别/","content":"\n## 实验内容\n1. 数据集选择\n2. Bayes判别分类\n3. Fisher 线性判别\n4. SVM的线性与非线性分类\n5. 不同分类器之间的比较\n\n> 原始数据集上传至网盘: https://pan.baidu.com/s/1uqmJg7EGxpKR62j-Qbr1ow?pwd=jjrc\n\n## 实验数据特征提取方法\n手写数字样本。每个数字有 $50$ 张图片，选择其中 $40$ 个作为训练集，$10$ 个作为测试集。\n\n首先将含有全部特征信息的手写数字图像从坐标轴中提取出来，将提取出来的书写数字图像进行二值化处理; 将处理后的每个数字图像提取 $5\\times 5$ 块模板，每个模块中 1 值像素点与总像素点的比值就是这个模块的特征值。将所有特征值放入 $5\\times 5$ 的矩阵。设定阈值 $T = 0.05$，每块内所对应的元素白像素占有率大于 $T$ ，则该块特征取1;否则取0。\n\n选择minst手写数字数据集，因为图片尺寸为 $28\\times 28$ 不为5的倍数，使用中心裁剪法将图像裁剪为25x25的大小再进行分块操作与特征提取。\n\n数据处理(特征提取) `dataset.m` 代码如下:\n```matlab\n% ----------\n%\n% 数据集处理\n%\n% ----------\n\nfunction [train_X, train_Y, test_X, test_Y] = load_datasets(train_pc)\n    % 参数设置\n    T = 0.05;\n    kernelSize = 5;\n    imgSize = 28;\n    sub_counts = floor(imgSize / kernelSize);\n    newImgSize = kernelSize * sub_counts;\n    train_X = [];\n    train_Y = [];\n    test_X = [];\n    test_Y = [];\n    \n    for digit = 0:9\n        digitFolderPath = fullfile('./mnist', num2str(digit));\n        imageFiles = dir(fullfile(digitFolderPath, '*.png'));\n        % 读取当前数字的所有图像数据\n        images = length(imageFiles);\n        for i = 1:images\n            imgPath = fullfile(digitFolderPath, imageFiles(i).name);\n            % 读取图像\n            img = double(imread(imgPath)); \n            % 中心裁剪图像\n            croppedImg = centerCropImage(img, newImgSize);\n            % 提取图像特征\n            features = getFeatures(croppedImg, kernelSize, T);\n            %features = img(:);\n            if i <= images * train_pc\n                % 划分为训练集\n                train_X = [train_X; features'];\n                train_Y = [train_Y; digit];\n            else\n                % 划分为测试集\n                test_X = [test_X; features'];\n                test_Y = [test_Y; digit];\n            end\n        end\n    end\n    \n    end\n    \n    \n    function croppedImg = centerCropImage(img, newImgSize)\n        [rows, cols] = size(img);\n        startRow = floor((rows - newImgSize) / 2) + 1;\n        startCol = floor((cols - newImgSize) / 2) + 1;\n        croppedImg = img(startRow:startRow + newImgSize - 1, startCol:startCol + newImgSize - 1);\n    end\n    \n    function features = getFeatures(img, kernelSize, T)\n        [rows, cols] = size(img);\n        % 计算分块数目\n        numBlocksRow = round(rows / kernelSize);\n        numBlocksCol = round(cols / kernelSize);\n        % 初始化特征向量\n        features = zeros(1, numBlocksRow * numBlocksCol);\n    \n        blockIndex = 1;\n        for i = 1:numBlocksRow\n            for j = 1:numBlocksCol\n                % 计算分块的起始和结束位置\n                startRow = (i - 1) * kernelSize + 1;\n                endRow = i * kernelSize;\n                startCol = (j - 1) * kernelSize + 1;\n                endCol = j * kernelSize;\n                % 计算分块的总像素数\n                totalPixels = kernelSize * kernelSize;\n                % 计算分块内白像素的个数\n                whitePixels = sum(sum(img(startRow:endRow, startCol:endCol) >= 250));\n                \n                % 根据阈值T判断特征取值\n                if whitePixels / totalPixels > T\n                    features(blockIndex) = 1;\n                else\n                    features(blockIndex) = 0;\n                end\n                blockIndex = blockIndex + 1;\n            end\n        end\n        features = features';\n    end\n```\n\n## 朴素Bayes判别分类\n\n### 理论基础\n设 $B_i$ 表示事件: 图片为数字 $i$ ，则由 Bayes 公式有\n$$\n\\begin{align*}\nP(B_i|A) = \\frac{P(A|B_i)P(B_i)}{\\sum_{j=0}^{9} P(A|B_j)P(B_j)} \n\\end{align*}\n$$\n\n其中，$P(B_i)$ 在这里是先验概率，在这里等于 0.1。$P(B_i|A)$ 是后验概率，在这里是对于一张手写数字图片(事件 $A$)上的数字是 $d$ ($0\\sim 9$ 对应事件 $B_0\\sim B_9$)的概率，由于这里是设计基于最小错误率的贝叶斯分类器，故而认为该数字为后验概率最大的数字。\n\n令 $\\mathbf{X}$ 表示图片集合，$\\mathbf{Y}$ 表示标签集合，则训练数据集可以表示为:\n$$\n\\mathbf{T} = \\{(\\bar{x}_1, y_1), (\\bar{x}_2,y_2),\\cdots, (\\bar{x}_n,y_n)\\}\n$$\n其中，$\\bar{x}_1,\\cdots,\\bar{x}_n\\in \\mathbf{X}$ , $y_1,\\cdots,y_n\\in \\mathbf{Y}$ ，对于任意的 $\\bar{x}_i$ 有 $\\bar{x}_i = \\{x_i^1, x_i^2, \\cdots, x_i^m\\}$ 意为第 $i$ 张图片的 $m$ 个特征。\n\n对于训练数据集 $P(X,Y)$ 独立同分布，所以有\n$$\nP(X|Y) = \\frac{P(X,Y)}{P(Y)}\n$$\n又有先验概率 $P(Y = c_k) = 0.1$ , $k=0,1,\\cdots,9$ , 而条件概率\n$$\nP(X=x|Y=c_k) = P(X^1=x^1,X^2=x^2,\\cdots,X^m=x^m|Y=c_k)\n$$\n又因为这里数据的条件概率分布是特征条件独立，所以进一步地可以表示为\n$$\nP(X=x|Y=c_k) = \\prod_{j=1}^m P(X^j=x^j|Y=c_k)\n$$\n\n> 在这里问题里的实际含义是: 对于测试集的任意一张 $28\\times 28$ 大小的手写数字图片，最后得到 25 个特征，每一个特征对应于每一个模块的取值。在朴素贝叶斯的假设条件下，这张图片是 1 的概率就是每一个特征都是 1 的特征的概率的累乘。\n\n进一步得到后验概率的计算公式:\n$$\nP(Y=c_k|X=x) = \\frac{P(Y=c_k)\\prod_j^m P(X^j=x^j|Y=c_k)}{\\sum_kP(Y=c_k)\\prod_j^m P(X^j=x^j|Y=c_k)}\n$$\n\n因为是要取最大值，所以可以去掉公分母，得到朴素贝叶斯分类器的判别式\n$$\ny = f(x) = \\max_{c_k} P(Y=c_k)\\prod_j P(X^j=x^j|Y=c_k)\n$$\n\n对每一个实验样本，选取前 40 个作为训练集，后 10 个作为测试集。\n\n编写代码 `bayesClassifier.m`\n```matlab\n% ----------\n%\n% 贝叶斯判别代码\n%\n% ----------\n\nclc, clear;\n% 重新加载数据\nload('datasets.mat');\n\n% v = mnistData{8}{1, 2};\n% A = reshape(v, 5, 5)';\n% disp(A);\n\n% 从每个类别中选择40个样本作为训练集，10个样本作为测试集\ntrain_samples = cell(10, 40);\ntest_samples = cell(10, 10);\n\nerror_count = 0;\nfor digit = 1:10\n    % 从当前类别中随机选择40个样本作为训练集\n    all_samples = mnistData{digit};\n%     random_indices = randperm(length(all_samples), 40);\n%     % disp(random_indices);\n%     train_samples{digit} = all_samples(random_indices, :);\n    \n    train_samples{digit} = all_samples(1:40, :);\n    % 剩余的10个样本作为测试集\n%     test_indices = setdiff(1:length(all_samples), random_indices);\n%     test_samples{digit} = all_samples(test_indices, :);\n    test_samples{digit} = all_samples(41:50, :);\n    %(test_indices);\nend\n\n% 重新计算先验概率和类条件概率\nnum_classes = 10; % 数字类别数量\nnum_features = 25; % 特征数量\nnum_train = 40; % 训练样本的数量\nnum_test = 10; % 测试样本的数量\n\ntrue_positives = zeros(1, num_classes); % 正类别被正确分类的样本数量\nfalse_positives = zeros(1, num_classes); % 负类别被错误分类成正类别的样本数量\nfalse_negatives = zeros(1, num_classes); % 正类别被错误分类成负类别的样本数量\n\nfor x = 1:10\n    for y = 1:10\n        % 获取第i个测试样本的特征向量\n        test_sample = test_samples{x}{y, 2};\n        \n        prior_prob = zeros(1, num_classes); % 先验概率\n        class_cond_prob = zeros(num_features, num_classes); % 类条件概率\n        pij = []; % i类的样本第j个特征为1的概率\n        for i = 1:num_classes\n            % 计算先验概率\n            prior_prob(i) = 0.1;\n            for j = 1:num_features % 每个数字图片提取出来的特征数\n                sum = 0;\n                for k = 1:num_train % 每个类别下训练样本的个数\n                    i_feature = train_samples{i}{k, 2}; % 获取第k个训练样本的特征向量\n                    sum = sum + i_feature(j);\n                end\n                % disp(sum);\n                pij(i,j) = (sum + 1) / (num_train + 2); % 计算概率估计值即Pj(ωi)，注意拉普拉斯平滑处理\n            end\n        end\n        for i = 1:num_classes\n            multi = 1;\n            for j = 1:num_features % 每个数字图片提取出来的特征数\n                if(test_sample(j) == 1)\n                    multi = multi * pij(i,j);\n                else\n                    multi = multi * (1 - pij(i,j));\n                end\n            end\n            class_cond_prob(i) = multi;\n        end\n        %计算后验概率\n        p_class = []; % 后验概率\n        sum = 0;\n        for i=1:num_classes%数字类别个数\n            sum = sum + prior_prob(i) * class_cond_prob(i);\n        end\n        for i = 1:num_classes % 数字类别个数\n            p_class(i) = prior_prob(i) * class_cond_prob(i) / sum;\n        end\n        [maxval, maxpos] = max(p_class);\n        if maxpos == x\n            true_positives(x) = true_positives(x) + 1;\n        else\n            error_count = error_count + 1;\n            false_positives(maxpos) = false_positives(maxpos) + 1;\n            false_negatives(x) = false_negatives(x) + 1;\n        end\n    end\nend\n\n% 计算准确率（acc）、精确率（precision）、召回率（recall）、F1-score\nprecision = true_positives ./ (true_positives + false_positives);\nrecall = true_positives ./ (true_positives + false_negatives);\nf1_score = 2 * (precision .* recall) ./ (precision + recall);\n\n% 计算错误率和正确率\nerror_rate = error_count / 100;\naccuracy = 1 - error_rate;\n\ndisp(['Accuracy: ', num2str(accuracy)]);\ndisp(['Precision: ', num2str(mean(precision))]); % Changed here\ndisp(['Recall: ', num2str(mean(recall))]); % Changed here\ndisp(['F1 Score: ', num2str(mean(f1_score))]); % Changed here\n```\n\n得到结果:\nAccuracy: 0.66\nPrecision: 0.67991\nRecall: 0.66\nF1 Score: 0.65476\n\n\n## Fisher判别分类\n使用 Fisher 线性判别方法求分类器的步骤:\n1. 计算各类的均值向量: $\\mu_i = \\frac{1}{N_i}\\sum_{x\\in X_i}x$ ;\n2. 计算各类的类内离散矩阵: $S_{wi} = \\sum_{x\\in X_i}(x-\\mu_i)(x-\\mu_i)^T$ ;\n3. 计算类内总离散矩阵: $S_w = S_{w0}+S_{w1}+\\cdots$ ;\n4. 计算总离散矩阵的逆矩阵: $S_w^{-1}$ ;\n5. 求出向量 $w^* = S_w^{-1}(\\mu_1-\\mu_0)$ ;\n6. 判别函数为: $y=(w^*)^Tx$ ;\n7. 求出判别函数的阈值: $w_0 = \\frac{(w^*)^T(\\mu_0+\\mu_1+\\cdots)}{2}$ ;\n8. 比较 $y$ 值与阈值的大小得出分类。\n\n```matlab\n% ----------\n%\n% Fisher分类代码\n%\n% ----------\n\nclc,clear;\nload('datasets.mat');\n% 初始化\n\nnumClasses = 10; % 类别数\nnumImages = 50; % 每个类别的图像数\nnumFeatures = 25; % 特征数\ntrainingSize = 40; % 训练集大小\n\n% 创建训练集和测试集\ntrainingData = zeros(numClasses * trainingSize, numFeatures);\ntrainingLabels = zeros(numClasses * trainingSize, 1);\ntestData = zeros(numClasses * (numImages - trainingSize), numFeatures);\ntestLabels = zeros(numClasses * (numImages - trainingSize), 1);\n\nfor i = 1:numClasses\n    for j = 1:numImages\n        if j <= trainingSize\n            trainingData((i-1)*trainingSize + j, :) = mnistData{i,1}{j,2};\n            trainingLabels((i-1)*trainingSize + j) = i;\n        else\n            testData((i-1)*(numImages - trainingSize) + j - trainingSize, :) = mnistData{i,1}{51-j,2};\n            testLabels((i-1)*(numImages - trainingSize) + j - trainingSize) = i;\n        end\n    end\nend\n\n% 使用Fisher线性判别方法进行训练\nMdlLinear = fitcdiscr(trainingData, trainingLabels, 'DiscrimType', 'pseudoLinear');\n% 对测试集进行预测\n\npredictedLabels = predict(MdlLinear, testData);\n\n% 计算错误率\nerrorRate = sum(predictedLabels ~= testLabels) / length(testLabels);\nfprintf('Error Rate: %.2f%%\\n', errorRate * 100);\n\n% 初始化\nprior = ones(1, numClasses) / numClasses; % 先验概率\n\n% 使用Fisher线性判别方法进行训练\nMdlLinear = fitcdiscr(trainingData, trainingLabels, 'DiscrimType', 'pseudoLinear', 'Prior', prior);\n\n% 对测试集进行预测\npredictedLabels = predict(MdlLinear, testData);\n\n% 计算错误率\nerrorRate = sum(predictedLabels ~= testLabels) / length(testLabels);\nfprintf('Error Rate: %.2f%%\\n', errorRate * 100);\n\n% 计算混淆矩阵\nC = confusionmat(testLabels, predictedLabels);\n\n% 计算准确率（accuracy）\naccuracy = sum(diag(C)) / sum(C(:));\nfprintf('Accuracy: %.2f%%\\n', accuracy * 100);\n\n% 计算精确率（precision）\nprecision = diag(C) ./ sum(C, 2);\nfprintf('Precision: %.2f%%\\n', mean(precision) * 100);\n\n% 计算召回率（recall）\nrecall = diag(C) ./ sum(C, 1)';\nfprintf('Recall: %.2f%%\\n', mean(recall) * 100);\n\n% 计算F1-score\nf1score = 2 * (precision .* recall) ./ (precision + recall);\nfprintf('F1-score: %.2f%%\\n', mean(f1score) * 100);\n```\n\n## 多分类支持向量机\n### 二分类支持向量机介绍\n对于线性不可分情况引入惩罚因子 $C$ ，于是广义最优分类面问题模型如下:\n$$\n\\max_{a} \\sum_{j=1}^N a_j - \\frac{1}{2}\\sum_{i=1}^{N}\\sum_{j=1}^{N} y_iy_ja_ia_jK(x_i,x_j) , s.t.\\sum_{ i=1}^N y_ia_i=0\n$$\n\n其中 $0\\le a_i\\le C$ 。\n\n### 特征选择\n用于训练SVM的特征使用的是图像的完整像素特征，即一张 $28\\times 28$ 的图像，它的特征向量的大小为 $1\\times 784$ 。将该特征进行标准化处理后即可用于训练SVM。\n\n### ECOC编码与多分类SVM\nECOC(Error-Correcting Output Codes)编码是一种纠错输出编码用于将多分类任务高效地转换为多个二分类任务。Mnist数据集有0~9个数字共10分类。对应的ECOC编码如下图:\n\n![FBxr2.png](https://raw.githubusercontent.com/wxLiu925/blog-images/master/FBxr2.png)\n\n代码如下:\n```matlab\n% ----------\n%\n% 支持向量机代码\n%\n% ----------\n\nclc,clear;\n\n[train_X, train_Y, test_X, test_Y] = load_datasets(0.8);\n\n% 核函数选择，可选：'linear','gaussian','rbf','polynomial'\nKernelFunction = 'polynomial';\n% 惩罚参数C确认\nC = 1000;\n\ntemplate = templateSVM(...\n    'KernelFunction', KernelFunction, ...\n    'PolynomialOrder', 3, ...\n    'KernelScale', 'auto', ...\n    'BoxConstraint', C, ...\n    'Standardize', true);\nsvm_model = fitcecoc(...\n    train_X, ...\n    train_Y, ...\n    'Learners', template);\n\n% spy(svm_model.BinaryY(1:40:400,:));\n% title('ECOC编码');\n% yticks(1:10);\n% yticklabels(0:9);\n% xlabel('分类器数目');\n\npredicted_labels = predict(svm_model, test_X);\n\n% 计算混淆矩阵\nC = confusionmat(test_Y, predicted_labels);\n\n% 计算准确率（accuracy）\naccuracy = sum(diag(C)) / sum(C(:));\nfprintf('Accuracy: %.2f%%\\n', accuracy * 100);\n\n% 计算精确率（precision）\nprecision = diag(C) ./ sum(C, 2);\nfprintf('Precision: %.2f%%\\n', mean(precision) * 100);\n\n% 计算召回率（recall）\nrecall = diag(C) ./ sum(C, 1)';\nfprintf('Recall: %.2f%%\\n', mean(recall) * 100);\n\n% 计算F1-score\nf1score = 2 * (precision .* recall) ./ (precision + recall);\nfprintf('F1-score: %.2f%%\\n', mean(f1score) * 100);\n```\n\n下表为使用全部特征进行训练、测试得到的结果。\n\n| 核函数 | 惩罚参数C | 准确率(%) | 精确率(%) | 召回率(%) | F1-score(%) |\n| :----: | :----: | :----: | :----: | :----: | :----: | \n| 线性 | 1 | 86.00 | 86.00 | 87.83 | 85.77 |\n| 线性 | 100 | 82.00 | 82.00 | 84.35 | 81.44 |\n| 线性 | 1000 | 82.00 | 82.00 | 84.35 | 81.44 |\n| 高斯 | 1 | 71.00 | 71.00 | 83.30 | 73.64 |\n| 高斯 | 100 | 72.00 | 72.00 | 82.89 | 73.80 |\n| 高斯 | 1000 | 72.00 | 72.00 | 82.89 | 73.80 |\n| 三次多项式 | 1 | 87.00 | 87.00 | 87.18 | 86.58 |\n| 三次多项式 | 100 | 87.00 | 87.00 | 87.18 | 86.58 |\n| 三次多项式 | 1000 | 87.00 | 87.00 | 87.18 | 86.58 |\n\n由上表得，三次多项式作为核函数效果最佳，且乘法参数C取值对评估结果没有影响。但如果选取原始特征提取方法(图像被分为5x5个块，一共提取了25个特征)，准确率将有所下降，仅能达到 60% 左右。\n\n## 各分类器间的比较\n无论是贝叶斯判别还是Fisher分类，两者改为多分类方法比较容易。SVM是一个性能很好的二分类算法，然而在进行多分类任务时需要多个SVM才能进行，这导致SVM在多分类任务中的准确率下降。本次实验如果全部使用提取特征后的数据来训练模型，Fisher判别表现最好，准确率在74%；其次是贝叶斯判别，准确率在66%. SVM分类效果最差，准确率为61%.\n     \n总的来说，分类算法的选择更多取决于数据集。如果数据集规模较大，且基本线性可分，使用贝叶斯或是Fisher判别效率更高，反之应使用SVM处理更加复杂的非线性分类任务。","tags":["Bayes","Fisher","SVM","matlab"]},{"title":"C++面经Part1","url":"/2023/10/25/C-面经Part1/","content":"### const\n主要有以下作用:\n1. 修饰变量，说明该变量不可改变;\n2. 修饰指针，这里分为**指向常量的指针(指针常量，pointer to const)**和**自身是常量的指针(常量指针，const pointer)**\n```cpp\nint a = 0, b = 10;\nconst int *p1 = &a; // 指针常量，指向的值不可以使用*p修改，*p = 10 错误，可以修改指向的地址\nint *const p2 = &a; // 常量指针，指针指向的地址不可改变，p2 = &b 错误，可以修改该地址的变量值\n```\n3. 修饰引用，指向常量的引用，用于形参类型，既避免了拷贝，又避免了函数对值进行修改\n4. 类内修饰成员函数，说明该成员函数内不能修改成员变量\n\n```cpp\n#include <iostream>\n\nclass A {\nprivate:\n    const int a;\npublic:\n    // 构造函数\n    A() : a(0) { };\n    A(int x) : a(x) { };\n\n    // const可用于对重载函数的区分\n    // 普通成员函数\n    void func() {\n        std::cout << \"这是一个普通函数\" << std::endl;\n    }\n    // 常成员函数，不得修改类中任何数据的值\n    void func() const {\n        std::cout << \"这是一个常函数\" << std::endl;\n    }\n};\n\nint main() {\n    A obj1;\n    const A obj2;\n    obj1.func(); // \"这是一个普通函数\"\n    obj2.func(); // \"这是一个常函数\"\n    return 0;\n}\n```\n需要注意的是，普通对象可以调用普通函数也可以调用常函数，前者优先，如果是常量对象的话，只能调用常函数，如果调用普通函数会导致报错。\n\n进一步地\n```cpp\n// 函数\nvoid function1(const int Var);           // 传递过来的参数在函数内不可变\nvoid function2(const char* Var);         // 参数指针所指内容为常量\nvoid function3(char* const Var);         // 参数指针为常量\nvoid function4(const int& Var);          // 引用参数在函数内为常量\n// 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰\n\n// 函数返回值\nconst int function5();      // 返回一个常数\nconst int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();\nint* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();\n```\n\n### static\n主要有以下作用:\n1. **修饰普通变量:** 修改变量的存储区域和生命周期，使变量存储在静态区域，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。需要注意的是: 在函数内部定义了一个静态变量，生命周期到程序结束，但是这个变量的作用域仅限于声明它的函数内部。\n```cpp\nvoid myFunction() {\n    static int count = 0; // 静态局部变量\n    count++;\n    std::cout << \"Count: \" << count << std::endl;\n}\n\nint main() {\n    myFunction(); // 输出 Count: 1\n    myFunction(); // 输出 Count: 2\n    // 这里无法直接访问 count\n    return 0;\n}\n```\n2. **修饰普通函数:** 表明函数的作用范围，仅在定义该函数的文件内才能使用，它的作用域被限制在声明它的文件中，即它变成了一个“内部链接”的函数，只能在当前文件内部访问。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n```cpp\n// File1.cpp\nstatic void myFunction() {\n    std::cout << \"这是一个静态函数\" << std::endl;\n}\n// File2.cpp\nvoid anotherFunction() {\n    myFunction(); // 错误，无法访问静态函数\n}\n```\n3. **修饰成员变量:** 修饰成员变量时该变量将被所有该类的对象共享，而不是每个对象拥有一份副本，而且不需要生成对象就可以访问该成员。\n```cpp\nclass MyClass {\npublic:\n    static int count; // 静态成员变量\n};\n\nint MyClass::count = 0; // 静态成员变量的初始化\n\nint main() {\n    MyClass obj1;\n    MyClass obj2;\n\n    obj1.count = 5;\n    std::cout << obj2.count << std::endl; // 输出 5\n\n    return 0;\n}\n```\n4. **修饰成员函数:** 修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内只能访问 static 成员。\n\n### this 指针\n`this` 指针是一个特殊的指针，它指向当前对象的地址。在 C++ 中，每个类的非静态成员函数都有一个隐含的 `this` 指针，它指向调用该成员函数的对象。\n\n当一个类对象调用成员函数时，编译程序先将对象的地址赋给了 `this` 指针，然后调用该成员函数，每次成员函数存取数据成员时，都其实是在隐式地使用 `this` 指针。\n\n`this` 指针是一个常量指针，被隐含地声明为: `ClassName *const this` ，这意味着不能给 `this` 指针赋值，而在 `const` 成员函数里被声明为 `const ClassName* const`\n\n最后还需要注意的是，`this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址(不能 `&this`)\n\n### 左值和右值(引用)\n1. 左值(lvalue)\n+ 左值既能够出现在等号左边，也能出现在等号右边\n+ 左值可以被赋值，可以作为赋值语句的目标\n+ 左值是可寻址的变量，有持久性\n+ 具体来说，变量、对象或者通过解引用获得的指针都属于左值\n```cpp\nint x = 5; // x 是左值，因为它代表一个内存位置，可以被赋值\nint* ptr = &x; // &x 是左值，因为它是变量 x 的地址\n```\n\n2. 右值(rvalue)\n+ 右值是不能被赋值的表达式，它们代表的是一个数值或者临时值，通常在赋值语句的右侧\n+ 右值可以是一个常数、一个临时的计算结果或者一个表达式的返回值。\n+ 右值在使用后就失去意义，因此不能被取地址\n```cpp\nint y = 10; // 10 是右值，因为它代表一个数值，不能被赋值\nint z = x + y; // x + y 是右值，因为它代表一个临时计算结果\n```\n\n> C++ Primer:\" 当一个对象被用作右值的时候，用的是对象的值(内容);当对象被用作左值时，用的是对象的身份(在内存中的位置)\"\n\n左值引用(lvalue reference)和右值引用(rvalue reference)是C++中引入的两种不同类型的引用。\n\n3. **左值引用:** 左值引用是最常见的引用类型。它们使用 `&` 符号声明，并且只能绑定到左值(可以取地址的表达式)。\n4. **右值引用:** 右值引用是在C++11中引入的新特性，用 && 符号表示。它们可以绑定到临时值、表达式结果或具有名称的右值。\n```cpp\nint x = 6; // x是左值，6是右值\nint &y = x; // 左值引用，y引用x\n\nint &z1 = x * 6; // 错误，x*6是一个右值\n\nint &&z2 = x * 6; // 正确，右值引用\nint &&z3 = x; // 错误，x是一个左值\n```\n> 可以引用右值的除了右值引用外还有 const 左值引用，例如 `const int &z4 =  x * 6;` 正确，可以将一个const引用绑定到一个右值。例如 `std::vector` 的 `push_back` 函数就使用了 const 左值引用(`void push_back (const value_type& val);`) ，这样能让我们使用 `v.push_back(1)` 这样的代码。\n\n`std::move` 可以实现将左值转换成右值以实现对左值进行右值引用\n```cpp\nint i = 3, j;\nj = std::move(2); // 合法，从一个右值移动数据\nj = std::move(i); // 合法，从一个左值移动数据，i的值之后是不确定的。\n```\n\n### inline 内联函数\n主要有以下特征:\n+ 相当于把内联函数里面的内容写在调用内联函数处;\n+ 相当于不用执行进入函数的步骤，直接执行函数体;\n+ 相当于宏，却比宏多了类型检查，真正具有函数特性;\n+ 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数;\n+ 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。\n\n```cpp\n// 一般在类内定义的成员函数会隐式成为inline，而在类外定义的成员函数不会(当然是否内联完全取决于编译器)\n// 类内定义，隐式内联\nclass A {\n    int doA() { return 0; }         // 隐式内联\n}\n// 类外定义，需要显式内联\nclass A {\n    int doA();\n}\ninline int A::doA() { return 0; }   // 需要显式内联\n```\n\n虚函数可以是内联函数吗？\n[Standard C++: Are “inline virtual” member functions ever actually “inlined”?](https://isocpp.org/wiki/faq/value-vs-ref-semantics#:~:text=Therefore%20the%20only%20time%20an,or%20reference%20to%20an%20object.)\n[Stackoverflow: Can virtual functions be inlined [duplicate]](https://stackoverflow.com/questions/18432040/can-virtual-functions-be-inlined)\n\n虚函数可以是内联函数，但是当虚函数表现出多态性的时候不能内联，因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性的时候不可以内联。\n\n下面是虚函数内联使用例子\n```cpp\n#include <iostream>\n\nclass Base {\npublic:\n    inline virtual void who() {\n        std::cout << \"I am Base\" << std::endl;\n    }\n    virtual ~Base() { }\n};\n\nclass Derived: public Base {\npublic:\n    // // 不写 inline 时会隐式内联\n    inline void who() {\n        std::cout << \"I am Derived\" << std::endl;\n    }\n};\n\nint main() {\n    Base fa;\n    fa.who(); // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。\n\n    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。\n    Base *ptr = new Derived();\n    ptr->who();\n\n    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。\n    delete ptr;\n    ptr = nullptr;\n\n    return 0;\n}\n```\n\n具体来说，就是\n1. 当使用类的对象来调用时，则虚函数可以当做是内联的，因为编译器在编译时就确切知道对象是哪个类的;\n2. 当使用基类指针或引用来调用虚函数时，它都不能是内联函数，因为调用发生在运行时，是动态绑定的。\n\n","tags":["C++"]},{"title":"CSAPP-计算机系统漫游","url":"/2023/10/23/CSAPP-计算机系统漫游/","content":"之前在读 xv6-book 的时候，发现自己对一些计算机底层的知识了解的太少，导致看到虚拟内存映射、物理地址这些东西的时候就很头大。在一个群友的推荐下，我决定先来看一下CSAPP的1、2、3、6、7、8、9章(当然，还有一种方案是学习CS61C)，于是有了这个系列。\n\ngitbook: https://hansimov.gitbook.io/csapp/\n\n## 系统的硬件组成\n### 1.总线\n总线是贯穿整个系统的一组电子管道。它们携带者信息字节在各个部件之间传递，传送定长的字节块(字)。字中的字节数(字长)是一个基本的系统参数，通常是4个字节(32位)、8个字节(64位)。\n\n### 2.I/O 设备\n示例有作为用户输入的键盘和鼠标，作为用户输出的显示器，用于长期存储数据和程序的磁盘驱动器(磁盘)。每个 I/O 设备都通过一个**控制器**或者**适配器**与 I/O 总线相连。\n> 控制器和适配器之间的区别在于它们的封装方式: 控制器是 I/O 设备本身或系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。功能都是在 I/O 总线和 I/O 设备之间传递信息。\n\n### 3.主存\n主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组 **动态随机获取存储器(DRAM)** 芯片组成;从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。\n\n### 4.处理器\n**中央处理单元(CPU)**简称为处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或**寄存器**)，称为**程序计数器(PC)**。在任何时刻，PC都指向主存中的某条机器语言指令(该指令的地址)\n\n处理器从通电到系统断电一直在不断从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令。\n\n这样的操作围绕着主存、寄存器文件(register file)和算数/逻辑单元(ALU)进。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。\n\nCPU在指令的要求下可能会执行如下操作:\n+ **加载:** 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容;\n+ **存储:** 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容;\n+ **操作:** 把两个寄存器的内容复制到ALU，ALU对这两个字做算数运算，并将结果存放到一个寄存器中;\n+ **跳转:** 从指令本身抽取一个字，并将这个字复制到PC中，以覆盖PC中原先的值。\n\n## 操作系统管理硬件\n操作系统有两个基本功能∶ \n1. 防止硬件被失控的应用程序滥用;\n2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。\n\n操作系统通过几个基本的抽象概念(**进程、虚拟内存和文件**)来实现。\n\n> 文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。\n\n### 进程\n进程是操作系统对一个正在运行的程序进行的一种抽象。一个CPU在同一时间只能执行一个进程，但是可以**并发运行**，即一个进程的指令和另一个进程的指令是交错执行，操作系统实现这种交错执行的机制称为**上下文切换**，而上下文就是操作系统保持跟踪进程运行所需的所有状态信息。\n\n### 线程\n在现代操作系统中，一个进程实际上可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。\n\n### 虚拟内存\n使用 xv6 里的解释\n\n虚拟内存是每个进程都会有自己独立的 page table，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的 page table 中。\n> 就比如 ls 程序会有一个内存地址 0，echo 程序也会有一个内存地址 0，但是操作系统会将两个程序的内存地址0映射到不同的物理内存地址，所以ls程序不能访问echo程序的内存，同样echo程序也不能访问ls程序的内存。\n\n### 文件\n文件就是字节序列。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。\n\n## 系统之间利用网络通信\n从一个单独的系统来看，网络可视为一个 I/O 设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。","tags":["CSAPP"]},{"title":"微信Robot使用手册","url":"/2023/10/22/微信Robot使用手册/","content":"\n> bot wechat id: liuwx_robot\n\n该机器人依赖于 [chatgpt-on-wechat](https://github.com/zhayujie/chatgpt-on-wechat) 项目进行开发\n\n主要在私聊和群聊中使用，私聊需要使用 bot 作为前缀，比如发送:\"bot 你是谁？\"，如果没有前缀将会被视为普通消息而不予回复。群聊直接 @ 即可。\n\n## 角色功能如下:\n\n以下示例指令都使用 `bot` 为前缀，这是在私聊场景中的使用方法，在群聊中，你只需要将 `bot` 前缀更换为 @ bot 即可。\n\n### 1.Chatgpt3.5\nbot 接入了 chatgpt3.5 ，可以回复你想问的任何问题，即你可以直接将该 bot 当作一个不需要挂代理的 chatgpt 使用，需要注意的是，问题回复的时间将由此时的网络代理环境和回复答案的字数而定，请耐心等待。\n\n### 2.语音识别\nbot 可以进行语音识别，你可以直接发送语音消息进行提问，bot 会对私聊和群聊中所有的语音消息进行识别并且作出回复，需要注意的是，你应该尽量使用标准的普通话。\n\n### 3.AI绘画\nbot 接入了基于 LinkAI 提供的 Midjourney 绘画，提问时只需要以为 \"画\" 为开头即可完成绘画，比如在私聊场景下你可以发送 \"bot 画一只青蛙\" 来进行绘画。\n\n### 4.文档总结\nbot 接入了基于 LinkAI 提供的文档总结对话，你向机器人发送 **文件** 或 **分享链接卡片** 即可生成摘要，进一步可以与文件或链接的内容进行多轮对话。\n> 值得注意的是，目前 bot 仅支持 txt, docx, pdf, md, csv 格式的文件，同时文件大小不能超过 5M ，文件字数最多可支持百万字的文件。分享链接 目前仅支持 公众号文章，后续会支持更多文章类型及视频链接等。\n\n### 5.角色预设\nbot 可以进行角色设定，具体使用方法以及可用角色设定可以使用 `bot $role help` 即可进行查看。\n\n### 6.冒险游戏\n使用 `bot $开始冒险 <故事背景>` ，如果不填写故事背景则会使用默认故事背景，bot 回复后你需要继续告诉 bot 后续发展，这样在你的引导下 bot 会慢慢完善这个完整的冒险游戏。\n\n### 7.管理员指令\n可以根据 `@bot #help` 进行查看，设置管理员需要在私聊中设置，具体方法为 `#auth <口令>` ，口令仅有我本人知晓。\n\n目前该机器人部署在我的个人电脑上，因此仅在开机时可以使用，后续会考虑将其部署至服务器上。\n\n该 bot 使用日期为即日起至 bot 被腾讯风控或者本人无力继续维护时，且用且珍惜。","tags":["Robot"]},{"title":"Hello World","url":"/2023/10/19/hello/","content":"\n> 你好, 世界!\n\n本博客搭建于2023年10月18日，使用 github pages + hexo 进行搭建，使用 aircloud 主题，这是一个简洁轻量的 hexo 博客主题。\n\n这是笔者第三次搭建博客，第一次也是使用 hexo 搭建的一个静态博客，可惜后来在维护过程中遇到了一些当时无法解决的问题，于是放弃。第二次是使用腾讯云服务器，基于 wordpress 框架搭建的一个动态网站，还给它取了一个响亮的名字 —— 「牛牛网」，只是可惜在使用几个月之后因为一直忙于其他事没有管理，又刚好被人注入赌博网站的暗链，导致网站被查封了。\n\n大概快一个月前，我在知乎上发布了这样一条想法:\n> \"感觉简中互联网环境下很难找到一个可以随便分享东西的平台，微信朋友圈发东西需要考虑一些微信好友的感受(浏览很多知乎问题可以看出来大家对朋友发pyq的戾气)，小红书和vb环境太差，知乎里发想法没试过，但是感觉应该也不怎么好用，其实tt是一个很合适的平台，但是感觉海外的中文互联网是一个很小的圈子大部分都是中国留学生和一些出去释放压力的非正常人完全融入不进去，而且也不想发的东西完全没人看(是的，我就是这么矛盾，想让别人看又不想让别人看)\"\n\n今天突然想到，自己搭一个网站或许是一个不错的选择，于是就有了现在的这个网站。换句话说，搭建这个网站的初衷其实不是作为一个知识分享的平台，而且作为一个个人生活分享平台，平时也许会发布一些碎碎念、一些随想随记，又或者是一些学习笔记，总而言之，这将会是一个独属于我自己的小世界，发布的内容完全随机，所以，如果某些文章内容对你造成了一些不好的影响，在此我深表歉意。\n\n我其实是一个分享欲比较强烈的人，但是从广义上来看，人生本来就是一场孤独的旅行，所以，我总是需要写点什么东西来聊以慰藉。也希望大家都能多多记录一下自己，不为被看见，只为留下痕迹。每一个当下，每一刻的感受，都是我们活着的证据。更重要的是，每一分、每一秒都是倒计时，请务必为自己而活。\n\n2023年10月19日，于湖北武汉记。"}]