<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="liuwx&#39;s home">
    <meta property="og:type" content="website">
    <meta name="description" content="liuwx&#39;s home">
    <meta name="keyword"  content="退役amer, 数学系在读">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        CSAPP-程序的机器级表示 - 刘刘大顺wx
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>

    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="刘刘大顺" type="application/atom+xml">
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 宁在一思进，莫在一思停。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.png" />
        </div>
        <div class="name">
            <i>liuwx</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="toc-text">程序编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">C编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6-x86-64"><span class="toc-text">寄存器文件(x86-64)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">PC寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-AT-amp-T"><span class="toc-text">汇编语言(AT&amp;T)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-text">操作数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-text">操作码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text">实例</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-bg" id="search-bg"></div>
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 宁在一思进，莫在一思停。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        CSAPP-程序的机器级表示
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2023-11-01 19:28:02</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#CSAPP" title="CSAPP">CSAPP</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <p>历史上出现过很多知名的指令集架构，比如Alpha， SPARC，PowerPC，MIPS等，而在今天最流行的则是x86(-64)，ARM，RISC-V。这一章以x86-64为重点。</p>
<div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/isa.png" width=""></div>


<blockquote>
<p>指令集体系结构或指令集架构(nstruetion Set Arehiteeture, ISA)，定义机器级程序的<br>格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA, 包括 x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的。</p>
</blockquote>
<p>虽然我们日常使用的编程语言多种多样，但对于计算机来说，其唯一能理解的无非就是二进制，即0和1而已。 CPU的工作流程基本可以看作为控制器从计数器(PC)取出下一条指令并执行，同时更新程序计数器的值。下面是一些基本概念:</p>
<ul>
<li><strong>Instructure Set Architecture:</strong> 指令集架构 (包括指令规格，寄存器等)，简称ISA，它是软硬件之间的“合同”</li>
<li><strong>Mircoarchitecture:</strong> 指令集架构的具体实现方式 (比如流水线级数，缓存大小等)，它是可变的</li>
<li><strong>Machine Code:</strong> 机器码，也就是机器可以直接执行的二进制指令</li>
<li><strong>Assembly Code:</strong> 汇编码，也就是机器码的文本形式 (主要是给人类阅读)</li>
</ul>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><h3 id="C编译过程"><a href="#C编译过程" class="headerlink" title="C编译过程"></a>C编译过程</h3><p>C程序的编译过程: 源代码 <code>-&gt;</code> 编译 <code>-&gt;</code> 汇编 <code>-&gt;</code> 链接 <code>-&gt;</code> 可执行文件 <code>-&gt;</code> 装载 <code>-&gt;</code> 执行</p>
<div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/05AFB7EEA96F9F7EEC5ADE1BEA97CC09.png" width=""></div> 

<p>更具体的是:</p>
<ol>
<li>预处理器(preprocessor) 把诸如 <code>#include</code>、<code>#define</code>、<code>#if</code>、<code>#else</code>、<code>#elif</code>、<code>#ifdef</code>、<code>#endif</code> 等预编译指令替换掉</li>
<li>编译器(compiler)把.c源文件编译成.s的汇编代码文件</li>
<li>汇编器(assembler)把汇编代码文件转换成相应的二进制目标文件.o，目标文件已经是机器码了，只是没有填入全局变量的地址</li>
<li>链接器(linker)，把多目标文件和库函数链接在一起，形成可执行文件</li>
</ol>
<p>在整个编译过程中，编译器会完成大部分工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。</p>
<ul>
<li>程序计数器(“PC”)，在 x86-64 中用 <code>%rip</code> 表示，给出将要执行的下一条指令在内存中的地址;</li>
<li>整数寄存器文件包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址或整数数据，有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值;</li>
<li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，可以用来实现条件控制代码比如 <code>if</code> 和 <code>while</code></li>
<li>向量寄存器可以存放一个或多个整数或浮点数值。</li>
</ul>
<blockquote>
<p>以下并不严格按照CSAPP的内容</p>
</blockquote>
<p>例如有如下 C 代码 <code>mstore.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在命令行使用 <code>gcc -Og -S mstore.c</code> , <code>-S</code> 选项会使GCC运行编译器,产生一个汇编文件 <code>mstore.s</code> , 但是不做进一步工作</p>
<p>查看该汇编文件，内容如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">	.file	<span class="string">&quot;mstore.c&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	multstore</span><br><span class="line">	.type	multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">3</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rdx, %rbx</span><br><span class="line">	call	mult2@PLT</span><br><span class="line">	movq	%rax, (%rbx)</span><br><span class="line">	popq	%rbx</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	multstore, .-multstore</span><br><span class="line">	.ident	<span class="string">&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span></span><br><span class="line">	.section	.note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line">	.section	.note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line">	.align <span class="number">8</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">1f</span> - <span class="number">0f</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">4f</span> - <span class="number">1f</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">5</span></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;GNU&quot;</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	.align <span class="number">8</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">0xc0000002</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">3f</span> - <span class="number">2f</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">	.<span class="type">long</span>	<span class="number">0x3</span></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">	.align <span class="number">8</span></span><br><span class="line"><span class="number">4</span>:</span><br></pre></td></tr></table></figure></p>
<p>我们其实只需要关注其中的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">3</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rdx, %rbx</span><br><span class="line">	call	mult2@PLT</span><br><span class="line">	movq	%rax, (%rbx)</span><br><span class="line">	popq	%rbx</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure></p>
<h3 id="寄存器文件-x86-64"><a href="#寄存器文件-x86-64" class="headerlink" title="寄存器文件(x86-64)"></a>寄存器文件(x86-64)</h3><p>16个64位的寄存器，构成了寄存器文件。</p>
<div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/5948E8CF263182DEE3C28521452B4405.png" width=""></div> 

<p>16个寄存器文件，但是有64个命名，这是因为字节数量的不同。比如 <code>%rax</code> ，存储 <code>char</code> 类型的变量时只会用到低八位，即 <code>al</code> ，存储 <code>short</code> 类型的变量则需要用到低16位，即 <code>%ax</code> ，而 <code>int</code> 类型的变量需要用到32位，即 <code>%eax</code> 。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>在 x86-64 中存在着栈空间，它存储着临时变量，担任过程调用的中转站，即保留返回地址、参数等。栈遵循先进后出原则(LIFO)。栈空间有一个栈顶指针，也就是十六个寄存器里的 <code>%rsp</code> ，在 x86-64 中，程序栈存放在内存中某个区域，栈向下增长，这样可以使得栈顶元素的地址是所有栈中元素地址最低的。栈指针 <code>%rsp</code> 保存着栈顶元素的地址，如下图</p>
<div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/4F2CBA99F7FB1F479FC93BC217889736.png" width=""></div> 

<p>栈有两个操作:</p>
<ul>
<li>压入栈(push): 将栈顶指针往下移动若干个字节，使得栈的容量增大，再把新的数据填入栈顶;</li>
<li>弹出栈(pop): 将栈顶指针上移若干字节，随着栈顶指针的上移，原来的栈顶已经被排除在栈的范围之外。</li>
</ul>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>PC(Program counter)寄存器，也就是前面说的程序计数器，用 <code>%rip</code> 表示，它并不是通用寄存器的一员，它存储着下一条要执行的指令的地址。此外，PC寄存器并不会显式地出现在汇编代码中，其值的变化都是暗地里进行的。</p>
<h2 id="汇编语言-AT-amp-T"><a href="#汇编语言-AT-amp-T" class="headerlink" title="汇编语言(AT&amp;T)"></a>汇编语言(AT&amp;T)</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>汇编代码是由多条指令组成的序列，指令序列存在内存里，PC指向下一条指令的地址，一个指令可以完成一个CPU操作。一条指令由<strong>操作码</strong>和 $0\sim 2$ 个<strong>操作数</strong>组成，操作码指定了当前指令要执行的操作，例如两数相加，操作数则是操作码的作用对象。由此可见，指令的长度并不固定。</p>
<h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>操作数可以是<strong>立即数、寄存器、内存地址</strong>，以下是三种操作数的表示方法</p>
<div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/9812E8E00347A8E30C20E1A2635EC8D1.png" width=""></div> 

<p>举例子对上图进行说明:</p>
<ol>
<li><code>$5</code> 是立即数，它的值为 5;</li>
<li><code>%rax</code> 是寄存器，它的值是寄存器 <code>%rax</code> 中的值;</li>
<li><code>0x07</code> 是内存地址，它的值是内存中地址为 <code>0x07</code> 的某种类型的值;</li>
<li><code>(%rax)</code> 是内存地址，该地址保留在寄存器 <code>%rax</code> 中;</li>
<li><code>0xf7(%rax, %rbp, 4)</code> 是内存地址，所有的内存寻址方式都可以写成这种类型。</li>
</ol>
<p>最后一种表示一个基址寻址，寻址方式是: <code>displacement(base register, index register, scale factor)</code> ，在上面个例子中:</p>
<ul>
<li>displacement(偏移)是 <code>0xf7</code>，即十六进制的偏移值F7</li>
<li>base register(基址寄存器)是 <code>%rax</code></li>
<li>index register(索引寄存器)是 <code>%rbp</code></li>
<li>scale factor(倍数因子)是 4</li>
</ul>
<p>也就是说，该表达式表示的内存地址是: <code>0xf7 + (%rax) + 4 * (%rbp)</code></p>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>操作码分为<strong>算数逻辑类、数据传输类、控制类</strong>等。</p>
<ol>
<li>算术和逻辑指令操作码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq $<span class="number">3</span>, %rdi</span><br></pre></td></tr></table></figure>
<code>add</code> 表示相加，第一个操作数是源操作数，第二个操作数是目标操作数，表示将立即数 3 加到寄存器 <code>%rdi</code> 中。而 <code>add</code> 的后缀表示操作数的大小，分别为:</li>
</ol>
<ul>
<li><code>b</code> —— 字节(byte, 8bit);</li>
<li><code>w</code> —— 字(word, 16bit);</li>
<li><code>l</code> —— 双字(doubleword, 32bit);</li>
<li><code>q</code> —— 四字(quadword, 64bit)</li>
</ul>
<p>算数和逻辑类指令操作码被分为四组: <strong>加载有效地址、一元操作、二元操作和移位</strong>，二元操作有两个操作数，而一元操作有一个操作数。如下图所示</p>
<div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/E1D9A89ED6FD8CBE5E3D5B4CD9FFCAF7.png" width=""></div> 

<ol>
<li>数据传输指令操作码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movb %bl, %al</span><br></pre></td></tr></table></figure>
将 <code>%bl</code> 寄存器中的值赋给<code>%al</code> 寄存器。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp</span><br></pre></td></tr></table></figure>
<p>表示将 <code>%rbp</code> 的值压入栈中，即先使栈顶指针寄存器<code>%rsp</code>的值减少8个字节，再将<code>%rbp</code>的值赋值给<code>%rsp</code>所指的内存单元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popq %rsi</span><br></pre></td></tr></table></figure>
<p>将栈顶的8个字节的值弹出，并赋给 <code>%rsi</code></p>
<p>除此之外，还有诸如控制类、比较和测试类操作码。</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU还维护了一组单个位的条件码(condition code)寄存器，它们<br>描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用<br>的条件码有:</p>
<ul>
<li><code>CF</code> : 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出;</li>
<li><code>ZF</code> : 零标志。最近的操作得出的结果为 0;</li>
<li><code>SF</code> : 符号标志。最近的操作得到的结果为负数;</li>
<li><code>OF</code> : 溢出标志。最近的操作导致一个补码溢出正溢出或负溢出。</li>
</ul>
<p>比如说，当使用一条 <code>add</code> 指令来完成等价于 C 表达式 <code>t = a + b</code> 的功能后，这里的变量都是整型的。然后由下面的 C 表达式来设置条件码</p>
<ul>
<li>CF —— (unsigned) t &lt; (unsigned) a —— 无符号溢出</li>
<li>ZF —— (t == 0) —— 零</li>
<li>SF —— (t &lt; 0) —— 负数</li>
<li>OF —— (a &lt; 0 == b &lt; 0) &amp;&amp; (t &lt; 0 != a &lt; 0) —— 有符号溢出</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>准备一个 <code>test.c</code> 文件，写入如下代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>gcc -Og -S test.c</code> 命令可以得到 *.s 的汇编语言文件，加入 <code>-Og</code> 的目的是使得到的汇编代码与源代码尽可能的对应。更好的办法是:</p>
<p>首先编译源代码得到目标文件test.o<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -Og test.c</span><br></pre></td></tr></table></figure></p>
<p>然后用反汇编命令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d test.o</span><br></pre></td></tr></table></figure></p>
<p>得到如下:</p>
<div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/521877CBD05A3E6B85EAAA99A1A59C92.png" width=""></div> 

<p>首先 <code>0000000000000000 &lt;main&gt;</code> ，前面的 16 个 0 是十六进制下的 0，也就是二进制下的 64 个 0, 表示该函数所在的虚拟地址，而 <code>&lt;main&gt;</code> 则是函数名。接下来是函数体，0、4、8、f…是各指令的地址，也是十六进制，因为第一条指令有4个字节(f3、0f、1e、fa)所以第二条指令的地址和第一条指令地址相差 4。</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        <li>
            <a target="_blank" href="https://twitter.com/DanielGrif67907">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-twitter"></i>
                            </span>
            </a>
        </li>
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/li-zhi-meng-49">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/wxLiu925">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="#">Copyright © 2023 liuwx</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://giscus.app/client.js"
    data-repo="wxLiu925/blog-comments"
    data-repo-id="R_kgDOKi3_Rw"
    data-category="Announcements"
    data-category-id="DIC_kwDOKi3_R84CaTAG"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
</script>




</html>
