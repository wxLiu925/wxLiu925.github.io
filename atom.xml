<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘刘大顺</title>
  <icon>https://www.gravatar.com/avatar/70602d1ab7a2560418e69761351f7bdf</icon>
  <subtitle>宁在一思进，莫在一思停。</subtitle>
  <link href="https://wxliu925.github.io/atom.xml" rel="self"/>
  
  <link href="https://wxliu925.github.io/"/>
  <updated>2023-10-26T06:01:32.366Z</updated>
  <id>https://wxliu925.github.io/</id>
  
  <author>
    <name>liuwx</name>
    <email>1557172715@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习与模式识别:手写数字识别</title>
    <link href="https://wxliu925.github.io/2023/10/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>https://wxliu925.github.io/2023/10/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2023-10-26T04:50:58.000Z</published>
    <updated>2023-10-26T06:01:32.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>数据集选择</li><li>Bayes判别分类</li><li>Fisher 线性判别</li><li>SVM的线性与非线性分类</li><li>不同分类器之间的比较</li></ol><blockquote><p>原始数据集上传至网盘: <a href="https://pan.baidu.com/s/1uqmJg7EGxpKR62j-Qbr1ow?pwd=jjrc">https://pan.baidu.com/s/1uqmJg7EGxpKR62j-Qbr1ow?pwd=jjrc</a></p></blockquote><h2 id="实验数据特征提取方法"><a href="#实验数据特征提取方法" class="headerlink" title="实验数据特征提取方法"></a>实验数据特征提取方法</h2><p>手写数字样本。每个数字有 $50$ 张图片，选择其中 $40$ 个作为训练集，$10$ 个作为测试集。</p><p>首先将含有全部特征信息的手写数字图像从坐标轴中提取出来，将提取出来的书写数字图像进行二值化处理; 将处理后的每个数字图像提取 $5\times 5$ 块模板，每个模块中 1 值像素点与总像素点的比值就是这个模块的特征值。将所有特征值放入 $5\times 5$ 的矩阵。设定阈值 $T = 0.05$，每块内所对应的元素白像素占有率大于 $T$ ，则该块特征取1;否则取0。</p><p>选择minst手写数字数据集，因为图片尺寸为28x28不为5的倍数，使用中心裁剪法将图像裁剪为25x25的大小再进行分块操作与特征提取。</p><p>数据处理(特征提取) <code>dataset.m</code> 代码如下:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 数据集处理</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[train_X, train_Y, test_X, test_Y]</span> = <span class="title">load_datasets</span><span class="params">(train_pc)</span></span></span><br><span class="line">    <span class="comment">% 参数设置</span></span><br><span class="line">    T = <span class="number">0.05</span>;</span><br><span class="line">    kernelSize = <span class="number">5</span>;</span><br><span class="line">    imgSize = <span class="number">28</span>;</span><br><span class="line">    sub_counts = <span class="built_in">floor</span>(imgSize / kernelSize);</span><br><span class="line">    newImgSize = kernelSize * sub_counts;</span><br><span class="line">    train_X = [];</span><br><span class="line">    train_Y = [];</span><br><span class="line">    test_X = [];</span><br><span class="line">    test_Y = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> digit = <span class="number">0</span>:<span class="number">9</span></span><br><span class="line">        digitFolderPath = fullfile(<span class="string">&#x27;./mnist&#x27;</span>, num2str(digit));</span><br><span class="line">        imageFiles = dir(fullfile(digitFolderPath, <span class="string">&#x27;*.png&#x27;</span>));</span><br><span class="line">        <span class="comment">% 读取当前数字的所有图像数据</span></span><br><span class="line">        images = <span class="built_in">length</span>(imageFiles);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:images</span><br><span class="line">            imgPath = fullfile(digitFolderPath, imageFiles(<span class="built_in">i</span>).name);</span><br><span class="line">            <span class="comment">% 读取图像</span></span><br><span class="line">            img = double(imread(imgPath)); </span><br><span class="line">            <span class="comment">% 中心裁剪图像</span></span><br><span class="line">            croppedImg = centerCropImage(img, newImgSize);</span><br><span class="line">            <span class="comment">% 提取图像特征</span></span><br><span class="line">            features = getFeatures(croppedImg, kernelSize, T);</span><br><span class="line">            <span class="comment">%features = img(:);</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">i</span> &lt;= images * train_pc</span><br><span class="line">                <span class="comment">% 划分为训练集</span></span><br><span class="line">                train_X = [train_X; features&#x27;];</span><br><span class="line">                train_Y = [train_Y; digit];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">% 划分为测试集</span></span><br><span class="line">                test_X = [test_X; features&#x27;];</span><br><span class="line">                test_Y = [test_Y; digit];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">croppedImg</span> = <span class="title">centerCropImage</span><span class="params">(img, newImgSize)</span></span></span><br><span class="line">        [rows, cols] = <span class="built_in">size</span>(img);</span><br><span class="line">        startRow = <span class="built_in">floor</span>((rows - newImgSize) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        startCol = <span class="built_in">floor</span>((cols - newImgSize) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        croppedImg = img(startRow:startRow + newImgSize - <span class="number">1</span>, startCol:startCol + newImgSize - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">features</span> = <span class="title">getFeatures</span><span class="params">(img, kernelSize, T)</span></span></span><br><span class="line">        [rows, cols] = <span class="built_in">size</span>(img);</span><br><span class="line">        <span class="comment">% 计算分块数目</span></span><br><span class="line">        numBlocksRow = <span class="built_in">round</span>(rows / kernelSize);</span><br><span class="line">        numBlocksCol = <span class="built_in">round</span>(cols / kernelSize);</span><br><span class="line">        <span class="comment">% 初始化特征向量</span></span><br><span class="line">        features = <span class="built_in">zeros</span>(<span class="number">1</span>, numBlocksRow * numBlocksCol);</span><br><span class="line">    </span><br><span class="line">        blockIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:numBlocksRow</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:numBlocksCol</span><br><span class="line">                <span class="comment">% 计算分块的起始和结束位置</span></span><br><span class="line">                startRow = (<span class="built_in">i</span> - <span class="number">1</span>) * kernelSize + <span class="number">1</span>;</span><br><span class="line">                endRow = <span class="built_in">i</span> * kernelSize;</span><br><span class="line">                startCol = (<span class="built_in">j</span> - <span class="number">1</span>) * kernelSize + <span class="number">1</span>;</span><br><span class="line">                endCol = <span class="built_in">j</span> * kernelSize;</span><br><span class="line">                <span class="comment">% 计算分块的总像素数</span></span><br><span class="line">                totalPixels = kernelSize * kernelSize;</span><br><span class="line">                <span class="comment">% 计算分块内白像素的个数</span></span><br><span class="line">                whitePixels = sum(sum(img(startRow:endRow, startCol:endCol) &gt;= <span class="number">250</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">% 根据阈值T判断特征取值</span></span><br><span class="line">                <span class="keyword">if</span> whitePixels / totalPixels &gt; T</span><br><span class="line">                    features(blockIndex) = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    features(blockIndex) = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                blockIndex = blockIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        features = features&#x27;;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="朴素Bayes判别分类"><a href="#朴素Bayes判别分类" class="headerlink" title="朴素Bayes判别分类"></a>朴素Bayes判别分类</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>设 $B_i$ 表示事件: 图片为数字 $i$ ，则由 Bayes 公式有<br>$$<br>\begin{align*}<br>P(B_i|A) = \frac{P(A|B_i)P(B_i)}{\sum_{j=0}^{9} P(A|B_j)P(B_j)}<br>\end{align*}<br>$$</p><p>其中，$P(B_i)$ 在这里是先验概率，在这里等于 0.1。$P(B_i|A)$ 是后验概率，在这里是对于一张手写数字图片(事件 $A$)上的数字是 $d$ ($0\sim 9$ 对应事件 $B_0\sim B_9$)的概率，由于这里是设计基于最小错误率的贝叶斯分类器，故而认为该数字为后验概率最大的数字。</p><p>令 $\mathbf{X}$ 表示图片集合，$\mathbf{Y}$ 表示标签集合，则训练数据集可以表示为:<br>$$<br>\mathbf{T} = {(\bar{x}_1, y_1), (\bar{x}_2,y_2),\cdots, (\bar{x}_n,y_n)}<br>$$<br>其中，$\bar{x}_1,\cdots,\bar{x}_n\in \mathbf{X}$ , $y_1,\cdots,y_n\in \mathbf{Y}$ ，对于任意的 $\bar{x}_i$ 有 $\bar{x}_i = {x_i^1, x_i^2, \cdots, x_i^m}$ 意为第 $i$ 张图片的 $m$ 个特征。</p><p>对于训练数据集 $P(X,Y)$ 独立同分布，所以有<br>$$<br>P(X|Y) = \frac{P(X,Y)}{P(Y)}<br>$$<br>又有先验概率 $P(Y = c_k) = 0.1$ , $k=0,1,\cdots,9$ , 而条件概率<br>$$<br>P(X=x|Y=c_k) = P(X^1=x^1,X^2=x^2,\cdots,X^m=x^m|Y=c_k)<br>$$<br>又因为这里数据的条件概率分布是特征条件独立，所以进一步地可以表示为<br>$$<br>P(X=x|Y=c_k) = \prod_{j=1}^m P(X^j=x^j|Y=c_k)<br>$$</p><blockquote><p>在这里问题里的实际含义是: 对于测试集的任意一张 $28\times 28$ 大小的手写数字图片，最后得到 25 个特征，每一个特征对应于每一个模块的取值。在朴素贝叶斯的假设条件下，这张图片是 1 的概率就是每一个特征都是 1 的特征的概率的累乘。</p></blockquote><p>进一步得到后验概率的计算公式:<br>$$<br>P(Y=c_k|X=x) = \frac{P(Y=c_k)\prod_j^m P(X^j=x^j|Y=c_k)}{\sum_kP(Y=c_k)\prod_j^m P(X^j=x^j|Y=c_k)}<br>$$</p><p>因为是要取最大值，所以可以去掉公分母，得到朴素贝叶斯分类器的判别式<br>$$<br>y = f(x) = \max_{c_k} P(Y=c_k)\prod_j P(X^j=x^j|Y=c_k)<br>$$</p><p>对每一个实验样本，选取前 40 个作为训练集，后 10 个作为测试集。</p><p>编写代码 <code>bayesClassifier.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 贝叶斯判别代码</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line">clc, clear;</span><br><span class="line"><span class="comment">% 重新加载数据</span></span><br><span class="line">load(<span class="string">&#x27;datasets.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% v = mnistData&#123;8&#125;&#123;1, 2&#125;;</span></span><br><span class="line"><span class="comment">% A = reshape(v, 5, 5)&#x27;;</span></span><br><span class="line"><span class="comment">% disp(A);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 从每个类别中选择40个样本作为训练集，10个样本作为测试集</span></span><br><span class="line">train_samples = cell(<span class="number">10</span>, <span class="number">40</span>);</span><br><span class="line">test_samples = cell(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">error_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> digit = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    <span class="comment">% 从当前类别中随机选择40个样本作为训练集</span></span><br><span class="line">    all_samples = mnistData&#123;digit&#125;;</span><br><span class="line"><span class="comment">%     random_indices = randperm(length(all_samples), 40);</span></span><br><span class="line"><span class="comment">%     % disp(random_indices);</span></span><br><span class="line"><span class="comment">%     train_samples&#123;digit&#125; = all_samples(random_indices, :);</span></span><br><span class="line">    </span><br><span class="line">    train_samples&#123;digit&#125; = all_samples(<span class="number">1</span>:<span class="number">40</span>, :);</span><br><span class="line">    <span class="comment">% 剩余的10个样本作为测试集</span></span><br><span class="line"><span class="comment">%     test_indices = setdiff(1:length(all_samples), random_indices);</span></span><br><span class="line"><span class="comment">%     test_samples&#123;digit&#125; = all_samples(test_indices, :);</span></span><br><span class="line">    test_samples&#123;digit&#125; = all_samples(<span class="number">41</span>:<span class="number">50</span>, :);</span><br><span class="line">    <span class="comment">%(test_indices);</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 重新计算先验概率和类条件概率</span></span><br><span class="line">num_classes = <span class="number">10</span>; <span class="comment">% 数字类别数量</span></span><br><span class="line">num_features = <span class="number">25</span>; <span class="comment">% 特征数量</span></span><br><span class="line">num_train = <span class="number">40</span>; <span class="comment">% 训练样本的数量</span></span><br><span class="line">num_test = <span class="number">10</span>; <span class="comment">% 测试样本的数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">true</span>_positives = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 正类别被正确分类的样本数量</span></span><br><span class="line"><span class="built_in">false</span>_positives = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 负类别被错误分类成正类别的样本数量</span></span><br><span class="line"><span class="built_in">false</span>_negatives = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 正类别被错误分类成负类别的样本数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> y = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">        <span class="comment">% 获取第i个测试样本的特征向量</span></span><br><span class="line">        test_sample = test_samples&#123;x&#125;&#123;y, <span class="number">2</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        prior_prob = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 先验概率</span></span><br><span class="line">        class_cond_prob = <span class="built_in">zeros</span>(num_features, num_classes); <span class="comment">% 类条件概率</span></span><br><span class="line">        pij = []; <span class="comment">% i类的样本第j个特征为1的概率</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_classes</span><br><span class="line">            <span class="comment">% 计算先验概率</span></span><br><span class="line">            prior_prob(<span class="built_in">i</span>) = <span class="number">0.1</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:num_features <span class="comment">% 每个数字图片提取出来的特征数</span></span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> k = <span class="number">1</span>:num_train <span class="comment">% 每个类别下训练样本的个数</span></span><br><span class="line">                    i_feature = train_samples&#123;<span class="built_in">i</span>&#125;&#123;k, <span class="number">2</span>&#125;; <span class="comment">% 获取第k个训练样本的特征向量</span></span><br><span class="line">                    sum = sum + i_feature(<span class="built_in">j</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">% disp(sum);</span></span><br><span class="line">                pij(<span class="built_in">i</span>,<span class="built_in">j</span>) = (sum + <span class="number">1</span>) / (num_train + <span class="number">2</span>); <span class="comment">% 计算概率估计值即Pj(ωi)，注意拉普拉斯平滑处理</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_classes</span><br><span class="line">            multi = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:num_features <span class="comment">% 每个数字图片提取出来的特征数</span></span><br><span class="line">                <span class="keyword">if</span>(test_sample(<span class="built_in">j</span>) == <span class="number">1</span>)</span><br><span class="line">                    multi = multi * pij(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    multi = multi * (<span class="number">1</span> - pij(<span class="built_in">i</span>,<span class="built_in">j</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            class_cond_prob(<span class="built_in">i</span>) = multi;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%计算后验概率</span></span><br><span class="line">        p_class = []; <span class="comment">% 后验概率</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:num_classes<span class="comment">%数字类别个数</span></span><br><span class="line">            sum = sum + prior_prob(<span class="built_in">i</span>) * class_cond_prob(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_classes <span class="comment">% 数字类别个数</span></span><br><span class="line">            p_class(<span class="built_in">i</span>) = prior_prob(<span class="built_in">i</span>) * class_cond_prob(<span class="built_in">i</span>) / sum;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        [maxval, maxpos] = <span class="built_in">max</span>(p_class);</span><br><span class="line">        <span class="keyword">if</span> maxpos == x</span><br><span class="line">            <span class="built_in">true</span>_positives(x) = <span class="built_in">true</span>_positives(x) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error_count = error_count + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">false</span>_positives(maxpos) = <span class="built_in">false</span>_positives(maxpos) + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">false</span>_negatives(x) = <span class="built_in">false</span>_negatives(x) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算准确率（acc）、精确率（precision）、召回率（recall）、F1-score</span></span><br><span class="line">precision = <span class="built_in">true</span>_positives ./ (<span class="built_in">true</span>_positives + <span class="built_in">false</span>_positives);</span><br><span class="line">recall = <span class="built_in">true</span>_positives ./ (<span class="built_in">true</span>_positives + <span class="built_in">false</span>_negatives);</span><br><span class="line">f1_score = <span class="number">2</span> * (precision .* recall) ./ (precision + recall);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算错误率和正确率</span></span><br><span class="line">error_rate = error_count / <span class="number">100</span>;</span><br><span class="line">accuracy = <span class="number">1</span> - error_rate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Accuracy: &#x27;</span>, num2str(accuracy)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Precision: &#x27;</span>, num2str(<span class="built_in">mean</span>(precision))]); <span class="comment">% Changed here</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Recall: &#x27;</span>, num2str(<span class="built_in">mean</span>(recall))]); <span class="comment">% Changed here</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;F1 Score: &#x27;</span>, num2str(<span class="built_in">mean</span>(f1_score))]); <span class="comment">% Changed here</span></span><br></pre></td></tr></table></figure><p>得到结果:<br>Accuracy: 0.66<br>Precision: 0.67991<br>Recall: 0.66<br>F1 Score: 0.65476</p><h2 id="Fisher判别分类"><a href="#Fisher判别分类" class="headerlink" title="Fisher判别分类"></a>Fisher判别分类</h2><p>使用 Fisher 线性判别方法求分类器的步骤:</p><ol><li>计算各类的均值向量: $\mu_i = \frac{1}{N_i}\sum_{x\in X_i}x$ ;</li><li>计算各类的类内离散矩阵: $S_{wi} = \sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^T$ ;</li><li>计算类内总离散矩阵: $S_w = S_{w0}+S_{w1}+\cdots$ ;</li><li>计算总离散矩阵的逆矩阵: $S_w^{-1}$ ;</li><li>求出向量 $w^* = S_w^{-1}(\mu_1-\mu_0)$ ;</li><li>判别函数为: $y=(w^*)^Tx$ ;</li><li>求出判别函数的阈值: $w_0 = \frac{(w^*)^T(\mu_0+\mu_1+\cdots)}{2}$ ;</li><li>比较 $y$ 值与阈值的大小得出分类。</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Fisher分类代码</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line">clc,clear;</span><br><span class="line">load(<span class="string">&#x27;datasets.mat&#x27;</span>);</span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line"></span><br><span class="line">numClasses = <span class="number">10</span>; <span class="comment">% 类别数</span></span><br><span class="line">numImages = <span class="number">50</span>; <span class="comment">% 每个类别的图像数</span></span><br><span class="line">numFeatures = <span class="number">25</span>; <span class="comment">% 特征数</span></span><br><span class="line">trainingSize = <span class="number">40</span>; <span class="comment">% 训练集大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建训练集和测试集</span></span><br><span class="line">trainingData = <span class="built_in">zeros</span>(numClasses * trainingSize, numFeatures);</span><br><span class="line">trainingLabels = <span class="built_in">zeros</span>(numClasses * trainingSize, <span class="number">1</span>);</span><br><span class="line">testData = <span class="built_in">zeros</span>(numClasses * (numImages - trainingSize), numFeatures);</span><br><span class="line">testLabels = <span class="built_in">zeros</span>(numClasses * (numImages - trainingSize), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:numClasses</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:numImages</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">j</span> &lt;= trainingSize</span><br><span class="line">            trainingData((<span class="built_in">i</span><span class="number">-1</span>)*trainingSize + <span class="built_in">j</span>, :) = mnistData&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125;&#123;<span class="built_in">j</span>,<span class="number">2</span>&#125;;</span><br><span class="line">            trainingLabels((<span class="built_in">i</span><span class="number">-1</span>)*trainingSize + <span class="built_in">j</span>) = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            testData((<span class="built_in">i</span><span class="number">-1</span>)*(numImages - trainingSize) + <span class="built_in">j</span> - trainingSize, :) = mnistData&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125;&#123;<span class="number">51</span>-<span class="built_in">j</span>,<span class="number">2</span>&#125;;</span><br><span class="line">            testLabels((<span class="built_in">i</span><span class="number">-1</span>)*(numImages - trainingSize) + <span class="built_in">j</span> - trainingSize) = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Fisher线性判别方法进行训练</span></span><br><span class="line">MdlLinear = fitcdiscr(trainingData, trainingLabels, <span class="string">&#x27;DiscrimType&#x27;</span>, <span class="string">&#x27;pseudoLinear&#x27;</span>);</span><br><span class="line"><span class="comment">% 对测试集进行预测</span></span><br><span class="line"></span><br><span class="line">predictedLabels = predict(MdlLinear, testData);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算错误率</span></span><br><span class="line">errorRate = sum(predictedLabels ~= testLabels) / <span class="built_in">length</span>(testLabels);</span><br><span class="line">fprintf(<span class="string">&#x27;Error Rate: %.2f%%\n&#x27;</span>, errorRate * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line">prior = <span class="built_in">ones</span>(<span class="number">1</span>, numClasses) / numClasses; <span class="comment">% 先验概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Fisher线性判别方法进行训练</span></span><br><span class="line">MdlLinear = fitcdiscr(trainingData, trainingLabels, <span class="string">&#x27;DiscrimType&#x27;</span>, <span class="string">&#x27;pseudoLinear&#x27;</span>, <span class="string">&#x27;Prior&#x27;</span>, prior);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对测试集进行预测</span></span><br><span class="line">predictedLabels = predict(MdlLinear, testData);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算错误率</span></span><br><span class="line">errorRate = sum(predictedLabels ~= testLabels) / <span class="built_in">length</span>(testLabels);</span><br><span class="line">fprintf(<span class="string">&#x27;Error Rate: %.2f%%\n&#x27;</span>, errorRate * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算混淆矩阵</span></span><br><span class="line">C = confusionmat(testLabels, predictedLabels);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算准确率（accuracy）</span></span><br><span class="line">accuracy = sum(<span class="built_in">diag</span>(C)) / sum(C(:));</span><br><span class="line">fprintf(<span class="string">&#x27;Accuracy: %.2f%%\n&#x27;</span>, accuracy * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算精确率（precision）</span></span><br><span class="line">precision = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">2</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;Precision: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(precision) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算召回率（recall）</span></span><br><span class="line">recall = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">1</span>)&#x27;;</span><br><span class="line">fprintf(<span class="string">&#x27;Recall: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(recall) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算F1-score</span></span><br><span class="line">f1score = <span class="number">2</span> * (precision .* recall) ./ (precision + recall);</span><br><span class="line">fprintf(<span class="string">&#x27;F1-score: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(f1score) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="多分类支持向量机"><a href="#多分类支持向量机" class="headerlink" title="多分类支持向量机"></a>多分类支持向量机</h2><h3 id="二分类支持向量机介绍"><a href="#二分类支持向量机介绍" class="headerlink" title="二分类支持向量机介绍"></a>二分类支持向量机介绍</h3><p>对于线性不可分情况引入惩罚因子 $C$ ，于是广义最优分类面问题模型如下:<br>$$<br>\max_{a} \sum_{j=1}^N a_j - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N} y_iy_ja_ia_jK(x_i,x_j) , s.t.\sum_{ i=1}^N y_ia_i=0<br>$$</p><p>其中 $0\le a_i\le C$ 。</p><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>用于训练SVM的特征使用的是图像的完整像素特征，即一张 $28\times 28$ 的图像，它的特征向量的大小为 $1\times 784$ 。将该特征进行标准化处理后即可用于训练SVM。</p><h3 id="ECOC编码与多分类SVM"><a href="#ECOC编码与多分类SVM" class="headerlink" title="ECOC编码与多分类SVM"></a>ECOC编码与多分类SVM</h3><p>ECOC(Error-Correcting Output Codes)编码是一种纠错输出编码用于将多分类任务高效地转换为多个二分类任务。Mnist数据集有0~9个数字共10分类。对应的ECOC编码如下图:<br><img src="https://i0.imgs.ovh/2023/10/26/F0SDU.png" alt="F0SDU.png"></p><p>代码如下:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 支持向量机代码</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line">clc,clear;</span><br><span class="line"></span><br><span class="line">[train_X, train_Y, test_X, test_Y] = load_datasets(<span class="number">0.8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 核函数选择，可选：&#x27;linear&#x27;,&#x27;gaussian&#x27;,&#x27;rbf&#x27;,&#x27;polynomial&#x27;</span></span><br><span class="line">KernelFunction = <span class="string">&#x27;polynomial&#x27;</span>;</span><br><span class="line"><span class="comment">% 惩罚参数C确认</span></span><br><span class="line">C = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">template = templateSVM(...</span><br><span class="line">    <span class="string">&#x27;KernelFunction&#x27;</span>, KernelFunction, ...</span><br><span class="line">    <span class="string">&#x27;PolynomialOrder&#x27;</span>, <span class="number">3</span>, ...</span><br><span class="line">    <span class="string">&#x27;KernelScale&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, ...</span><br><span class="line">    <span class="string">&#x27;BoxConstraint&#x27;</span>, C, ...</span><br><span class="line">    <span class="string">&#x27;Standardize&#x27;</span>, <span class="built_in">true</span>);</span><br><span class="line">svm_model = fitcecoc(...</span><br><span class="line">    train_X, ...</span><br><span class="line">    train_Y, ...</span><br><span class="line">    <span class="string">&#x27;Learners&#x27;</span>, template);</span><br><span class="line"></span><br><span class="line"><span class="comment">% spy(svm_model.BinaryY(1:40:400,:));</span></span><br><span class="line"><span class="comment">% title(&#x27;ECOC编码&#x27;);</span></span><br><span class="line"><span class="comment">% yticks(1:10);</span></span><br><span class="line"><span class="comment">% yticklabels(0:9);</span></span><br><span class="line"><span class="comment">% xlabel(&#x27;分类器数目&#x27;);</span></span><br><span class="line"></span><br><span class="line">predicted_labels = predict(svm_model, test_X);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算混淆矩阵</span></span><br><span class="line">C = confusionmat(test_Y, predicted_labels);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算准确率（accuracy）</span></span><br><span class="line">accuracy = sum(<span class="built_in">diag</span>(C)) / sum(C(:));</span><br><span class="line">fprintf(<span class="string">&#x27;Accuracy: %.2f%%\n&#x27;</span>, accuracy * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算精确率（precision）</span></span><br><span class="line">precision = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">2</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;Precision: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(precision) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算召回率（recall）</span></span><br><span class="line">recall = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">1</span>)&#x27;;</span><br><span class="line">fprintf(<span class="string">&#x27;Recall: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(recall) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算F1-score</span></span><br><span class="line">f1score = <span class="number">2</span> * (precision .* recall) ./ (precision + recall);</span><br><span class="line">fprintf(<span class="string">&#x27;F1-score: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(f1score) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>下表为使用全部特征进行训练、测试得到的结果。</p><table><thead><tr><th align="center">核函数</th><th align="center">惩罚参数C</th><th align="center">准确率(%)</th><th align="center">精确率(%)</th><th align="center">召回率(%)</th><th align="center">F1-score(%)</th></tr></thead><tbody><tr><td align="center">线性</td><td align="center">1</td><td align="center">86.00</td><td align="center">86.00</td><td align="center">87.83</td><td align="center">85.77</td></tr><tr><td align="center">线性</td><td align="center">100</td><td align="center">82.00</td><td align="center">82.00</td><td align="center">84.35</td><td align="center">81.44</td></tr><tr><td align="center">线性</td><td align="center">1000</td><td align="center">82.00</td><td align="center">82.00</td><td align="center">84.35</td><td align="center">81.44</td></tr><tr><td align="center">高斯</td><td align="center">1</td><td align="center">71.00</td><td align="center">71.00</td><td align="center">83.30</td><td align="center">73.64</td></tr><tr><td align="center">高斯</td><td align="center">100</td><td align="center">72.00</td><td align="center">72.00</td><td align="center">82.89</td><td align="center">73.80</td></tr><tr><td align="center">高斯</td><td align="center">1000</td><td align="center">72.00</td><td align="center">72.00</td><td align="center">82.89</td><td align="center">73.80</td></tr><tr><td align="center">三次多项式</td><td align="center">1</td><td align="center">87.00</td><td align="center">87.00</td><td align="center">87.18</td><td align="center">86.58</td></tr><tr><td align="center">三次多项式</td><td align="center">100</td><td align="center">87.00</td><td align="center">87.00</td><td align="center">87.18</td><td align="center">86.58</td></tr><tr><td align="center">三次多项式</td><td align="center">1000</td><td align="center">87.00</td><td align="center">87.00</td><td align="center">87.18</td><td align="center">86.58</td></tr></tbody></table><p>由上表得，三次多项式作为核函数效果最佳，且乘法参数C取值对评估结果没有影响。但如果选取原始特征提取方法(图像被分为5x5个块，一共提取了25个特征)，准确率将有所下降，仅能达到 60% 左右。</p><h2 id="各分类器间的比较"><a href="#各分类器间的比较" class="headerlink" title="各分类器间的比较"></a>各分类器间的比较</h2><p>无论是贝叶斯判别还是Fisher分类，两者改为多分类方法比较容易。SVM是一个性能很好的二分类算法，然而在进行多分类任务时需要多个SVM才能进行，这导致SVM在多分类任务中的准确率下降。本次实验如果全部使用提取特征后的数据来训练模型，Fisher判别表现最好，准确率在74%；其次是贝叶斯判别，准确率在66%. SVM分类效果最差，准确率为61%.<br> <br>总的来说，分类算法的选择更多取决于数据集。如果数据集规模较大，且基本线性可分，使用贝叶斯或是Fisher判别效率更高，反之应使用SVM处理更加复杂的非线性分类任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;数据集选择&lt;/li&gt;
&lt;li&gt;Bayes判别分类&lt;/li&gt;
&lt;li&gt;Fisher 线性判别&lt;/li&gt;
&lt;li&gt;S</summary>
      
    
    
    
    
    <category term="Bayes" scheme="https://wxliu925.github.io/tags/Bayes/"/>
    
    <category term="Fisher" scheme="https://wxliu925.github.io/tags/Fisher/"/>
    
    <category term="SVM" scheme="https://wxliu925.github.io/tags/SVM/"/>
    
    <category term="matlab" scheme="https://wxliu925.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>C++面经Part1</title>
    <link href="https://wxliu925.github.io/2023/10/25/C-%E9%9D%A2%E7%BB%8FPart1/"/>
    <id>https://wxliu925.github.io/2023/10/25/C-%E9%9D%A2%E7%BB%8FPart1/</id>
    <published>2023-10-25T06:26:07.000Z</published>
    <updated>2023-10-26T04:40:40.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>主要有以下作用:</p><ol><li>修饰变量，说明该变量不可改变;</li><li>修饰指针，这里分为<strong>指向常量的指针(指针常量，pointer to const)<strong>和</strong>自身是常量的指针(常量指针，const pointer)</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;a; <span class="comment">// 指针常量，指向的值不可以使用*p修改，*p = 10 错误，可以修改指向的地址</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p2 = &amp;a; <span class="comment">// 常量指针，指针指向的地址不可改变，p2 = &amp;b 错误，可以修改该地址的变量值</span></span><br></pre></td></tr></table></figure></li><li>修饰引用，指向常量的引用，用于形参类型，既避免了拷贝，又避免了函数对值进行修改</li><li>类内修饰成员函数，说明该成员函数内不能修改成员变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x) &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一个普通函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 常成员函数，不得修改类中任何数据的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一个常函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj1;</span><br><span class="line">    <span class="type">const</span> A obj2;</span><br><span class="line">    obj1.<span class="built_in">func</span>(); <span class="comment">// &quot;这是一个普通函数&quot;</span></span><br><span class="line">    obj2.<span class="built_in">func</span>(); <span class="comment">// &quot;这是一个常函数&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，普通对象可以调用普通函数也可以调用常函数，前者优先，如果是常量对象的话，只能调用常函数，如果调用普通函数会导致报错。</p><p>进一步地</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">(<span class="type">char</span>* <span class="type">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function4</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"><span class="comment">// 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="type">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>主要有以下作用:</p><ol><li><strong>修饰普通变量:</strong> 修改变量的存储区域和生命周期，使变量存储在静态区域，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。需要注意的是: 在函数内部定义了一个静态变量，生命周期到程序结束，但是这个变量的作用域仅限于声明它的函数内部。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myFunction</span>(); <span class="comment">// 输出 Count: 1</span></span><br><span class="line">    <span class="built_in">myFunction</span>(); <span class="comment">// 输出 Count: 2</span></span><br><span class="line">    <span class="comment">// 这里无法直接访问 count</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>修饰普通函数:</strong> 表明函数的作用范围，仅在定义该函数的文件内才能使用，它的作用域被限制在声明它的文件中，即它变成了一个“内部链接”的函数，只能在当前文件内部访问。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;这是一个静态函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// File2.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myFunction</span>(); <span class="comment">// 错误，无法访问静态函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>修饰成员变量:</strong> 修饰成员变量时该变量将被所有该类的对象共享，而不是每个对象拥有一份副本，而且不需要生成对象就可以访问该成员。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 静态成员变量的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line"></span><br><span class="line">    obj1.count = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; obj2.count &lt;&lt; std::endl; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>修饰成员函数:</strong> 修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内只能访问 static 成员。</li></ol><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p><code>this</code> 指针是一个特殊的指针，它指向当前对象的地址。在 C++ 中，每个类的非静态成员函数都有一个隐含的 `this`` 指针，它指向调用该成员函数的对象。</p><p>当一个类对象调用成员函数时，编译程序先将对象的地址赋给了 <code>this</code> 指针，然后调用该成员函数，每次成员函数存取数据成员时，都其实是在隐式地使用 <code>this</code> 指针。</p><p><code>this</code> 指针是一个常量指针，被隐含地声明为: <code>ClassName *const this</code> ，这意味着不能给 <code>this</code> 指针赋值，而在 <code>const</code> 成员函数里被声明为 <code>const ClassName* const</code></p><p>最后还需要注意的是，<code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址(不能 <code>&amp;this</code>)</p><h3 id="左值和右值-引用"><a href="#左值和右值-引用" class="headerlink" title="左值和右值(引用)"></a>左值和右值(引用)</h3><ol><li>左值(lvalue)</li></ol><ul><li>左值既能够出现在等号左边，也能出现在等号右边</li><li>左值可以被赋值，可以作为赋值语句的目标</li><li>左值是可寻址的变量，有持久性</li><li>具体来说，变量、对象或者通过解引用获得的指针都属于左值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// x 是左值，因为它代表一个内存位置，可以被赋值</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;x; <span class="comment">// &amp;x 是左值，因为它是变量 x 的地址</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>右值(rvalue)</li></ol><ul><li>右值是不能被赋值的表达式，它们代表的是一个数值或者临时值，通常在赋值语句的右侧</li><li>右值可以是一个常数、一个临时的计算结果或者一个表达式的返回值。</li><li>右值在使用后就失去意义，因此不能被取地址<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>; <span class="comment">// 10 是右值，因为它代表一个数值，不能被赋值</span></span><br><span class="line"><span class="type">int</span> z = x + y; <span class="comment">// x + y 是右值，因为它代表一个临时计算结果</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>C++ Prime:” 当一个对象被用作右值的时候，用的是对象的值(内容);当对象被用作左值时，用的是对象的身份(在内存中的位置)”</p></blockquote><p>左值引用(lvalue reference)和右值引用(rvalue reference)是C++中引入的两种不同类型的引用。</p><ol start="3"><li><strong>左值引用:</strong> 左值引用是最常见的引用类型。它们使用 <code>&amp;</code> 符号声明，并且只能绑定到左值(可以取地址的表达式)。</li><li><strong>右值引用:</strong> 右值引用是在C++11中引入的新特性，用 &amp;&amp; 符号表示。它们可以绑定到临时值、表达式结果或具有名称的右值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">6</span>; <span class="comment">// x是左值，6是右值</span></span><br><span class="line"><span class="type">int</span> &amp;y = x; <span class="comment">// 左值引用，y引用x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;z1 = x * <span class="number">6</span>; <span class="comment">// 错误，x*6是一个右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;z2 = x * <span class="number">6</span>; <span class="comment">// 正确，右值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;z3 = x; <span class="comment">// 错误，x是一个左值</span></span><br></pre></td></tr></table></figure><blockquote><p>可以引用右值的除了右值引用外还有 const 左值引用，例如 <code>const int &amp;z4 =  x * 6;</code> 正确，可以将一个const引用绑定到一个右值。例如 <code>std::vector</code> 的 <code>push_back</code> 函数就使用了 const 左值引用(<code>void push_back (const value_type&amp; val);</code>) ，这样能让我们使用 <code>v.push_back(1)</code> 这样的代码。</p></blockquote></li></ol><p><code>std::move</code> 可以实现将左值转换成右值以实现对左值进行右值引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j;</span><br><span class="line">j = std::<span class="built_in">move</span>(<span class="number">2</span>); <span class="comment">// 合法，从一个右值移动数据</span></span><br><span class="line">j = std::<span class="built_in">move</span>(i); <span class="comment">// 合法，从一个左值移动数据，i的值之后是不确定的。</span></span><br></pre></td></tr></table></figure><h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><p>主要有以下特征:</p><ul><li>相当于把内联函数里面的内容写在调用内联函数处;</li><li>相当于不用执行进入函数的步骤，直接执行函数体;</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性;</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数;</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在类内定义的成员函数会隐式成为inline，而在类外定义的成员函数不会(当然是否内联完全取决于编译器)</span></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure><p>虚函数可以是内联函数吗？<br><a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics#:~:text=Therefore%20the%20only%20time%20an,or%20reference%20to%20an%20object.">Standard C++: Are “inline virtual” member functions ever actually “inlined”?</a><br><a href="https://stackoverflow.com/questions/18432040/can-virtual-functions-be-inlined">Stackoverflow: Can virtual functions be inlined [duplicate]</a></p><p>虚函数可以是内联函数，但是当虚函数表现出多态性的时候不能内联，因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性的时候不可以内联。</p><p>下面是虚函数内联使用例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// // 不写 inline 时会隐式内联</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base fa;</span><br><span class="line">    fa.<span class="built_in">who</span>(); <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，就是</p><ol><li>当使用类的对象来调用时，则虚函数可以当做是内联的，因为编译器在编译时就确切知道对象是哪个类的;</li><li>当使用基类指针或引用来调用虚函数时，它都不能是内联函数，因为调用发生在运行时，是动态绑定的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;const&quot;&gt;&lt;a href=&quot;#const&quot; class=&quot;headerlink&quot; title=&quot;const&quot;&gt;&lt;/a&gt;const&lt;/h3&gt;&lt;p&gt;主要有以下作用:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修饰变量，说明该变量不可改变;&lt;/li&gt;
&lt;li&gt;修饰指针，这里分为&lt;s</summary>
      
    
    
    
    
    <category term="C++" scheme="https://wxliu925.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-计算机系统漫游</title>
    <link href="https://wxliu925.github.io/2023/10/23/CSAPP-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>https://wxliu925.github.io/2023/10/23/CSAPP-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2023-10-23T03:21:29.000Z</published>
    <updated>2023-10-26T04:40:42.617Z</updated>
    
    <content type="html"><![CDATA[<p>之前在读 xv6-book 的时候，发现自己对一些计算机底层的知识了解的太少，导致看到虚拟内存映射、物理地址这些东西的时候就很头大。在一个群友的推荐下，我决定先来看一下CSAPP的1、2、3、6、7、8、9章(当然，还有一种方案是学习CS61C)，于是有了这个系列。</p><p>gitbook: <a href="https://hansimov.gitbook.io/csapp/">https://hansimov.gitbook.io/csapp/</a></p><h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><h3 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h3><p>总线是贯穿整个系统的一组电子管道。它们携带者信息字节在各个部件之间传递，传送定长的字节块(字)。字中的字节数(字长)是一个基本的系统参数，通常是4个字节(32位)、8个字节(64位)。</p><h3 id="2-I-O-设备"><a href="#2-I-O-设备" class="headerlink" title="2.I/O 设备"></a>2.I/O 设备</h3><p>示例有作为用户输入的键盘和鼠标，作为用户输出的显示器，用于长期存储数据和程序的磁盘驱动器(磁盘)。每个 I/O 设备都通过一个<strong>控制器</strong>或者<strong>适配器</strong>与 I/O 总线相连。</p><blockquote><p>控制器和适配器之间的区别在于它们的封装方式: 控制器是 I/O 设备本身或系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。功能都是在 I/O 总线和 I/O 设备之间传递信息。</p></blockquote><h3 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h3><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组 <strong>动态随机获取存储器(DRAM)</strong> 芯片组成;从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。</p><h3 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h3><p><strong>中央处理单元(CPU)<strong>简称为处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或</strong>寄存器</strong>)，称为**程序计数器(PC)**。在任何时刻，PC都指向主存中的某条机器语言指令(该指令的地址)</p><p>处理器从通电到系统断电一直在不断从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令。</p><p>这样的操作围绕着主存、寄存器文件(register file)和算数/逻辑单元(ALU)进。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。</p><p>CPU在指令的要求下可能会执行如下操作:</p><ul><li><strong>加载:</strong> 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容;</li><li><strong>存储:</strong> 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容;</li><li><strong>操作:</strong> 把两个寄存器的内容复制到ALU，ALU对这两个字做算数运算，并将结果存放到一个寄存器中;</li><li><strong>跳转:</strong> 从指令本身抽取一个字，并将这个字复制到PC中，以覆盖PC中原先的值。</li></ul><h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>操作系统有两个基本功能∶ </p><ol><li>防止硬件被失控的应用程序滥用;</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ol><p>操作系统通过几个基本的抽象概念(<strong>进程、虚拟内存和文件</strong>)来实现。</p><blockquote><p>文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。</p></blockquote><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序进行的一种抽象。一个CPU在同一时间只能执行一个进程，但是可以<strong>并发运行</strong>，即一个进程的指令和另一个进程的指令是交错执行，操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>，而上下文就是操作系统保持跟踪进程运行所需的所有状态信息。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在现代操作系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>使用 xv6 里的解释</p><p>虚拟内存是每个进程都会有自己独立的 page table，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的 page table 中。</p><blockquote><p>就比如 ls 程序会有一个内存地址 0，echo 程序也会有一个内存地址 0，但是操作系统会将两个程序的内存地址0映射到不同的物理内存地址，所以ls程序不能访问echo程序的内存，同样echo程序也不能访问ls程序的内存。</p></blockquote><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件就是字节序列。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。</p><h2 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><p>从一个单独的系统来看，网络可视为一个 I/O 设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前在读 xv6-book 的时候，发现自己对一些计算机底层的知识了解的太少，导致看到虚拟内存映射、物理地址这些东西的时候就很头大。在一个群友的推荐下，我决定先来看一下CSAPP的1、2、3、6、7、8、9章(当然，还有一种方案是学习CS61C)，于是有了这个系列。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="https://wxliu925.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>微信Robot使用手册</title>
    <link href="https://wxliu925.github.io/2023/10/22/%E5%BE%AE%E4%BF%A1Robot%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://wxliu925.github.io/2023/10/22/%E5%BE%AE%E4%BF%A1Robot%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2023-10-22T08:08:42.000Z</published>
    <updated>2023-10-23T03:19:36.475Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>bot wechat id: liuwx_robot</p></blockquote><p>该机器人依赖于 <a href="https://github.com/zhayujie/chatgpt-on-wechat">chatgpt-on-wechat</a> 项目进行开发</p><p>主要在私聊和群聊中使用，私聊需要使用 bot 作为前缀，比如发送:”bot 你是谁？”，如果没有前缀将会被视为普通消息而不予回复。群聊直接 @ 即可。</p><h2 id="角色功能如下"><a href="#角色功能如下" class="headerlink" title="角色功能如下:"></a>角色功能如下:</h2><p>以下示例指令都使用 <code>bot</code> 为前缀，这是在私聊场景中的使用方法，在群聊中，你只需要将 <code>bot</code> 前缀更换为 @ bot 即可。</p><h3 id="1-Chatgpt3-5"><a href="#1-Chatgpt3-5" class="headerlink" title="1.Chatgpt3.5"></a>1.Chatgpt3.5</h3><p>bot 接入了 chatgpt3.5 ，可以回复你想问的任何问题，即你可以直接将该 bot 当作一个不需要挂代理的 chatgpt 使用，需要注意的是，问题回复的时间将由此时的网络代理环境和回复答案的字数而定，请耐心等待。</p><h3 id="2-语音识别"><a href="#2-语音识别" class="headerlink" title="2.语音识别"></a>2.语音识别</h3><p>bot 可以进行语音识别，你可以直接发送语音消息进行提问，bot 会对私聊和群聊中所有的语音消息进行识别并且作出回复，需要注意的是，你应该尽量使用标准的普通话。</p><h3 id="3-AI绘画"><a href="#3-AI绘画" class="headerlink" title="3.AI绘画"></a>3.AI绘画</h3><p>bot 接入了基于 LinkAI 提供的 Midjourney 绘画，提问时只需要以为 “画” 为开头即可完成绘画，比如在私聊场景下你可以发送 “bot 画一只青蛙” 来进行绘画。</p><h3 id="4-文档总结"><a href="#4-文档总结" class="headerlink" title="4.文档总结"></a>4.文档总结</h3><p>bot 接入了基于 LinkAI 提供的文档总结对话，你向机器人发送 <strong>文件</strong> 或 <strong>分享链接卡片</strong> 即可生成摘要，进一步可以与文件或链接的内容进行多轮对话。</p><blockquote><p>值得注意的是，目前 bot 仅支持 txt, docx, pdf, md, csv 格式的文件，同时文件大小不能超过 5M ，文件字数最多可支持百万字的文件。分享链接 目前仅支持 公众号文章，后续会支持更多文章类型及视频链接等。</p></blockquote><h3 id="5-角色预设"><a href="#5-角色预设" class="headerlink" title="5.角色预设"></a>5.角色预设</h3><p>bot 可以进行角色设定，具体使用方法以及可用角色设定可以使用 <code>bot $role help</code> 即可进行查看。</p><h3 id="6-冒险游戏"><a href="#6-冒险游戏" class="headerlink" title="6.冒险游戏"></a>6.冒险游戏</h3><p>使用 <code>bot $开始冒险 &lt;故事背景&gt;</code> ，如果不填写故事背景则会使用默认故事背景，bot 回复后你需要继续告诉 bot 后续发展，这样在你的引导下 bot 会慢慢完善这个完整的冒险游戏。</p><h3 id="7-管理员指令"><a href="#7-管理员指令" class="headerlink" title="7.管理员指令"></a>7.管理员指令</h3><p>可以根据 <code>@bot #help</code> 进行查看，设置管理员需要在私聊中设置，具体方法为 <code>#auth &lt;口令&gt;</code> ，口令仅有我本人知晓。</p><p>目前该机器人部署在我的个人电脑上，因此仅在开机时可以使用，后续会考虑将其部署至服务器上。</p><p>该 bot 使用日期为即日起至 bot 被腾讯风控或者本人无力继续维护时，且用且珍惜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;bot wechat id: liuwx_robot&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该机器人依赖于 &lt;a href=&quot;https://github.com/zhayujie/chatgpt-on-wechat&quot;&gt;chatgpt-on-w</summary>
      
    
    
    
    
    <category term="Robot" scheme="https://wxliu925.github.io/tags/Robot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wxliu925.github.io/2023/10/19/hello/"/>
    <id>https://wxliu925.github.io/2023/10/19/hello/</id>
    <published>2023-10-19T08:14:03.000Z</published>
    <updated>2023-10-22T14:11:39.505Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你好, 世界!</p></blockquote><p>本博客搭建于2023年10月18日，使用 github pages + hexo 进行搭建，使用 aircloud 主题，这是一个简洁轻量的 hexo 博客主题。</p><p>这是笔者第三次搭建博客，第一次也是使用 hexo 搭建的一个静态博客，可惜后来在维护过程中遇到了一些当时无法解决的问题，于是放弃。第二次是使用腾讯云服务器，基于 wordpress 框架搭建的一个动态网站，还给它取了一个响亮的名字 —— 「牛牛网」，只是可惜在使用几个月之后因为一直忙于其他事没有管理，又刚好被人注入赌博网站的暗链，导致网站被查封了。</p><p>大概快一个月前，我在知乎上发布了这样一条想法:</p><blockquote><p>“感觉简中互联网环境下很难找到一个可以随便分享东西的平台，微信朋友圈发东西需要考虑一些微信好友的感受(浏览很多知乎问题可以看出来大家对朋友发pyq的戾气)，小红书和vb环境太差，知乎里发想法没试过，但是感觉应该也不怎么好用，其实tt是一个很合适的平台，但是感觉海外的中文互联网是一个很小的圈子大部分都是中国留学生和一些出去释放压力的非正常人完全融入不进去，而且也不想发的东西完全没人看(是的，我就是这么矛盾，想让别人看又不想让别人看)”</p></blockquote><p>今天突然想到，自己搭一个网站或许是一个不错的选择，于是就有了现在的这个网站。换句话说，搭建这个网站的初衷其实不是作为一个知识分享的平台，而且作为一个个人生活分享平台，平时也许会发布一些碎碎念、一些随想随记，又或者是一些学习笔记，总而言之，这将会是一个独属于我自己的小世界，发布的内容完全随机，所以，如果某些文章内容对你造成了一些不好的影响，在此我深表歉意。</p><p>我其实是一个分享欲比较强烈的人，但是从广义上来看，人生本来就是一场孤独的旅行，所以，我总是需要写点什么东西来聊以慰藉。也希望大家都能多多记录一下自己，不为被看见，只为留下痕迹。每一个当下，每一刻的感受，都是我们活着的证据。更重要的是，每一分、每一秒都是倒计时，请务必为自己而活。</p><p>2023年10月19日，于湖北武汉记。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你好, 世界!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本博客搭建于2023年10月18日，使用 github pages + hexo 进行搭建，使用 aircloud 主题，这是一个简洁轻量的 hexo 博客主题。&lt;/p&gt;
&lt;p&gt;这是笔者第三</summary>
      
    
    
    
    
  </entry>
  
</feed>
