<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘刘大顺</title>
  <icon>https://www.gravatar.com/avatar/70602d1ab7a2560418e69761351f7bdf</icon>
  <subtitle>宁在一思进，莫在一思停。</subtitle>
  <link href="https://wxliu925.github.io/atom.xml" rel="self"/>
  
  <link href="https://wxliu925.github.io/"/>
  <updated>2023-11-25T12:08:26.877Z</updated>
  <id>https://wxliu925.github.io/</id>
  
  <author>
    <name>liuwx</name>
    <email>1557172715@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT6.s081Lec01 Note</title>
    <link href="https://wxliu925.github.io/2023/11/25/MIT6-s081Lec01-Note/"/>
    <id>https://wxliu925.github.io/2023/11/25/MIT6-s081Lec01-Note/</id>
    <published>2023-11-25T11:05:26.000Z</published>
    <updated>2023-11-25T12:08:26.877Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统经典的组织架构，一般最底层包括了计算机的一些硬件资源，包括CPU、内存、磁盘、网卡等。而在这个架构的最上层则运行着各种各样的应用程序，这些程序都运行在同一个空间中，这个空间被称为<strong>用户空间(Usersapce)</strong></p><p>区别于运行在用户空间里的程序，有一个特殊的程序总是在运行，他称作<strong>Kernel</strong>。</p><p>当打开计算机时，Kernel总是第一个启动，Kernel 程序只有一个，它维护数据来管理每一个用户空间进程，同时还维护了大量的数据结构来管理底层的硬件资源，以供用户空间的程序使用。因此，Kernel的核心功能就是: <strong>管理硬件设备，供应用程序使用</strong></p><p>我们通常会比较关心Kernel中的服务，一个是<strong>文件系统</strong>，另一个是<strong>进程管理系统</strong></p><blockquote><p>每一个用户空间程序都被称为一个进程，他们有自己的内存和共享的CPU时间。<br>同时, Kernel会管理内存的分配，不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。</p></blockquote><p>文件系统通常会有一些逻辑分区，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有的这些都被文件系统所管理。</p><h3 id="Kernel的Access-Control机制"><a href="#Kernel的Access-Control机制" class="headerlink" title="Kernel的Access Control机制"></a>Kernel的Access Control机制</h3><p>当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control 机制会决定是否允许这样的操作。</p><h3 id="Kernel的系统调用-System-Call"><a href="#Kernel的系统调用-System-Call" class="headerlink" title="Kernel的系统调用(System Call)"></a>Kernel的系统调用(System Call)</h3><p>我们同时也会对应用程序如何与Kernel交互，它们之间的接口长什么样感兴趣，这些通常称为Kernel的API，它们决定了应用程序如何访问Kernel。通常来说，这是通过 <strong>系统调用(System Call)</strong> 来实现的。</p><p>系统调用于程序中的函数调用看起来是一样的，区别在于<strong>系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现</strong>。</p><blockquote><p>第一个例子是如果应用程序要打开一个文件，它会调用名为 open 的系统调用，并且把文件名作为参数传给 open。比如我要打开一个名为 “out” 的文件，那么 “out” 将会作为参数传人，同时还希望写入数据，那么还会有一个额外的参数 1 , 表明我想要写入参数，就是 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">API-Kernel</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;out&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里看起来就像是一个函数调用，但是 open 是一个系统调用，它会跳到Kernel, Kernel可以获取到 open 的参数，接下来执行实现 open 的 Kernel 代码，最后返回一个文件描述符对象，之后，应用程序可以使用这个文件描述符作为 handle , 来表示打开相应的文件。</p><p>如果想要向文件写入数据，相应的系统调用则是 write .<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;out&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;Hello\n&quot;</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><ol><li>第一个参数是由 open 返回的文件描述符</li><li>第二个参数是指向要写入数据的指针，通常是 char 型。实际上是内存中的地址</li><li>第三个参数是写入字符的数量</li></ol><p>除此之外还可能用到的系统调用是 fork, 它会创建一个与调用进程一模一样的进程，并返回新进程的 process ID/pid。</p><blockquote><p>系统调用跳到内核与标准的函数调用跳到另一个函数相比，区别是什么？<br>A: Kernel会有特殊的权限能够直接访问到底层硬件，而普通的用户程序是没有办法直接访问这些硬件的。</p></blockquote><h4 id="系统调用-copy"><a href="#系统调用-copy" class="headerlink" title="系统调用-copy"></a>系统调用-copy</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy.c: copy input to output.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(<span class="number">1</span>, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序执行了三个系统调用：read、write、exit</p><h4 id="系统调用-read"><a href="#系统调用-read" class="headerlink" title="系统调用-read"></a>系统调用-read</h4><p>它接收三个参数：</p><ol><li><strong>第一个参数是文件描述符</strong>，指向一个之前打开的文件。Shell 会确保在默认情况下，当一个程序启动时，文件描述符0链接到console的输入，文件描述符1链接到console的输出，所以可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。这里的0，1文件描述符是非常普遍的Unix风格，许多的Unix系统都会从文件描述符0读取数据，然后向文件描述符1写入数据。</li><li><strong>第二个参数是指向某段内存的指针</strong>，程序可以通过指针对应的地址读取内存中的数据。</li><li><strong>第三个参数是代码想读取的最大长度。</strong></li></ol><p><strong>read 的返回值是读到的字节数，如果读到文件结尾没有更多内容了read会返回0，如果发生了一些错误比如文件描述符不存在则会返回-1。</strong></p><h4 id="系统调用-open"><a href="#系统调用-open" class="headerlink" title="系统调用-open"></a>系统调用-open</h4><p>前面 copy 代码假设文件描述符已经设置好了，但是一般情况下，我们需要创建文件描述符，最直接的创建文件描述符的方法就是使用open系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//open.c: create a file, write to it.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREATE);</span><br><span class="line">    write(fd, <span class="string">&quot;ooo\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个程序会创建一个叫做 output.txt 的新文件，并向它写入一些数据，最后退出。我们看不到任何输出，因为它只是向打开的文件中写入数据。</p><ol><li>第一个参数是文件名</li><li>第二个参数是一些标志位，用来告诉 open 系统调用在内核中的实现：我们将要创建并写入一个文件。</li></ol><p>open 系统调用会返回一个新分配的文件描述符，通常是一个比较小的数字，2、3、4等。</p><p>之后这个文件描述符作为第一个参数传入 write，数据被写入到了文件描述符对应的文件中。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p><strong>文件描述符本质上对应了一个内核中的表单数据</strong>。内核维护了每个运行程序的状态，内核会为每一个运行进程保存一个表单，表单的 key 是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的是，<strong>每个进程都有自己独立的文件描述符空间</strong>，所以如果运行了两个不同的程序，对应两个不同的进程，如果他们都打开一个文件，他们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。</p><blockquote><p>文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。Linux中”万物皆可文件”</p></blockquote><h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><p>Shell 通常就是人们说的命令行接口。它提供了很多工具来管理文件，编写程序，编写脚本。通常来说，当你输入内容时，其实是在告诉Shell运行相应的程序，比如输入 ls 时，实际意义就是要求 Shell 运行名为 ls 的程序，文件系统中有一个文件名为 ls, 这个文件中包含一些计算机指令。</p><p>除了运行程序以外，Shell还可以做其他事情，比如重定向IO<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &gt; out</span><br></pre></td></tr></table></figure><br>要求Shell运行ls程序并将输出重定向到一个叫做out的文件中，然后可以通过 <code>cat</code> 命令来读取 out 中的数据。也可以运行一个叫做 <code>grep</code> 的程序。grep x会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep x &lt; out</span><br></pre></td></tr></table></figure></p><h4 id="系统调用-fork"><a href="#系统调用-fork" class="headerlink" title="系统调用-fork"></a>系统调用-fork</h4><p>下面是一个简单用例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork.c: create a new process</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork() returned %d&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用 fork 会拷贝当前进程的内存并且创建一个新的进程，这里的内存包含了进程的指令和数据，之后就有了两个拥有完全一样内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。(完全相同的内存，但是是不同的内存地址，此外，文件描述符也会被拷贝)</p><h4 id="系统调用-exec-wait"><a href="#系统调用-exec-wait" class="headerlink" title="系统调用-exec, wait"></a>系统调用-exec, wait</h4><p>echo是一个非常简单的命令，它接收任何你传递给它的输入，并将输入写到输出。</p><p>下面是一个 exec 系统调用的简单使用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exec.c: replace a process with an executable file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 指针0是一个NULL指针，它只表明结束</span></span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码会执行 exec 系统调用，这个系统调用会从指定的文件中读取并加载命令，并替代当前调用进程的指令。从某种程度上来说相当于丢弃了调用进程的内存，并开始执行新加载的指令。所以上面的代码执行 exec 命令后会有这样的效果：操作系统从名为 echo 的文件中加载指令到当前的进程中，并替代了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec允许传入一个命令行参数的数组，这里是一个C语言中的指针数组，这里的字符指针本质就是一个字符串。</p><p>所以这里等价于运行 echo 命令，并且带上 “this is echo” 这三个参数。我们可以看到如下输出:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is echo</span><br></pre></td></tr></table></figure><br>即我运行了exec程序，exec程序实际上会调用exec系统调用，并用echo指令来代替自己，所以这里是echo命令在产生输出。</p><blockquote><p>exec命令用于调用并执行指定的命令。exec命令通常用在shell脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。系统调用 exec 是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。</p></blockquote><p>除此之外，还有一些值得注意的地方：</p><ol><li>exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等，它们在新的程序中表示相同的东西。</li><li>通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。exec系统调用只会当出错时才会返回，例如程序文件根本不存在，因为exec系统调用不能找到文件，exec会返回-1。</li></ol><p>如果不想原进程被替代的话，可以先 fork 一个子进程，然后在子进程里调用exec系统调用。下面是一个应用场景<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forkexec.c: fork then exec</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid, status;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;THIS&quot;</span>, <span class="string">&quot;IS&quot;</span>, <span class="string">&quot;ECHO&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent waiting\n&quot;</span>);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the child exited with status %d\n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个程序中先调用了fork，在子进程中与前一个程序一样调用exec。子进程会用echo命令来代替自己，echo执行完成之后就退出。之后父进程重新获得了控制。fork会在父进程中返回大于0的值。</p><blockquote><p>Unix提供了一个wait系统调用，如第20行所示。wait会等待之前创建的子进程退出。当我在命令行执行一个指令时，我们一般会希望Shell等待指令执行完成。所以wait系统调用，使得父进程可以等待任何一个子进程返回。这里wait的参数status，是一种让退出的子进程以一个整数（32bit的数据）的格式与等待的父进程通信方式。所以在第17行，exit的参数是1，操作系统会将1从退出的子进程传递到第20行，也就是等待的父进程处。&amp;status，是将status对应的地址传递给内核，内核会向这个地址写入子进程向exit传入的参数。wait返回子进程的进程号。</p><p>Unix中的风格是，如果一个程序成功的退出了，那么exit的参数会是0，如果出现了错误，那么就会像第17行一样，会向exit传递1。</p></blockquote><h4 id="IO重定向-Redirect"><a href="#IO重定向-Redirect" class="headerlink" title="IO重定向(Redirect)"></a>IO重定向(Redirect)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redirect.c: run a command with output redirected</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY|O_CREATE);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;redirect&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shell提供了方便的IO重定向工具，<code>echo hello &gt; out</code> 会将 <code>echo</code> 的输出重定向到 <code>out</code> 文件中，然后运行 <code>cat &lt; out</code> 就可以看到输出。</p><blockquote><p>Shell之所以有这样的能力，是因为Shell首先会先fork一个子进程，然后再子进程里，Shell改变了文件描述符。文件描述符1通常是进程用来作为输出的(也就是console的输出文件符)，Shell会先将文件描述符1改为output文件，之后再运行你的指令。同时，父进程的文件描述符1并没有改变。所以这里先fork，再更改子进程的文件描述符，是Unix中常见的重定向指令的输入输出的方法。</p></blockquote><p>运行上面的代码，没有看到任何的输出，但实际上 redirect 程序里运行了 echo，并且把 echo 的输出重定向到 output.txt。在output.txt里可以看到 “this is redirect echo”。代码里 <code>close(1)</code> 的意义是我们希望文件描述符1指向一个其他的位置，也就是说，在子进程里，我们不想使用原本指向console的文件描述符1。后面的 <code>open</code> 语句一定会返回1，因为 open 会返回当前进程未使用的最小文件描述符。因为刚刚关闭了文件描述符1，而文件描述符0又对应着console的输入，所以open一定会返回1。再之后，文件描述符1就和output.txt关联起来了。</p><h4 id="管道-PIPE"><a href="#管道-PIPE" class="headerlink" title="管道-PIPE"></a>管道-PIPE</h4><p>管道是一种通信机制，通常用于进程间的通信，将前一个进程的输出(stdout)作为下一下进程的输入(stdin)。管道命令仅能处理standard output，也就是说类似 <code>less</code>、<code>head</code>、<code>tail</code>等可以接受标准输入的命令，而管道又可以分为匿名管道和有名管道。</p><p>匿名管道用 <code>|</code> 来表示，用完即销毁，例如 <code>ls -al /etc | less</code> 。而有名管道又被称为先进先出队列(FIFO)，可以通过 <code>mkfifo</code> 命令来显式地常见，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo hello</span><br></pre></td></tr></table></figure><br>会在当前文件夹下创建一个管道文件 <code>hello</code> ，然后可以执行 <code>echo &quot;hello world&quot; &gt; hello</code> 往管道里写入 <code>hello world</code> ，然后因为管道是同步的，所以在当前终端下会发生阻塞，需要新打开一个终端，然后执行 <code>cat &lt; hello</code> 命令就可以将管道中的数据读取出来并打印，然后之前的终端阻塞也停止了。</p><p>需要注意的是，当进程对命名管道的使用结束后，命名管道依然存在于文件系统中，使用 <code>ls</code> 命令可以看到该文件，需要手动删除。</p><p>管道的创建是系统调用 <code>pipe()</code> ，该函数创建了一个管道 <code>pipe</code> 并且返回两个文件描述符用来表示管道的两端，读取端描述符是 <code>fd[0]</code> ，写入端描述符是 <code>fd[1]</code> 。</p><p>而我们之所以能够使用类似 <code>ls -al /etc | less</code> 这样的命令来进行两个进程之间的通信，主要是进行了如下实现:</p><ol><li>首先在当前进程下创建一个管道 <code>fd[2]</code> ，然后使用 <code>fork</code> 创建一个子进程，此时 <code>fd</code> 数组同样会被复制，但是由于它们指向了同一个文件(管道)，所以就实现了两个进程通过 <code>fd</code> 数组对同一个管道进行跨进程读写操作。</li><li>禁用父进程的读取端，禁用子进程的写入端，就实现了从父进程写入由子进程读取的单向操作。</li></ol><p>下面这段程序运行了 <code>wc</code> ，并将它的标准输出绑定到了一个管道的读端口:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(fd[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段程序首先创建了一个管道，然后 <code>fork</code> 出一个子进程，这样父子进程都指向同一个管道。</p><p>在子进程中，首先关闭了标准输入(文件描述符为0)，然后使用 <code>dup(fd[0])</code> 复制了管道的读端，由于复制操作会使用最小可用的文件描述符，所以管道的读端成为了新的标准输入。接着，关闭了管道的两个端口，因为复制后就不再需要原来的文件描述符。最后，使用 <code>exec</code> 函数执行了 <code>wc</code> 命令，wc命令会从标准输入(现在是管道的读端)读取数据。</p><p>在父进程中，使用write函数向管道的写端写入了字符串”hello world\n”。然后，关闭了管道的两个端口。总的来说就是这里实现了父进程向子进程传输 “hello world\n” ，然后子进程调用 <code>wc</code> 命令处理这个字符串，输出行数、单词数和字节数，在这里应该是输出 <code>1 2 12</code> 。</p><p>如果数据没有准备好，那么对管道执行的 <code>read</code> 会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。后者 <code>read</code> 会返回 0，这也是为什么执行 <code>wc</code> 之前要关闭子进程的写端口 —— 防止堵塞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;操作系统经典的组织架构，一般最底层包括了计算机的一些硬件资源，包括CPU、内存、磁盘、网卡等。而在这个架构的最上层则运行着各种各样的应用程序，这些程序都运行在同一个空间中，这个空间被称为&lt;strong&gt;用户空间(Usersapce)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区别于运</summary>
      
    
    
    
    
    <category term="OS" scheme="https://wxliu925.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-处理器体系结构</title>
    <link href="https://wxliu925.github.io/2023/11/21/CSAPP-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://wxliu925.github.io/2023/11/21/CSAPP-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2023-11-21T11:55:13.000Z</published>
    <updated>2023-11-25T12:51:54.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在正式开始之前"><a href="#写在正式开始之前" class="headerlink" title="写在正式开始之前"></a>写在正式开始之前</h2><p>这一部分内容，并非是CSAPP第四章笔记，因为该章节设计了一个 Y68-64 指令集架构，然而这并不通用，且并不优雅。这里选择 [RISC-V] 作为学习方式，阅读「RISC-V 手册」来写了这篇笔记。</p><p>计算机体系结构的传统方法是增量ISA, 也就是在实现新的ISA扩展的同时还需要实现过去的所有扩展。而 RISC-V 的区别就在于它是模块化的，其核心是一个名为 RV32I 的基础 ISA，RV32I 是固定的，永远也不会改变，再次之外提供了可选的扩展标准，惯例是把代表扩展的字母附加到指令集名称之后作为指示，例如 RV32IMFD 将 乘法(RV32M)，单精度浮点(RV32F)和双精度浮点(RV32D)的扩展添加到了基础指令集(RV32I)中。</p><p>在正式开始之前，推荐观看 <a href="https://www.bilibili.com/video/BV1bE411C76e/?spm_id_from=333.999.list.card_archive.click">从沙子到芯片-中芯国际</a></p><center>      <img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/74E7C9D2AD0A22A10EC654DF565EDFBE.png" width="" height=""></center><center>      图一: 半导体IC的制造过程[计算机组成与设计:硬件/软件接口(RISC-V版)]</center>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在正式开始之前&quot;&gt;&lt;a href=&quot;#写在正式开始之前&quot; class=&quot;headerlink&quot; title=&quot;写在正式开始之前&quot;&gt;&lt;/a&gt;写在正式开始之前&lt;/h2&gt;&lt;p&gt;这一部分内容，并非是CSAPP第四章笔记，因为该章节设计了一个 Y68-64 指令集架构，然</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="https://wxliu925.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>万物的开始:Riemann积分</title>
    <link href="https://wxliu925.github.io/2023/11/15/%E4%B8%87%E7%89%A9%E7%9A%84%E5%BC%80%E5%A7%8B-Riemann%E7%A7%AF%E5%88%86/"/>
    <id>https://wxliu925.github.io/2023/11/15/%E4%B8%87%E7%89%A9%E7%9A%84%E5%BC%80%E5%A7%8B-Riemann%E7%A7%AF%E5%88%86/</id>
    <published>2023-11-15T11:46:37.000Z</published>
    <updated>2023-11-21T15:16:11.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>“微积分是近代数学中最伟大的成就，对它的重要性无论做怎样的估计都不会。”</em></p></blockquote><p>在现代数学体系里，「微积分」是及其重要的组成部分，而积分又由不定积分和定级分组成，后者又被称作「黎曼积分」(Riemann integral)。微积分发展至今，黎曼积分首次对函数在给定区间上的积分给出了一个精确定义。</p><h3 id="Riemann积分定义"><a href="#Riemann积分定义" class="headerlink" title="Riemann积分定义"></a>Riemann积分定义</h3><p>设函数 $f$ 在区间 $[a,b]$ 上有定义</p><p>$\rm \textbf{Definition 1.}$ 如果点集 $P=\{x_0,x_1,\cdots,x_n\}$ 满足 $a=x_0&lt;x_1&lt;\cdots&lt;x_{n-1}&lt;x_n=b$ , 则称 $P$ 为 $[a,b]$ 的一个<strong>分划</strong>. 设 $\Delta x_i = x_i-x_{i-1},i=1,2,\cdots,n$ , 则称 $||P|| = \max\limits_{1\le i\le n} \{\Delta x_i\}$ 为分划 $P$ 的<strong>细度</strong> . 如果 $\Delta x_i=\frac{b-a}{n},i=1,2,\cdots,n$ , 则称 $P$ 为<strong>等距分划</strong></p><p>$\rm \textbf{Definition 2.}$ 设 $P$ 是区间 $[a, b]$ 的一个分划，对每个子区间 $[x_{i-1},x_i]$ , 任取 $\xi_i\in [x_{i-1},x_i]$ , 则称 $\xi = \{\xi_i|i=1,2,\cdots,n\}$ 为从属于 $P$ 的一个<strong>介点集</strong>; 并称和式 $\sum\limits_{i=1}^n f(\xi_i)\Delta x_i$ 为 $f$ 在区间 $[a,b]$ 上的一个<strong>Riemann和</strong>.</p><p>$\rm \textbf{Definition 3.}$ 设 $I$ 为实数，且有 $\lim\limits_{||P||\to 0}\sum\limits_{i=1}^n f(\xi_i)\Delta x_i = I$ , 即 $\forall \varepsilon &gt;0$ , $\exists \delta &gt; 0$ , 对 $||P||&lt;\delta$ 的每个分划 $P$, 以及对从属于 $P$ 的每个介点集 $\xi$ , 成立 $|\sum\limits_{i=1}^n f(\xi_i)\Delta x_i - I|&lt;\varepsilon$ , 则称函数 $f$ 在区间 $[a,b]$ 上<strong>Riemann可积</strong>或简称<strong>可积</strong>, 记为 $f\in R[a,b]$ . 并称 $I$ 为 $f$ 在区间 $[a,b]$ 上的<strong>Riemann积分</strong>或<strong>定积分</strong>, 简称积分, 记为 $\int_a^b f = I$ .</p><h3 id="Riemann可积条件"><a href="#Riemann可积条件" class="headerlink" title="Riemann可积条件"></a>Riemann可积条件</h3><p>$\rm \textbf{Definitions 4.}$ 设函数 $f$ 在 $[a,b]$ 上有界, $P$ 为 $[a,b]$ 的一个分划, 对 $i=1,2,\cdots,n$ , 记</p><script type="math/tex; mode=display">\begin{align*}M_i &= \sup\{f(x)|x\in [x_{i-1},x_i]\}\\m_i &= \inf\{f(x)|x\in [x_{i-1},x_i]\}\\\end{align*}</script><p>称 $w_i = M_i-m_i$ 为 $f$ 在 $[x_{i-1},x_i]$ 上的<strong>振幅</strong>, $\sum\limits_{i=1}^n w_i\Delta x_i$ 为 $f$ 的<strong>振幅面积</strong>.</p><p>$\rm \textbf{Proposition 1.}$(可积的第一充要条件): 有界函数 $f\in R[a, b]$ 的充分必要条件是</p><script type="math/tex; mode=display">\begin{align}\lim_{||P||\to 0}\sum_{i=1}^n w_i \Delta x_i = 0\end{align}</script><p>$\rm \textbf{Proposition 2.}$(可积的第二充要条件): 有界函数 $f\in R[a, b]$ 的充分必要条件是对每个 $\varepsilon &gt; 0$ , 存在区间 $[a,b]$ 的一个分划 $P$ 使得</p><script type="math/tex; mode=display">\begin{align}\sum_{P}w_i\Delta x_i< \varepsilon\end{align}</script><p>$\rm \textbf{Proposition 3.}$(可积的第三充要条件): 有界函数 $f\in R[a, b]$ 的充分必要条件是 $\forall \varepsilon, \eta &gt;0$, 存在 $[a,b]$ 的分划 $P$ , 使振幅不小于 $\eta$ 的子区间的长度之和小于 $\varepsilon$ .</p><p>利用定级分定义以及三个充分必要条件可以得到一些推论:</p><ol><li>设 $f\in R[a, b]$ , 则 $f$ 在 $[a, b]$ 上有界</li><li>设 $f\in C[a, b]$ , 则 $f\in R[a, b]$</li><li>设 $f$ 在 $[a, b]$ 上有界且只有有限个间断点，则 $f\in R[a, b]$</li><li>设 $f$ 在 $[a, b]$ 上单调, 则 $f\in R[a, b]$</li></ol><p>下面对这四个结论一一进行证明</p><p>$\rm \textbf{Corollary 1.1} \quad Proof.$ 记 $\int_a^b f = I$ , 由定积分定义知, 对于 $\varepsilon = 1$, 存在一个分划 $P$ , 使得对于从属于这个 $P$ 的任何介点集 $\xi$ 均成立</p><script type="math/tex; mode=display">\left|\sum_{i=1}^n f(\xi_i)\Delta x_i - I\right| < 1</script><p>对于确定的子区间 $[x_{i-1},x_i]$ , 固定所有的 $\xi_k$($k\ne i$) 对 $f(\xi_i)$ 作出如下估计</p><script type="math/tex; mode=display">\frac{1}{\Delta x_i}(I-1-\sum_{k\ne i}f(\xi_{k}\Delta x_k)) < f(\xi_i)<\frac{1}{\Delta x_i}(I+1-\sum_{k\ne i}f(\xi_k)\Delta x_k)</script><p>由于 $\xi_i \in I_i = [x_{i-1},x_i]$ 的任意性, 可得 $f$ 在 $[a, b]$ 上有界.</p><p>$\rm \textbf{Corollary 1.2} \quad Proof.$</p><p>考虑如下热传导方程的初边值问题</p><script type="math/tex; mode=display">\begin{cases}u_t -a^2u_{xx}=f(x,t), (x,t)\in(0,L)\times (0,+\infty)\\u(x,0) = \varphi(x), x\in (0, L)\\u_x(0, t) = g_1(t), u_x(L,t) = g_2(t), t\in (0, +\infty)\end{cases}</script><p>请证明该问题的解是唯一的. (提示: 请考虑与 Dirichlet 边界条件的异同和关系)</p><p>考虑如下热传导方程的 Cauchy 问题</p><script type="math/tex; mode=display">\begin{cases}u_t - a^2 \Delta u = f(x, t), (x, t)\in R^3 \times (0, +\infty)\\u(x,0) = \varphi(x) , x\in R^3\end{cases}</script><p>若存在着某一正常数 $B$, 使对任何 $t\ge 0$ 和 $x\in R^3$ 都有 $|u(x, t)|\le B$ .请证明该 Cauchy 问题的解是唯一的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“微积分是近代数学中最伟大的成就，对它的重要性无论做怎样的估计都不会。”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在现代数学体系里，「微积分」是及其重要的组成部分，而积分又由不定积分和定级分组成，后者又被称作「黎曼积分」(Rie</summary>
      
    
    
    
    
    <category term="数学分析" scheme="https://wxliu925.github.io/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
    
    <category term="积分" scheme="https://wxliu925.github.io/tags/%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理Lab1-图像增强的空域方法</title>
    <link href="https://wxliu925.github.io/2023/11/11/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86Lab1-%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E7%9A%84%E7%A9%BA%E5%9F%9F%E6%96%B9%E6%B3%95/"/>
    <id>https://wxliu925.github.io/2023/11/11/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86Lab1-%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E7%9A%84%E7%A9%BA%E5%9F%9F%E6%96%B9%E6%B3%95/</id>
    <published>2023-11-11T09:58:56.000Z</published>
    <updated>2023-11-11T10:12:10.947Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列是针对数学图像处理课程的实验以及大作业写的手册。原始代码已上传至github。四次实验的内容分别为:<br>Lab1: 图像增强的空域方法<br>Lab2: 图像增强的频域方法<br>Lab3: 图像压缩编码实现<br>Lab4(大作业): 美颜算法原理及其实现</p><p>地址: <a href="https://github.com/wxLiu925/Whut-ExperimentProject/tree/main/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80">https://github.com/wxLiu925/Whut-ExperimentProject/tree/main/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80</a></p><h2 id="实验内容-Lab1"><a href="#实验内容-Lab1" class="headerlink" title="实验内容(Lab1)"></a>实验内容(Lab1)</h2><ol><li>读入一副彩色图像(非卡通), 大小为256*256, 观察它的每个点象素;将该彩色图像变成灰度图像; 将该图像的直方图画出来, 要求自己编写函数绘制直方图的函数。</li><li>自己编写函数，进行直方图均衡化，并显示均衡化后的图像。</li><li>将该彩色图像使用 imnoise 函数加入各种噪声，显示图像；或者读入一副低<br>质量被噪声污染的图像。</li><li>分别使用 conv2 函数、fspecial 函数和 imfilter 函数，对受噪声污染的图像进行均值滤波和中值滤波、高斯滤波。要求设置不同大小的均值滤波模板，改变权值，测试试验结果。中值滤波要求能设置不同的滤波窗口大小，显示结果。请尽量使用矩阵的整体运算，来代替循环计算。</li><li>读入另外一副图像，对其采取不同的 roberts/laplace/sobel/priwitt 边缘锐化算子进行边缘增强和锐化，并显示不同算子的计算结果。对原始图像加入噪声，观察锐化后的效果。要求：请尽量避免循环运算，而使用矩阵整体运算。</li><li>结合试验结果，对不同图像空域增强方法进行分析和比较，写出你的实验体会。</li><li>对锐化算子的处理结果中，如果计算得到小于零的值，对小于 0 的部分，采用不同的方法标准化到[0,255]时，图像的显示效果有什么不同？为什么？</li></ol><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>这个实验没什么好讲的，实验内容比较简单，也比较繁杂，更多细节请看代码注释。</p><h3 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h3><ol><li>均值滤波和高斯滤波：这两种方法都是线性滤波器，主要用于减少图像中的噪声。均值滤波器简单易用，但可能会使图像变得模糊。高斯滤波器可以更好地保留图像的细节，但计算复杂度较高。</li><li>中值滤波：中值滤波是一种非线性滤波器，特别适合于去除椒盐噪声。它可以保留图像的边缘信息，但可能会导致图像的纹理信息丢失。</li><li>Sobel、Laplace、Prewitt和Roberts边缘检测：这些方法都是用于图像的边缘检测和锐化。Sobel和Prewitt操作符可以更好地保留边缘信息，但对噪声敏感。Laplace操作符可以检测所有方向的边缘，但可能会导致边缘变得较薄。Roberts操作符简单易用，但可能会错过一些细微的边缘信息。</li></ol><p>总的来说，如果图像中存在大量的高斯噪声，应该选择使用高斯滤波器。如果需要检测图像的边缘，则应该选择使用Sobel或Laplace操作符。</p><h3 id="T7"><a href="#T7" class="headerlink" title="T7"></a>T7</h3><p>在图像处理中，像素值通常被标准化或缩放到[0,255]的范围。当我们应用锐化算子后，有可能得到小于0的值。对于这些小于0的值，我们需要进行处理以便能在[0,255]的范围内表示。以下是两种常用的处理方法：</p><ol><li>截断处理：这种方法将所有小于0的值设为0。这是最直接的方法，但可能会导致一些信息丢失，因为所有小于0的值都变成了同样的值（即0）。</li><li>缩放处理：这种方法将所有的值（包括大于0的值）线性缩放到[0,255]的范围。这种方法可以保留更多的信息，因为它保持了原始数据中的相对差异。但这种方法可能会使图像看起来较暗，因为所有的值都被缩小了。<br>这两种方法会导致不同的显示效果。截断处理可能会导致图像在某些地方看起来有”断裂”，因为所有小于0的值都变成了0，可能会造成边缘信息的丢失。而缩放处理则能保留更多的边缘信息，但可能会使整个图像看起来较暗。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个系列是针对数学图像处理课程的实验以及大作业写的手册。原始代码已上传至github。四次实验的内容分别为:&lt;br&gt;Lab1: 图像增强的空域方法&lt;br&gt;Lab2: 图像增强的频域方法&lt;br&gt;Lab3: 图像压缩编码实现&lt;br&gt;Lab4(大作业): 美颜算法原理及其实现&lt;/</summary>
      
    
    
    
    
    <category term="C++" scheme="https://wxliu925.github.io/tags/C/"/>
    
    <category term="OpenCV" scheme="https://wxliu925.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-第二章(Homework)</title>
    <link href="https://wxliu925.github.io/2023/11/01/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-Homework/"/>
    <id>https://wxliu925.github.io/2023/11/01/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-Homework/</id>
    <published>2023-11-01T12:17:36.000Z</published>
    <updated>2023-11-03T11:24:40.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-57"><a href="#2-57" class="headerlink" title="2.57"></a>2.57</h3><blockquote><p>编写程序 <code>show_short</code> 、<code>show_long</code> 、<code>show_double</code>，它们分别打印类型为 <code>short</code>、<code>long</code> 和 <code>double</code> 的字节表示。</p></blockquote><p><code>char</code> 是字符型，但也是属于整形的，因为 <code>char</code> 最终存储的是 ASCLL 码值到内存的。一个 <code>char</code> 有 8 个位，所以能存储的范围为 $-128\sim 127$ ，而 <code>unsigned char</code> 存储的范围为 $0\sim 255$ 。因为它占用一个字节，所以 <code>unsigned char</code> 可以精确地表示一个字节的所有可能值，所以它通常用于存储和处理字节数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_byte</span><span class="params">(byte_pointer start, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    <span class="comment">// 展示十六进制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x&quot;</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 展示二进制(大端)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">7</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (start[i] &gt;&gt; j) &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_short</span><span class="params">(<span class="type">short</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;short: \n&quot;</span>);</span><br><span class="line">    show_byte((byte_pointer)&amp;num, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_long</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;long: \n&quot;</span>);</span><br><span class="line">    show_byte((byte_pointer)&amp;num, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_float</span><span class="params">(<span class="type">float</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;float: \n&quot;</span>);</span><br><span class="line">    show_byte((byte_pointer)&amp;num, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_double</span><span class="params">(<span class="type">double</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double: \n&quot;</span>);</span><br><span class="line">    show_byte((byte_pointer)&amp;num, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">365</span>;</span><br><span class="line">    show_short((<span class="type">short</span>)num);</span><br><span class="line">    show_long((<span class="type">long</span>)num);</span><br><span class="line">    show_float((<span class="type">float</span>)num);</span><br><span class="line">    show_double((<span class="type">double</span>)num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-58"><a href="#2-58" class="headerlink" title="2.58"></a>2.58</h3><blockquote><p>编写过程 <code>is_little_endian</code> ，当在小端法机器上编译和运行时返回1，在大端法机器上编译运行时则返回0。这个程序应该可以运行在任何机器上，无论机器的字长是多少。</p></blockquote><p>计算机存储数据在地址上都是由低到高，大小端的区别为小端法存储数据由低位到高位，而大端法则是由高位到低位，例如数据 <code>0x12345678</code> 小端法存储就是 <code>78 56 34 12</code>，而大端法存储则是 <code>12 34 56 78</code> 。<br>可以使用 <code>union</code> 来实现，在 <code>union</code> 中存放两个数据，一个 <code>int</code> 一个 <code>char</code> ，<code>char</code> 占的地址为 <code>int</code> 数据的第一个字节，修改 <code>int</code> 值为1，这样就只需要判断 char 数据是否为 1 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_little_endian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125; test;</span><br><span class="line">    test.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)test.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-59"><a href="#2-59" class="headerlink" title="2. 59"></a>2. 59</h3><blockquote><p>编写一个 C 表达式，它生成一个字，由 $x$ 的最低有效字节和 $y$ 中剩下的字节组成。对于运算数 <code>x = 0x89ABCDEF</code> 和 <code>y = 0x76543210</code> 得到 <code>0x765432EF</code>。</p></blockquote><ul><li><strong>位(bit)是计算机内部数据存储的最小单位</strong>，只能取0或者取1;</li><li><strong>字节(byte)是计算机数据处理的最小单位</strong>，每个字节有8个二进制位，其中最右边的一位为最低位，最左边的一位为最高位;</li><li><strong>字是计算机进行数据处理和运算的单位</strong>，即cpu一次处理二进制代码的位数，字的位数叫做字长，字长的大小与计算架构有关，通常说的32位机就是一个字有4个字节，32个位。</li></ul><p><code>x &amp; 0xFF</code>, 得到 x 最低有效位，<code>y &amp; ~0xFF</code> 得到 y 最低有效位之外的位，两者进行或运算，得到组合结果<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line">...</span><br><span class="line"><span class="type">size_t</span> x = <span class="number">0x89ABCDEF</span>;</span><br><span class="line"><span class="type">size_t</span> y = <span class="number">0x76543210</span>;</span><br><span class="line"><span class="type">size_t</span> mask = <span class="number">0xff</span>;</span><br><span class="line"><span class="type">size_t</span> res = ((x &amp; mask) | (y &amp; ~mask));</span><br><span class="line">byte_pointer start = (byte_pointer)&amp; res;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="type">size_t</span>); i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2x&quot;</span>, start[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出: ef32547600000000 (小端法机器)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="2-60"><a href="#2-60" class="headerlink" title="2.60"></a>2.60</h3><blockquote><p>假设我们将一个 $w$ 位的字中的字节从 0(最低位)到 $\frac{w}{8} - 1$(最高位)编号。写出下面C函数代码，它会返回一个无符号值，其中参数 $x$ 的字节 $i$ 被替换成字节 $b$ :<br><code>unsigned replace_byte (unsigned x, inti, unsigned char b);</code><br>以下示例说明其如何工作:<br><code>replace_byte(Ox12345678, 2, OxAB) --&gt; Ox12AB5678</code><br><code>replace_byte(Ox12345678, 0, OxAB) --&gt; Ox123456AB</code></p></blockquote><p>按要求模拟就好了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @brief 参数 x 的字节 i 被替换成字节 b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">replace_byte</span> <span class="params">(<span class="type">unsigned</span> x, <span class="type">int</span> i, <span class="type">unsigned</span> <span class="type">char</span> b)</span> &#123;</span><br><span class="line">    byte_pointer start = (byte_pointer)&amp; x;</span><br><span class="line">    start[i] = b;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span>*)start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_byte</span><span class="params">(byte_pointer start, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x&quot;</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> res1 = replace_byte(<span class="number">0x12345678</span>, <span class="number">2</span>, <span class="number">0xAB</span>);</span><br><span class="line">    <span class="type">unsigned</span> res2 = replace_byte(<span class="number">0x12345678</span>, <span class="number">0</span>, <span class="number">0xAB</span>);</span><br><span class="line">    show_byte((byte_pointer)&amp;res1, <span class="keyword">sizeof</span>(<span class="type">unsigned</span>));</span><br><span class="line">    show_byte((byte_pointer)&amp;res2, <span class="keyword">sizeof</span>(<span class="type">unsigned</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">7856ab12</span></span><br><span class="line"><span class="comment">ab563412</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>这里提一下最后为什么返回 <code>*(unsigned*)start</code> ，这里先要将 <code>unsigned char *</code> 类型的 <code>start</code> 转变为 <code>unsigned*</code> ，即先转换指针类型，再去指针指向地址的值，而如果使用 <code>(unsigned)(*start)</code> 的话，<code>*start</code> 由于是 <code>unsigned char</code> 类型的指针，所以只会取出第一个地址的值，而不是所有的内存单元。</p><p>在接下来的作业中，我们特意限制了你能使用的编程结构，来帮你更好地理解 C 语言的位级、逻辑<br>和算术运算。在回答这些问题时，你的代码必须遵守以下规则:</p><ul><li>假设:<ul><li>整数用补码形式表示;</li><li>有符号数的右移是算术右移;</li><li>数据类型 <code>int</code> 是 $w$ 位长的。对于某些题目，会给定 $w$ 的值，但是在其他情况下，只要 $2$ 是 8 的整数倍，你的代码就应该能工作。你可以用表达式 <code>sizeof(int)&lt;&lt;3</code> 来计算 $w$。</li></ul></li><li>禁止使用<ul><li>条件语句、循环、分支语句、函数调用和宏调用;</li><li>除法、模运算和乘法;</li><li>相对比较运算($&gt;$ 、$&lt;$ 、$\le$ 和 $\ge$)。</li></ul></li><li>允许的运算<ul><li>所有的位级和逻辑运算;</li><li>左移和右移，但是位移量只能在 $0$ 到 $w-1$ 之间;</li><li>加法和减法;</li><li>相等(==)和不等(!=)测试。(有些题目里也不允许这些运算);</li><li>整型常数 <code>INT_MAX</code> 和 <code>INT_MIN</code>;</li><li>对 <code>int</code> 和 <code>unsigned</code> 进行强制类型转换，无论是显式的还是隐式的。</li></ul></li></ul><h3 id="2-61"><a href="#2-61" class="headerlink" title="2.61"></a>2.61</h3><blockquote><p>写一个C表达式，在下列描述的条件下产生1, 而在其他情况下得到 0。假设 $x$ 是 <code>int</code> 类型。<br>A. $x$ 的任何位都等于 1<br>B. $x$ 的任何位都等于 0<br>C. $x$ 的最低有效字节中的位都等于1<br>D. $x$ 的最高有效字节中的位都等于0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_byte</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> mask = <span class="number">1u</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> cnt = <span class="number">1</span>; mask; mask &gt;&gt;= <span class="number">1</span>, cnt ++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x &amp; mask ? <span class="number">1</span>: <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">4</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !~x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !~(x | ~<span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">D</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(x &gt;&gt; ((<span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="number">1</span>) &lt;&lt; <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> all_bit_one = ~<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> all_bit_zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">assert(A(all_bit_one));</span><br><span class="line">assert(!B(all_bit_one));</span><br><span class="line">assert(C(all_bit_one));</span><br><span class="line">assert(!D(all_bit_one));</span><br><span class="line"></span><br><span class="line">assert(!A(all_bit_zero));</span><br><span class="line">assert(B(all_bit_zero));</span><br><span class="line">assert(!C(all_bit_zero));</span><br><span class="line">assert(D(all_bit_zero));</span><br><span class="line"></span><br><span class="line">assert(!A(<span class="number">0x1234FF</span>));</span><br><span class="line">assert(!B(<span class="number">0x1234FF</span>));</span><br><span class="line">assert(C(<span class="number">0x1234FF</span>));</span><br><span class="line">assert(D(<span class="number">0x1234FF</span>));</span><br><span class="line"></span><br><span class="line">assert(!A(<span class="number">0x1234</span>));</span><br><span class="line">assert(!B(<span class="number">0x1234</span>));</span><br><span class="line">assert(!C(<span class="number">0x1234</span>));</span><br><span class="line">assert(D(<span class="number">0x1234</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释:</p><ol><li><code>~</code> 是对每一位取反</li><li><code>!</code> 是对值取反</li></ol><p>而 C 部分，首先是和 <code>~0xFF</code> (亦即 <code>0xFFFFFF00</code>) 做或运算，前 3 个字节都为 1，最后一个字节为 $x$ 本来的最低字节，要判断是否为全 1 只需要全部取反再判断是否为0即可</p><p>D 部分，<code>(x &gt;&gt; ((sizeof(int) - 1) &lt;&lt; 3))</code> 会得到最高位字节右移后的结果，例如<code>0011 1011 1001 1010 1100 1010 0000 0000</code> 会变为 <code>0000 0000 0000 0000 0000 0000 0011 1011</code> ，最后判断即可。</p><h3 id="2-62"><a href="#2-62" class="headerlink" title="2. 62"></a>2. 62</h3><blockquote><p>编写一个函数 <code>int_shifts_are_arithmetic()</code> 在对 <code>int</code> 类型的数使用算术右移的机器上运行时这个函数生成 1, 而其他情况下生成 0 。你的代码应该可以运行在任何字长的机器上。在几种机器上测试你的代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">int_shifts_are_arithmetic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> !(x ^ (x &gt;&gt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的有时间慢慢做…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2-57&quot;&gt;&lt;a href=&quot;#2-57&quot; class=&quot;headerlink&quot; title=&quot;2.57&quot;&gt;&lt;/a&gt;2.57&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;编写程序 &lt;code&gt;show_short&lt;/code&gt; 、&lt;code&gt;show_long&lt;/co</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="https://wxliu925.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-程序的机器级表示</title>
    <link href="https://wxliu925.github.io/2023/11/01/CSAPP-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <id>https://wxliu925.github.io/2023/11/01/CSAPP-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</id>
    <published>2023-11-01T11:28:02.000Z</published>
    <updated>2023-11-21T11:54:21.343Z</updated>
    
    <content type="html"><![CDATA[<p>历史上出现过很多知名的指令集架构，比如Alpha， SPARC，PowerPC，MIPS等，而在今天最流行的则是x86(-64)，ARM，RISC-V。这一章以x86-64为重点。</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/isa.png" width=""></div><blockquote><p>指令集体系结构或指令集架构(nstruetion Set Arehiteeture, ISA)，定义机器级程序的<br>格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA, 包括 x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的。</p></blockquote><p>虽然我们日常使用的编程语言多种多样，但对于计算机来说，其唯一能理解的无非就是二进制，即0和1而已。 CPU的工作流程基本可以看作为控制器从计数器(PC)取出下一条指令并执行，同时更新程序计数器的值。下面是一些基本概念:</p><ul><li><strong>Instructure Set Architecture:</strong> 指令集架构 (包括指令规格，寄存器等)，简称ISA，它是软硬件之间的“合同”</li><li><strong>Mircoarchitecture:</strong> 指令集架构的具体实现方式 (比如流水线级数，缓存大小等)，它是可变的</li><li><strong>Machine Code:</strong> 机器码，也就是机器可以直接执行的二进制指令</li><li><strong>Assembly Code:</strong> 汇编码，也就是机器码的文本形式 (主要是给人类阅读)</li></ul><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><h3 id="C编译过程"><a href="#C编译过程" class="headerlink" title="C编译过程"></a>C编译过程</h3><p>C程序的编译过程: 源代码 <code>-&gt;</code> 编译 <code>-&gt;</code> 汇编 <code>-&gt;</code> 链接 <code>-&gt;</code> 可执行文件 <code>-&gt;</code> 装载 <code>-&gt;</code> 执行</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/05AFB7EEA96F9F7EEC5ADE1BEA97CC09.png" width=""></div> <p>更具体的是:</p><ol><li>预处理器(preprocessor) 把诸如 <code>#include</code>、<code>#define</code>、<code>#if</code>、<code>#else</code>、<code>#elif</code>、<code>#ifdef</code>、<code>#endif</code> 等预编译指令替换掉</li><li>编译器(compiler)把.c源文件编译成.s的汇编代码文件</li><li>汇编器(assembler)把汇编代码文件转换成相应的二进制目标文件.o，目标文件已经是机器码了，只是没有填入全局变量的地址</li><li>链接器(linker)，把多目标文件和库函数链接在一起，形成可执行文件</li></ol><p>在整个编译过程中，编译器会完成大部分工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。</p><ul><li>程序计数器(“PC”)，在 x86-64 中用 <code>%rip</code> 表示，给出将要执行的下一条指令在内存中的地址;</li><li>整数寄存器文件包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址或整数数据，有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值;</li><li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，可以用来实现条件控制代码比如 <code>if</code> 和 <code>while</code></li><li>向量寄存器可以存放一个或多个整数或浮点数值。</li></ul><blockquote><p>以下并不严格按照CSAPP的内容</p></blockquote><p>例如有如下 C 代码 <code>mstore.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在命令行使用 <code>gcc -Og -S mstore.c</code> , <code>-S</code> 选项会使GCC运行编译器,产生一个汇编文件 <code>mstore.s</code> , 但是不做进一步工作</p><p>查看该汇编文件，内容如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.file<span class="string">&quot;mstore.c&quot;</span></span><br><span class="line">.text</span><br><span class="line">.globlmultstore</span><br><span class="line">.typemultstore, @function</span><br><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">endbr64</span><br><span class="line">pushq%rbx</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset <span class="number">3</span>, <span class="number">-16</span></span><br><span class="line">movq%rdx, %rbx</span><br><span class="line">callmult2@PLT</span><br><span class="line">movq%rax, (%rbx)</span><br><span class="line">popq%rbx</span><br><span class="line">.cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemultstore, .-multstore</span><br><span class="line">.ident<span class="string">&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span></span><br><span class="line">.section.note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line">.section.note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line">.align <span class="number">8</span></span><br><span class="line">.<span class="type">long</span><span class="number">1f</span> - <span class="number">0f</span></span><br><span class="line">.<span class="type">long</span><span class="number">4f</span> - <span class="number">1f</span></span><br><span class="line">.<span class="type">long</span><span class="number">5</span></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line">.<span class="built_in">string</span><span class="string">&quot;GNU&quot;</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">.align <span class="number">8</span></span><br><span class="line">.<span class="type">long</span><span class="number">0xc0000002</span></span><br><span class="line">.<span class="type">long</span><span class="number">3f</span> - <span class="number">2f</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">.<span class="type">long</span><span class="number">0x3</span></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">.align <span class="number">8</span></span><br><span class="line"><span class="number">4</span>:</span><br></pre></td></tr></table></figure></p><p>我们其实只需要关注其中的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">endbr64</span><br><span class="line">pushq%rbx</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset <span class="number">3</span>, <span class="number">-16</span></span><br><span class="line">movq%rdx, %rbx</span><br><span class="line">callmult2@PLT</span><br><span class="line">movq%rax, (%rbx)</span><br><span class="line">popq%rbx</span><br><span class="line">.cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure></p><h3 id="寄存器文件-x86-64"><a href="#寄存器文件-x86-64" class="headerlink" title="寄存器文件(x86-64)"></a>寄存器文件(x86-64)</h3><p>16个64位的寄存器，构成了寄存器文件。</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/5948E8CF263182DEE3C28521452B4405.png" width=""></div> <p>16个寄存器文件，但是有64个命名，这是因为字节数量的不同。比如 <code>%rax</code> ，存储 <code>char</code> 类型的变量时只会用到低八位，即 <code>al</code> ，存储 <code>short</code> 类型的变量则需要用到低16位，即 <code>%ax</code> ，而 <code>int</code> 类型的变量需要用到32位，即 <code>%eax</code> 。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>在 x86-64 中存在着栈空间，它存储着临时变量，担任过程调用的中转站，即保留返回地址、参数等。栈遵循先进后出原则(LIFO)。栈空间有一个栈顶指针，也就是十六个寄存器里的 <code>%rsp</code> ，在 x86-64 中，程序栈存放在内存中某个区域，栈向下增长，这样可以使得栈顶元素的地址是所有栈中元素地址最低的。栈指针 <code>%rsp</code> 保存着栈顶元素的地址，如下图</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/4F2CBA99F7FB1F479FC93BC217889736.png" width=""></div> <p>栈有两个操作:</p><ul><li>压入栈(push): 将栈顶指针往下移动若干个字节，使得栈的容量增大，再把新的数据填入栈顶;</li><li>弹出栈(pop): 将栈顶指针上移若干字节，随着栈顶指针的上移，原来的栈顶已经被排除在栈的范围之外。</li></ul><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>PC(Program counter)寄存器，也就是前面说的程序计数器，用 <code>%rip</code> 表示，它并不是通用寄存器的一员，它存储着下一条要执行的指令的地址。此外，PC寄存器并不会显式地出现在汇编代码中，其值的变化都是暗地里进行的。</p><h2 id="汇编语言-AT-amp-T"><a href="#汇编语言-AT-amp-T" class="headerlink" title="汇编语言(AT&amp;T)"></a>汇编语言(AT&amp;T)</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>汇编代码是由多条指令组成的序列，指令序列存在内存里，PC指向下一条指令的地址，一个指令可以完成一个CPU操作。一条指令由<strong>操作码</strong>和 $0\sim 2$ 个<strong>操作数</strong>组成，操作码指定了当前指令要执行的操作，例如两数相加，操作数则是操作码的作用对象。由此可见，指令的长度并不固定。</p><h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>操作数可以是<strong>立即数、寄存器、内存地址</strong>，以下是三种操作数的表示方法</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/9812E8E00347A8E30C20E1A2635EC8D1.png" width=""></div> <p>举例子对上图进行说明:</p><ol><li><code>$5</code> 是立即数，它的值为 5;</li><li><code>%rax</code> 是寄存器，它的值是寄存器 <code>%rax</code> 中的值;</li><li><code>0x07</code> 是内存地址，它的值是内存中地址为 <code>0x07</code> 的某种类型的值;</li><li><code>(%rax)</code> 是内存地址，该地址保留在寄存器 <code>%rax</code> 中;</li><li><code>0xf7(%rax, %rbp, 4)</code> 是内存地址，所有的内存寻址方式都可以写成这种类型。</li></ol><p>最后一种表示一个基址寻址，寻址方式是: <code>displacement(base register, index register, scale factor)</code> ，在上面个例子中:</p><ul><li>displacement(偏移)是 <code>0xf7</code>，即十六进制的偏移值F7</li><li>base register(基址寄存器)是 <code>%rax</code></li><li>index register(索引寄存器)是 <code>%rbp</code></li><li>scale factor(倍数因子)是 4</li></ul><p>也就是说，该表达式表示的内存地址是: <code>0xf7 + (%rax) + 4 * (%rbp)</code></p><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>操作码分为<strong>算数逻辑类、数据传输类、控制类</strong>等。</p><ol><li>算术和逻辑指令操作码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq $<span class="number">3</span>, %rdi</span><br></pre></td></tr></table></figure><code>add</code> 表示相加，第一个操作数是源操作数，第二个操作数是目标操作数，表示将立即数 3 加到寄存器 <code>%rdi</code> 中。而 <code>add</code> 的后缀表示操作数的大小，分别为:</li></ol><ul><li><code>b</code> —— 字节(byte, 8bit);</li><li><code>w</code> —— 字(word, 16bit);</li><li><code>l</code> —— 双字(doubleword, 32bit);</li><li><code>q</code> —— 四字(quadword, 64bit)</li></ul><p>算数和逻辑类指令操作码被分为四组: <strong>加载有效地址、一元操作、二元操作和移位</strong>，二元操作有两个操作数，而一元操作有一个操作数。如下图所示</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/E1D9A89ED6FD8CBE5E3D5B4CD9FFCAF7.png" width=""></div> <ol><li>数据传输指令操作码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movb %bl, %al</span><br></pre></td></tr></table></figure>将 <code>%bl</code> 寄存器中的值赋给<code>%al</code> 寄存器。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp</span><br></pre></td></tr></table></figure><p>表示将 <code>%rbp</code> 的值压入栈中，即先使栈顶指针寄存器<code>%rsp</code>的值减少8个字节，再将<code>%rbp</code>的值赋值给<code>%rsp</code>所指的内存单元。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popq %rsi</span><br></pre></td></tr></table></figure><p>将栈顶的8个字节的值弹出，并赋给 <code>%rsi</code></p><p>除此之外，还有诸如控制类、比较和测试类操作码。</p><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU还维护了一组单个位的条件码(condition code)寄存器，它们<br>描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用<br>的条件码有:</p><ul><li><code>CF</code> : 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出;</li><li><code>ZF</code> : 零标志。最近的操作得出的结果为 0;</li><li><code>SF</code> : 符号标志。最近的操作得到的结果为负数;</li><li><code>OF</code> : 溢出标志。最近的操作导致一个补码溢出正溢出或负溢出。</li></ul><p>比如说，当使用一条 <code>add</code> 指令来完成等价于 C 表达式 <code>t = a + b</code> 的功能后，这里的变量都是整型的。然后由下面的 C 表达式来设置条件码</p><ul><li>CF —— (unsigned) t &lt; (unsigned) a —— 无符号溢出</li><li>ZF —— (t == 0) —— 零</li><li>SF —— (t &lt; 0) —— 负数</li><li>OF —— (a &lt; 0 == b &lt; 0) &amp;&amp; (t &lt; 0 != a &lt; 0) —— 有符号溢出</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>准备一个 <code>test.c</code> 文件，写入如下代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>gcc -Og -S test.c</code> 命令可以得到 *.s 的汇编语言文件，加入 <code>-Og</code> 的目的是使得到的汇编代码与源代码尽可能的对应。更好的办法是:</p><p>首先编译源代码得到目标文件test.o<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -Og test.c</span><br></pre></td></tr></table></figure></p><p>然后用反汇编命令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d test.o</span><br></pre></td></tr></table></figure></p><p>得到如下:</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/521877CBD05A3E6B85EAAA99A1A59C92.png" width=""></div> <p>首先 <code>0000000000000000 &lt;main&gt;</code> ，前面的 16 个 0 是十六进制下的 0，也就是二进制下的 64 个 0, 表示该函数所在的虚拟地址，而 <code>&lt;main&gt;</code> 则是函数名。接下来是函数体，0、4、8、f…是各指令的地址，也是十六进制，因为第一条指令有4个字节(f3、0f、1e、fa)所以第二条指令的地址和第一条指令地址相差 4。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;历史上出现过很多知名的指令集架构，比如Alpha， SPARC，PowerPC，MIPS等，而在今天最流行的则是x86(-64)，ARM，RISC-V。这一章以x86-64为重点。&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&quot;https://raw.gi</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="https://wxliu925.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-信息的表示和处理</title>
    <link href="https://wxliu925.github.io/2023/10/26/CSAPP-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://wxliu925.github.io/2023/10/26/CSAPP-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</id>
    <published>2023-10-26T09:00:11.000Z</published>
    <updated>2023-11-07T03:34:18.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人总是对记忆有一种放不下的假清高，渴望在过去里找一点存在感，却因此而陷入更深的纠结。这并不能减少人的迷茫彷徨，反而会加剧内心的动荡。<br>理解和接受过去的自己，这很重要。同时也要带着乐观派、理想主义和克制活着。<br>—— 2023.10.31记。</p></blockquote><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/Fq8hp.png" width=""></div><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>大多数计算机使用 8 位的块，或者字节作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存(virtual memory)</strong>。内存的每个字节都由一个唯一的数字来标识，称为它的<strong>地址(address)</strong>，所有可能地址的集合就称为<strong>虚拟地址空间(virtual address space)</strong>。</p><ul><li>无符号编码基于传统的二进制表示法，表示大于或者等于零的数字;</li><li><strong>补码(two’s-complement)</strong> 编码是表示有符号整数的最常见的方式;</li><li><strong>移码(增码)</strong> 是符号位取反的补码，一般用指数的移码减去1来做浮点数的阶码，引入的目的是为了保证浮点数的机器零为全0;</li><li><strong>原码(true form)</strong> 是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位(即最高位为符号位):正数该位为0，负数该位为1(0有两种表示:+0和-0)，其余位表示数值的大小;</li><li><strong>浮点数(floating-point)</strong> 编码是表示实数的科学计数法的以2为基数的版本。</li></ul><h3 id="十六进制-hex"><a href="#十六进制-hex" class="headerlink" title="十六进制(hex)"></a>十六进制(hex)</h3><p>使用 $0\sim 9$ 和 $A\sim F$ 来表示 <code>0000</code> 到 <code>1111</code> ，在 C 语言中，以 <code>0x</code> 或 <code>0X</code> 开头的数字常量通常被认为是十六进制的值，字符 $A\sim F$ 可以是大写也可以是小写，也可以大小写混合。将一个二进制的数转换为十六进制需要将该数划分为每4个为一组，如果不是4的倍数则在最左边补0 </p><p>而十进制转换为十六进制的话，可以使用辗转相除法，即不断除以16得到余数，再从下往上取。例如</p><script type="math/tex; mode=display">\begin{align*}314156 &= 19634 \times 16 + 12 \tag{C}\\19634 &= 1227\times 16+2 \tag{2}\\1227 &= 76\times 16+11 \tag{B}\\76 &= 4\times 16 + 12 \tag{C}\\4 &= 0\times 16 + 4 \tag{4}\end{align*}</script><p>所以 314156 的十六进制表示就是 0x4CB2C 。反过来，将16进制转换为10进制只需要不断乘上16的幂次相加即可，例如 $314156 = 4\times 16^4 + 12\times 16^3 + 11\times 16^2 + 2\times 16^1 + 12$ .</p><h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><p>每台计算机都有一个<strong>字长(word size)</strong>，指明指针数据的<strong>标称大小(nominal size)</strong>，字长决定了虚拟地址空间的最大大小: 对于一台字长为 $\omega$ 位的机器，虚拟地址的范围为 $0\sim 2^{\omega}-1$</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/FgDwe.png" width=""></div><h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>基本上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</p><p>排列表示一个对象的字节有两个通用的规则:</p><ul><li><strong>小端法(little ending)</strong>: 最低有效字节在前面的方式(低位放在低地址)</li><li><strong>大端法(big ending)</strong>: 最高有效字节在前面(高位放在低地址)</li></ul><blockquote><p>CSAPP里关于大小端之争记录的一个有趣故事: “ ‘……我下面要告诉你的是， Lilliput 和 Blefuscu 这两大强国在过去 36 个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由 Ble­fuscu 的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有 11000 人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。’(此段译文摘自网上蒋剑锋译的 《 格利佛游记 》 第一卷第 4 章。)<br>在他那个时代，Swift 是在讽刺英国(Lilliput)和法国(Blefuscu)之间持续的冲突。Danny Cohen, 一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序, 后来这个术语被广泛接纳了 。“</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C语言中字符串被编码为一个以 <code>null</code> 字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。</p><h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>位向量是固定长度为 $\omega$ 由 0 和 1 组成的串，位向量的运算可以定义成参数的每个对应元素之间的运算。</p><p>位向量一个很有用的应用就是表示有限集合: 我们可以用位向量 $[a_{\omega-1}, a_{\omega-2}, \cdots, a_0]$ 编码任何子集 $A\in 0, 1, \cdots, \omega-1$ ，其中 $a_i=1$ 当且仅当 $i\in A$ 。</p><ul><li>对于任意整数 $\omega&gt;0$ ，长度为 $\omega$ 的位向量上的布尔运算 <code>|</code>、<code>&amp;</code>、<code>~</code> 形成了一个布尔代数。</li><li>对于任意整数 $\omega&gt;0$ ，长度为 $\omega$ 的位向量上的布尔运算 <code>^</code>、<code>&amp;</code>、<code>~</code> 形成了一个布尔环。</li></ul><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><h3 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h3><p>假设有一个整数数据类型有 $w$ 位，定义向量 $\vec{x}=[x_{w-1},x_{w-2},\cdots,x_0]$ 。那么 $B2U_w$(Binary to Unsigned) 为:</p><script type="math/tex; mode=display">B2U_w(\vec{x}) := \sum_{i=0}^{w-1}x_i2^i</script><p>表示的最大整数值为 $\sum_{i=0}^{w-1}2^i=2^w-1$ 。无符号数和二进制编码一一对应，函数 $B2U_w$ 是一个双射。</p><h3 id="补码编码-two’s-complement"><a href="#补码编码-two’s-complement" class="headerlink" title="补码编码(two’s-complement)"></a>补码编码(two’s-complement)</h3><p>补码是表示有符号数最常见的方式: 将字的最高有效位解释为负权，用函数 $B2T_w$(Binary to Two’s-complement) 来表示。定义向量 $\vec{x}=[x_{w-1},x_{w-2},\cdots,x_0]$ 。那么 $B2T_w$ 为:</p><script type="math/tex; mode=display">B2T_w(\vec{x}):=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i</script><p>补码能表示的范围为: $[-2^{w-1}, 2^{w-1}-1]$ ，补码同样构成一一对应，函数 $B2T_w$ 也是一个双射。</p><h3 id="反码-Ones’Complement-和原码-Sign-Magnitude"><a href="#反码-Ones’Complement-和原码-Sign-Magnitude" class="headerlink" title="反码(Ones’Complement)和原码(Sign-Magnitude)"></a>反码(Ones’Complement)和原码(Sign-Magnitude)</h3><p>除了补码之外，还有反码和原码可以用来表示有符号数。</p><ul><li>反码: 除了最高有效位的权是 $-(2^{w-1}-1)$ 而不是 $-2^{w-1}$，它和补码是一样的<script type="math/tex; mode=display">B2O_w(\vec{x}) := -x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i</script></li><li>原码: 最高有效位是符号位，用来确定剩下的位应该取负权还是正权<script type="math/tex; mode=display">B2S_w(\vec{x}) := (-1)^{x_{w-1}}\times \sum_{i=0}^{w-2}x_i2^i</script><blockquote><p>反码和原码对于 0 都有两种表示方式，对于 +0 两者都表示为 $[00\cdots 0]$ ，而 -0 在原码中表示为 $[10\cdots 0]$ 在反码中表示为 $[11\cdots 1]$</p></blockquote></li></ul><h3 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h3><p>考虑下面这段代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span> <span class="type">short</span>) v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv = %u\n&quot;</span>, v, uv);</span><br></pre></td></tr></table></figure><br>输出: <code>v = -12345, uv = 53191</code> ，其含义是强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p><blockquote><p>C语言中执行一个运算时，它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数来执行运算。例如 <code>-1 &lt; 0u</code> 会返回 false，因为左边的操作数将被隐式地转换为无符号数: $-1\to -1+2^{w}$</p></blockquote><h3 id="扩展一个数的位表示"><a href="#扩展一个数的位表示" class="headerlink" title="扩展一个数的位表示"></a>扩展一个数的位表示</h3><p>即从一个较小的数据类型转换到一个较大的类型同时又保持数值不变。</p><ul><li>要将一个无符号数转换为一个更大的数据类型，只要简单的在表示的开头加0，这种运算被称为<strong>零扩展(zero extension)</strong>;</li><li>要将一个补码转换为更大的数据类型，可以执行一个<strong>符号扩展(sign extension)</strong>，在表示中添加最高有效位的值: <ul><li>将原始位 $\vec{x}=[x_{w-1},x_{w-2},\cdots,x_0]$ 扩展为 $\vec{x}’=[x_{w-1},x_{w-1},\cdots, x_{w-1}, x_{w-2}, \cdots, x_0]$</li></ul></li></ul><p>即 $B2T_{w}(\vec{x}) = B2T_{w’}(\vec{x}’)$ 。要证明这个，其实只需证明扩展1位时成立即可，即要证明 </p><script type="math/tex; mode=display">B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\cdots,x_0])=B2T_{w}([x_{w-1},x_{w-2},\cdots,x_0])</script><p>由于</p><script type="math/tex; mode=display">\begin{align*}B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},\cdots,x_0])&=-x_{w-1}2^w+\sum_{i=0}^{w-1}x_i2^i\\&=-x_{w-1}2^w+x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\&=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\&=B2T_{w}([x_{w-1},x_{w-2},\cdots,x_0])\end{align*}</script><p>这就证得了上结论。</p><p>观察下面的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> sx = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> uy = sx;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;uy = %u\n&quot;</span>, uy);</span><br></pre></td></tr></table></figure><br>在一台大端法机器中输出 <code>uy = 4294954951</code> ，这表明当把 short 转换成 unsigned 时会先改变大小，再完成从有符号到无符号的转换，也就是说 <code>(unsigned) sx</code> 等价于 <code>(unsigned) (int) sx</code></p><h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p>即不用额外的位来扩展一个数值，而是减少表示一个数字的位数。截断一个数字可能会改变它的值，溢出的一种形式。</p><ul><li>截断无符号数: 令 $\vec{x}=[x_{w-1},x_{w-2},\cdots,x_0]$ ，而 $\vec{x}’ = [x_{k-1},x_{k-2},\cdots,x_0]$ 为将 $\vec{x}$ 截断为 $k$ 位的结果，令 $x=B2U_w(\vec{x})$ ，$x’=B2U_k(\vec{x}’)$ ，则 $x’ = x\bmod{2^k}$ 。(直接带入即可证明)</li><li>截断补码数值: 令 $x=B2U_w(\vec{x})$，$x’=B2T_k(\vec{x}’)$ ，则 $x’=U2T_k(x\bmod{2^k})$</li></ul><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>考虑两个非负整数 $x$ 和 $y$ 满足 $0\le x, y&lt; 2^w$ ，表示它们的和可能需要 $w+1$ 位，这样就会造成字节膨胀。</p><p>定义运算 $+^u_w$ ，该运算把整数和 $x+y$ 截断为 $w$ 位得到的结果，再把这个结果看作一个无符号数，即取 $(x+y)\bmod{2^w}$ 。</p><p>检测无符号数加法中的溢出: 对在范围 $0\le x$ ，$y\le UMax_w$ 中的 $x$ 和 $y$ ，令 $s = x +_{w}^{u} y$ , 则对计算 $s$ ，当且仅当 $s&lt;x$ 或者等价地 $s&lt;y$ 时发生了溢出。</p><p>$Proof.$ 首先需要注意到 $x+y\ge s$ ，如果 $s$ 没有发生溢出，则 $s\ge x$ 。另一方面，如果 $s$ 发生了溢出，则有 $s = x+y-2^w=x+(y-2^w)&lt; x$</p><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>对整数 $x$ 和 $y$ 满足 $-2^{w-1}\le x, y\le w^{w-1}-1$ ，定义 $x+_w^t y$ 为整数和 $x+y$ 被截断为 $w$ 位的结果，并将这个结果看作补码数。有:</p><script type="math/tex; mode=display">x+_w^t y = \begin{cases}x+y-2^w, &2^{w-1}\le x+y\\x+y, &-2^{w-1}\le x+y< 2^{w-1}\\x+y+2^w, &x+y<-2^{w-1}\end{cases}</script><p>检测补码加法溢出: 对在范围 $TMin_w\le x$ ，$y\le TMax_w$ 中的 $x$ 和 $y$ ，令 $s = x +_{w}^{t} y$ , 则对计算 $s$ :</p><ul><li>当且仅当 $x&gt;0$ ，$y&gt;0$ 但 $s\le 0$ 时发生了正溢出;</li><li>当且仅当 $x&lt;0$ ，$y&lt;0$ 但 $s\ge 0$ 时发生了负溢出.</li></ul><h3 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h3><p>对满足 $TMin_w\le x\le TMax_w$ 中的 $x$ ，其补码的非 $-^t_w x$ 由下式给出</p><script type="math/tex; mode=display">-^t_w x = \begin{cases}TMin_w , &x=TMin_w\\-x, &x> TMin_w\end{cases}</script><p>也就是说，对 $w$ 位的补码加法来说，$TMin_w$ 是自己的加法的逆，而其他任何数值的 $x$ 都有 $-x$ 作为其加法的逆。</p><p><strong>求补码非的简便方法</strong>:</p><ol><li>对每一位求补(取反)，再对结果+1，也就是 <code>-x</code> 和 <code>~x+1</code> 等价。</li><li>假设 $k$ 是最右边 1 的位置，即将 $x$ 的位级表示为: $[x_{w-1},\cdots, x_{k+1},1,0,\cdots, 0]$ ，然后对 $k$ 左边的所有位取反(01110 $\to$ 10010)</li></ol><h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><p>对整数 $x$ 和 $y$ 满足 $-2^{w-1}\le x, y\le w^{w-1}-1$ ，定义 $x<em>^t_w y$ 为整数和 $x</em>y$ 被截断为 $w$ 位的结果，并将这个结果看作补码数。将一个补码数截断为 $w$ 位相当于先计算该值模上 $2^w$ 再将无符号数转换为补码，即</p><script type="math/tex; mode=display">x*^t_w y = U2T_w((x\times y)\bmod{2^w})</script><blockquote><p>无符号和补码乘法的位级等价。</p></blockquote><h3 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h3><p>对于大多数机器来说整数乘法指令都相当慢，而加法、减法、位级运算和移位等运算很快，因此编译器使用了用移位和加法运算的组合来对乘法指令进行优化。</p><p>首先考虑乘以 2 的幂次，$x\times 2^k$ 只需要将 $x$ 的位级表示左边加 $k$ 个 0 即可。如果是固定字长，则其高 $k$ 位被舍弃，可以发现左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法。而乘一个常数 $C$ 只需要将 $C$ 改写为 2 的幂次的和或者差，例如执行 $x*14$ 编译器会将乘法重写为 $(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)$ 或者更优地改为 $(x&lt;&lt;4)-(x&lt;&lt;1)$</p><h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>整数除法总是舍入到 0，即对于 $x\ge 0, y&gt;0$ ，结果是 $\lfloor\frac{x}{y}\rfloor$ ，而对于 $x\le 0, y&gt;0$ ，结果是 $\lceil \frac{x}{y}\rceil$ 。无符号数的右移一定是逻辑右移。</p><p><strong>除以 2 的幂的无符号除法原理</strong>: C 变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$ ，且 $0\le k<w$ ，则 C 表达式 `x >&gt; k` 产生数值 $\lfloor \frac{x}{2^k}\rfloor$</p><p><strong>除以 2 的幂的补码除法向下舍入原理</strong>: C 变量 $x$ 和 $k$ 有补码值 $x$ 和无符号数值 $k$ ，且 $0\le k<w$ ，则 C 表达式 `x >&gt; k` 产生数值 $\lfloor \frac{x}{2^k}\rfloor$</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p>考虑一个形如 $b_mb_{m-1}\cdots b_1b_0b_{-1}b_{-2}\cdots b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值为 0 或 1 ，这种表示方法定义如下:</p><script type="math/tex; mode=display">b = \sum_{i=-n}^{m} 2^i\times b_i</script><p>二进制小数点向左移动一位相当于这个数除以 2 ，向右移动一位相当于这个数被乘以 2。但是定点表示法不能很有效地表示非常大的数字。</p><ol><li>将二进制小数转换为十进制小数: $110.101_2 = 2^2 + 2^1 + 2^{-1} + 2^{-3} = 6.625$</li><li>将十进制小数转换为二进制小数: 整数部分：除 2 取余数，直到商为 0 ，小数部分：乘 2 取整数，直到小数部分为 0 。比如表示 0.1 :<script type="math/tex; mode=display">\begin{align*}0.1 \times 2 = 0.2 \tag0\\0.2\times 2 = 0.4 \tag0\\0.4\times 2 = 0.8 \tag0\\0.8\times 2 = 1.6 \tag1\\0.6\times 2 = 1.2 \tag1\\0.2\times 2 = 0.4 \tag0\\\cdots\end{align*}</script></li></ol><p>如此就可以将 0.1 表示为 $0.000110…$ ，如此循环，所以需要四舍五入存储到计算机当中，这就造成了误差。除此之外还比如 $0.875=0.111_2$ 。</p><h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>IEEE浮点标准用 $V = (-1)^s\times M\times 2^E$ 的形式来表示一个数:</p><ul><li>符号(sign) $s$ : 决定 $V$ 是整数( $s=0$ ) 还是负数( $s=1$ ) ，而对于数值 0 的符号位解释作为特殊情况处理;</li><li>尾数(significand) $M$ : $M$ 是一个二进制小数，范围是 $1\sim 2-\varepsilon$ 或者 $0\sim 1-\varepsilon$ ;</li><li>阶码(exponent) $E$ : 作用是对浮点数加权，这个权重是 2 的 $E$ 次幂(可能是负数)。将浮点数的位表示划分为 三 个字段，分别对这些值进行编码:<ul><li>一个单独的符号位 $s$ 直接编码符号 $s$ ;</li><li>$\rm{exp}$: 阶码位，以移码形式存储，位数决定数据的范围，用 $\rm{e}$ 表示，其阶码值为 $\rm{E}$ 。$\rm{k}$ 位的阶码字段 $\rm exp =$ $e_{k-1}\cdots e_{1}e_0$ 编码阶码值 $\rm E$ ;</li><li>$\rm frac$ : 尾数位，以原码形式存储，小数部分，其尾数决定小数的精度。$n$ 位小数字段 $\rm frac= $ $f_{n-1}\cdots f_1f_0$ 编码尾数 $M$ ，但是编码出来的值也依赖于阶码字段的值是否等于0。</li></ul></li></ul><p>在单精度浮点格式(C语言中的 <code>float</code> ) 中，$\rm s$、$\rm exp$ 和 $\rm frac$ 的字段分别为 1 位，$k=8$ 位和 $n = 23$ 位，得到一个 32 位的表示。<br>在双精度浮点格式(C语言中的 <code>double</code> ) 中，$\rm s$、$\rm exp$ 和 $\rm frac$ 的字段分别为 1 位，$k=11$ 位和 $n = 52$ 位，得到一个 64 位的表示。</p><p>以一个 32 位的 <code>float</code> 为例，由符号位、指数位和小数位组成，如图所示</p><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/ALnuv.png" width=""></div><ul><li>符号位: 1 位，0 表示正数，1 表示负数;</li><li>指数位: 8/11(float/double) 位表示指数，可以表示 256/2048 种状态;<blockquote><p>因为指数可正可负，在 IEEE 标准里并没有选择用补码来表示负数，而是选择了直接向左平移(又叫<strong>阶码</strong>)，8 位的范围是 $[0, 255]$ ，我们将它向左平移一半(取127)，范围就变成了 $[-127, 128]$ ，也就是说指数位减去127才是真实的指数，比如 12(00001100) 代表 12-127 = -115 。这里减去的数叫<strong>偏移量(biase)</strong>，对单精度来说是127，对双精度来说是1023。</p></blockquote></li><li>小数位: 23/52位，表示底数。显然底数的长度决定了类型的精度，决定了到底能存几位有效数字，而指数位只是表示小数点的位置;</li></ul><p><strong>Q.</strong> 将 $78.625$ 转化为单浮点数形式。</p><p><strong>A.</strong> 首先将 $78.625$ 转化为二进制表示，为 $1001110.101$ ，即 $1.001110101\times 2^6$ 。<br>考虑指数位为 $6+127=133=10000101_2$ ，并将底数的小数点后面添加0补到23位，得到结果为:</p><script type="math/tex; mode=display">\color{red}{0}\color{green}{10000101}\color{blue}{00111010100000000000000}</script><p>IEEE-754浮点转换器: <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a></p><blockquote><p>注意到，由于第一位总是1，所以就不需要显式地表示它，这就获得了一个额外的精度位。</p></blockquote><h3 id="非规约数-amp-正零和负零"><a href="#非规约数-amp-正零和负零" class="headerlink" title="非规约数 &amp; 正零和负零"></a>非规约数 &amp; 正零和负零</h3><p>考虑到指数范围为 $[-127, 128]$ ，也就是说能表示最大精度(<code>0x00000000</code>)为 $\pm2^{-127}$ 。</p><p>为了表示更小的数，在指数位全为0时，丢弃掉最高位为1的束缚，将最高位规定为0,将”全0指数位”规定为-126而不是本来的-127，用于表示绝对值小于 $2^{-126}$ 的数，这样的数就可以叫做<strong>非规约数(denormal number)</strong></p><p>比如 $\color{red}{0}\color{green}{00000000}\color{blue}{00111010100000000000000}$ 表示的数为 $0.001110101\times 2^{-126}=1.110101\times 2^{-129}$ ，这样就可以表示 $\pm 2^{-126-23} = \pm2^{-149}$ 。</p><p>而对于 0 的表示，因为符号位可以取1和0,即对应于负零和整零，在高级应用层面对于正零和负零的判定各不相同，C++中负零和整零相等，并且布尔值都对应于 <code>false</code> ，在运算过程一个理论答案为零的结果既可能被计算为正零，也可能被计算为负零。</p><h3 id="逐渐溢出"><a href="#逐渐溢出" class="headerlink" title="逐渐溢出"></a>逐渐溢出</h3><p>规格数的最小值为 $0(00000001)0\cdots 0_2 = 2^{-126}$<br>非规格数的最大值为 $0(00000000)1\cdots 1_2 = (1-2^{-23})2^{-126}$ ，基本可以看做 $2^{-126}$ 的开区间，从非规格数过渡到规格数时，相当于指数 $-126$ 不变，底数进位到隐藏的高位。从而实现了平稳的值域过渡，刚好覆盖了实数轴，这种特性叫做<strong>逐渐溢出(gradual overflow)</strong></p><p>而这也是前面非规约数使阶码值为 $1-\rm Bias$ 而不是 $-\rm Bias$ 的原因。</p><p>当二进制码从 <code>0x00000000</code> 不断递增时，它表示的浮点数值也是逐渐递增的。这对于非规约数到规约数来说表现为”逐渐溢出”，而对于规约数来说，小数部分不全为1的时候显然; 而当小数部分全为1的时候，再下一个数是小数位清零，指数位加1。<br>例如 $0(0..01)11..11$ 对应浮点数的下一个是 $0(0..10)00..00$ ，而 $0(0..01)11..11$ 对应整数的下一个也是 $0(0..10)00..00$ 。根据这个特性，可以像整数一样对浮点数进行基数排序。</p><h3 id="无穷-inf"><a href="#无穷-inf" class="headerlink" title="无穷(inf)"></a>无穷(inf)</h3><p>用指数位全为1的状态表示无穷，根据符号位的不同有正无穷和负无穷之分。无穷支持一些数学意义上的运算:</p><ul><li>同号无穷被认为相等，正无穷 &gt; 所有规约数 &gt; 负无穷</li><li>无穷与规约数进行四则运算仍是无穷</li></ul><p>C++ 中可以使用 <code>1/0.0</code> 或者 <code>1e1000</code> 等赋值来得到一个无穷，他们都是一样的无穷，本质上是表示”超过存储范围”。输出 <code>inf</code> 或者 <code>-inf</code> 。</p><h3 id="非数值-NaN"><a href="#非数值-NaN" class="headerlink" title="非数值(NaN)"></a>非数值(NaN)</h3><p>非数值与无穷一样使用全为1的指数位表示，为了区分开来，小数位全为0时表示无穷，其他所有情况表示非数值情况。</p><h3 id="浮点数的范围和精度"><a href="#浮点数的范围和精度" class="headerlink" title="浮点数的范围和精度"></a>浮点数的范围和精度</h3><div align=center><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/AIb4d.png" width=""></div><p>对于32位规约数来说，指数位包括 $[-127, 128]$ ，但是由于左右端点表示其他值，所以实际指数位为 $[-126,127]$ 。</p><p><strong>范围:</strong> 考虑正数，前面计算过最小的规约数为 $2^{-126}$ ，而最大的规约数为 $0(11111110)1…1_2 \approx 2^{128}$ ，所以极限范围就是 $[2^{-126}, 2^{128})$ ，转换为十进制就大约是 $[1.175\times 10^{-38}, 3.403\times 10^{38}]$ 。如果算上非规约数，那下界可以达到 $2^{-149}\approx 1.401\times 10^{-45}$ 。</p><p><strong>精度:</strong> 精度即底数有效数字的位数，底数有23位，而换算成十进制下就大约是7位小数，双精度的话就是大约15位。   </p><h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算，因此，对于值 $x$，我们使用一种系统的方法，能够找到最接近的匹配值 $x’$，它可以用期望的浮点形式表示出来，这就是舍入运算的任务。</p><p>IEEE浮点格式定义了四种不同的舍入方式，默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。</p><ul><li>向偶数舍入: 它将数字向上或者向下舍入，使得结果的最低的有效数字是偶数。</li><li>向零舍入：把正数向下舍入，把负数向上舍入。</li><li>向下舍入：把正数和负数都向下舍入。</li><li>向上舍入：把正数和负数都向上舍入。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;人总是对记忆有一种放不下的假清高，渴望在过去里找一点存在感，却因此而陷入更深的纠结。这并不能减少人的迷茫彷徨，反而会加剧内心的动荡。&lt;br&gt;理解和接受过去的自己，这很重要。同时也要带着乐观派、理想主义和克制活着。&lt;br&gt;—— 2023.10.31记</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="https://wxliu925.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>机器学习与模式识别:手写数字识别</title>
    <link href="https://wxliu925.github.io/2023/10/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>https://wxliu925.github.io/2023/10/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2023-10-26T04:50:58.000Z</published>
    <updated>2023-11-07T03:34:59.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>数据集选择</li><li>Bayes判别分类</li><li>Fisher 线性判别</li><li>SVM的线性与非线性分类</li><li>不同分类器之间的比较</li></ol><blockquote><p>原始数据集上传至网盘: <a href="https://pan.baidu.com/s/1uqmJg7EGxpKR62j-Qbr1ow?pwd=jjrc">https://pan.baidu.com/s/1uqmJg7EGxpKR62j-Qbr1ow?pwd=jjrc</a></p></blockquote><h2 id="实验数据特征提取方法"><a href="#实验数据特征提取方法" class="headerlink" title="实验数据特征提取方法"></a>实验数据特征提取方法</h2><p>手写数字样本。每个数字有 $50$ 张图片，选择其中 $40$ 个作为训练集，$10$ 个作为测试集。</p><p>首先将含有全部特征信息的手写数字图像从坐标轴中提取出来，将提取出来的书写数字图像进行二值化处理; 将处理后的每个数字图像提取 $5\times 5$ 块模板，每个模块中 1 值像素点与总像素点的比值就是这个模块的特征值。将所有特征值放入 $5\times 5$ 的矩阵。设定阈值 $T = 0.05$，每块内所对应的元素白像素占有率大于 $T$ ，则该块特征取1;否则取0。</p><p>选择minst手写数字数据集，因为图片尺寸为 $28\times 28$ 不为5的倍数，使用中心裁剪法将图像裁剪为25x25的大小再进行分块操作与特征提取。</p><p>数据处理(特征提取) <code>dataset.m</code> 代码如下:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 数据集处理</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[train_X, train_Y, test_X, test_Y]</span> = <span class="title">load_datasets</span><span class="params">(train_pc)</span></span></span><br><span class="line">    <span class="comment">% 参数设置</span></span><br><span class="line">    T = <span class="number">0.05</span>;</span><br><span class="line">    kernelSize = <span class="number">5</span>;</span><br><span class="line">    imgSize = <span class="number">28</span>;</span><br><span class="line">    sub_counts = <span class="built_in">floor</span>(imgSize / kernelSize);</span><br><span class="line">    newImgSize = kernelSize * sub_counts;</span><br><span class="line">    train_X = [];</span><br><span class="line">    train_Y = [];</span><br><span class="line">    test_X = [];</span><br><span class="line">    test_Y = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> digit = <span class="number">0</span>:<span class="number">9</span></span><br><span class="line">        digitFolderPath = fullfile(<span class="string">&#x27;./mnist&#x27;</span>, num2str(digit));</span><br><span class="line">        imageFiles = dir(fullfile(digitFolderPath, <span class="string">&#x27;*.png&#x27;</span>));</span><br><span class="line">        <span class="comment">% 读取当前数字的所有图像数据</span></span><br><span class="line">        images = <span class="built_in">length</span>(imageFiles);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:images</span><br><span class="line">            imgPath = fullfile(digitFolderPath, imageFiles(<span class="built_in">i</span>).name);</span><br><span class="line">            <span class="comment">% 读取图像</span></span><br><span class="line">            img = double(imread(imgPath)); </span><br><span class="line">            <span class="comment">% 中心裁剪图像</span></span><br><span class="line">            croppedImg = centerCropImage(img, newImgSize);</span><br><span class="line">            <span class="comment">% 提取图像特征</span></span><br><span class="line">            features = getFeatures(croppedImg, kernelSize, T);</span><br><span class="line">            <span class="comment">%features = img(:);</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">i</span> &lt;= images * train_pc</span><br><span class="line">                <span class="comment">% 划分为训练集</span></span><br><span class="line">                train_X = [train_X; features&#x27;];</span><br><span class="line">                train_Y = [train_Y; digit];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">% 划分为测试集</span></span><br><span class="line">                test_X = [test_X; features&#x27;];</span><br><span class="line">                test_Y = [test_Y; digit];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">croppedImg</span> = <span class="title">centerCropImage</span><span class="params">(img, newImgSize)</span></span></span><br><span class="line">        [rows, cols] = <span class="built_in">size</span>(img);</span><br><span class="line">        startRow = <span class="built_in">floor</span>((rows - newImgSize) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        startCol = <span class="built_in">floor</span>((cols - newImgSize) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        croppedImg = img(startRow:startRow + newImgSize - <span class="number">1</span>, startCol:startCol + newImgSize - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">features</span> = <span class="title">getFeatures</span><span class="params">(img, kernelSize, T)</span></span></span><br><span class="line">        [rows, cols] = <span class="built_in">size</span>(img);</span><br><span class="line">        <span class="comment">% 计算分块数目</span></span><br><span class="line">        numBlocksRow = <span class="built_in">round</span>(rows / kernelSize);</span><br><span class="line">        numBlocksCol = <span class="built_in">round</span>(cols / kernelSize);</span><br><span class="line">        <span class="comment">% 初始化特征向量</span></span><br><span class="line">        features = <span class="built_in">zeros</span>(<span class="number">1</span>, numBlocksRow * numBlocksCol);</span><br><span class="line">    </span><br><span class="line">        blockIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:numBlocksRow</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:numBlocksCol</span><br><span class="line">                <span class="comment">% 计算分块的起始和结束位置</span></span><br><span class="line">                startRow = (<span class="built_in">i</span> - <span class="number">1</span>) * kernelSize + <span class="number">1</span>;</span><br><span class="line">                endRow = <span class="built_in">i</span> * kernelSize;</span><br><span class="line">                startCol = (<span class="built_in">j</span> - <span class="number">1</span>) * kernelSize + <span class="number">1</span>;</span><br><span class="line">                endCol = <span class="built_in">j</span> * kernelSize;</span><br><span class="line">                <span class="comment">% 计算分块的总像素数</span></span><br><span class="line">                totalPixels = kernelSize * kernelSize;</span><br><span class="line">                <span class="comment">% 计算分块内白像素的个数</span></span><br><span class="line">                whitePixels = sum(sum(img(startRow:endRow, startCol:endCol) &gt;= <span class="number">250</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">% 根据阈值T判断特征取值</span></span><br><span class="line">                <span class="keyword">if</span> whitePixels / totalPixels &gt; T</span><br><span class="line">                    features(blockIndex) = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    features(blockIndex) = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                blockIndex = blockIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        features = features&#x27;;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="朴素Bayes判别分类"><a href="#朴素Bayes判别分类" class="headerlink" title="朴素Bayes判别分类"></a>朴素Bayes判别分类</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>设 $B_i$ 表示事件: 图片为数字 $i$ ，则由 Bayes 公式有</p><script type="math/tex; mode=display">\begin{align*}P(B_i|A) = \frac{P(A|B_i)P(B_i)}{\sum_{j=0}^{9} P(A|B_j)P(B_j)} \end{align*}</script><p>其中，$P(B_i)$ 在这里是先验概率，在这里等于 0.1。$P(B_i|A)$ 是后验概率，在这里是对于一张手写数字图片(事件 $A$)上的数字是 $d$ ($0\sim 9$ 对应事件 $B_0\sim B_9$)的概率，由于这里是设计基于最小错误率的贝叶斯分类器，故而认为该数字为后验概率最大的数字。</p><p>令 $\mathbf{X}$ 表示图片集合，$\mathbf{Y}$ 表示标签集合，则训练数据集可以表示为:</p><script type="math/tex; mode=display">\mathbf{T} = \{(\bar{x}_1, y_1), (\bar{x}_2,y_2),\cdots, (\bar{x}_n,y_n)\}</script><p>其中，$\bar{x}_1,\cdots,\bar{x}_n\in \mathbf{X}$ , $y_1,\cdots,y_n\in \mathbf{Y}$ ，对于任意的 $\bar{x}_i$ 有 $\bar{x}_i = \{x_i^1, x_i^2, \cdots, x_i^m\}$ 意为第 $i$ 张图片的 $m$ 个特征。</p><p>对于训练数据集 $P(X,Y)$ 独立同分布，所以有</p><script type="math/tex; mode=display">P(X|Y) = \frac{P(X,Y)}{P(Y)}</script><p>又有先验概率 $P(Y = c_k) = 0.1$ , $k=0,1,\cdots,9$ , 而条件概率</p><script type="math/tex; mode=display">P(X=x|Y=c_k) = P(X^1=x^1,X^2=x^2,\cdots,X^m=x^m|Y=c_k)</script><p>又因为这里数据的条件概率分布是特征条件独立，所以进一步地可以表示为</p><script type="math/tex; mode=display">P(X=x|Y=c_k) = \prod_{j=1}^m P(X^j=x^j|Y=c_k)</script><blockquote><p>在这里问题里的实际含义是: 对于测试集的任意一张 $28\times 28$ 大小的手写数字图片，最后得到 25 个特征，每一个特征对应于每一个模块的取值。在朴素贝叶斯的假设条件下，这张图片是 1 的概率就是每一个特征都是 1 的特征的概率的累乘。</p></blockquote><p>进一步得到后验概率的计算公式:</p><script type="math/tex; mode=display">P(Y=c_k|X=x) = \frac{P(Y=c_k)\prod_j^m P(X^j=x^j|Y=c_k)}{\sum_kP(Y=c_k)\prod_j^m P(X^j=x^j|Y=c_k)}</script><p>因为是要取最大值，所以可以去掉公分母，得到朴素贝叶斯分类器的判别式</p><script type="math/tex; mode=display">y = f(x) = \max_{c_k} P(Y=c_k)\prod_j P(X^j=x^j|Y=c_k)</script><p>对每一个实验样本，选取前 40 个作为训练集，后 10 个作为测试集。</p><p>编写代码 <code>bayesClassifier.m</code><br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 贝叶斯判别代码</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line">clc, clear;</span><br><span class="line"><span class="comment">% 重新加载数据</span></span><br><span class="line">load(<span class="string">&#x27;datasets.mat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% v = mnistData&#123;8&#125;&#123;1, 2&#125;;</span></span><br><span class="line"><span class="comment">% A = reshape(v, 5, 5)&#x27;;</span></span><br><span class="line"><span class="comment">% disp(A);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 从每个类别中选择40个样本作为训练集，10个样本作为测试集</span></span><br><span class="line">train_samples = cell(<span class="number">10</span>, <span class="number">40</span>);</span><br><span class="line">test_samples = cell(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">error_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> digit = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    <span class="comment">% 从当前类别中随机选择40个样本作为训练集</span></span><br><span class="line">    all_samples = mnistData&#123;digit&#125;;</span><br><span class="line"><span class="comment">%     random_indices = randperm(length(all_samples), 40);</span></span><br><span class="line"><span class="comment">%     % disp(random_indices);</span></span><br><span class="line"><span class="comment">%     train_samples&#123;digit&#125; = all_samples(random_indices, :);</span></span><br><span class="line">    </span><br><span class="line">    train_samples&#123;digit&#125; = all_samples(<span class="number">1</span>:<span class="number">40</span>, :);</span><br><span class="line">    <span class="comment">% 剩余的10个样本作为测试集</span></span><br><span class="line"><span class="comment">%     test_indices = setdiff(1:length(all_samples), random_indices);</span></span><br><span class="line"><span class="comment">%     test_samples&#123;digit&#125; = all_samples(test_indices, :);</span></span><br><span class="line">    test_samples&#123;digit&#125; = all_samples(<span class="number">41</span>:<span class="number">50</span>, :);</span><br><span class="line">    <span class="comment">%(test_indices);</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 重新计算先验概率和类条件概率</span></span><br><span class="line">num_classes = <span class="number">10</span>; <span class="comment">% 数字类别数量</span></span><br><span class="line">num_features = <span class="number">25</span>; <span class="comment">% 特征数量</span></span><br><span class="line">num_train = <span class="number">40</span>; <span class="comment">% 训练样本的数量</span></span><br><span class="line">num_test = <span class="number">10</span>; <span class="comment">% 测试样本的数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">true</span>_positives = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 正类别被正确分类的样本数量</span></span><br><span class="line"><span class="built_in">false</span>_positives = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 负类别被错误分类成正类别的样本数量</span></span><br><span class="line"><span class="built_in">false</span>_negatives = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 正类别被错误分类成负类别的样本数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> y = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">        <span class="comment">% 获取第i个测试样本的特征向量</span></span><br><span class="line">        test_sample = test_samples&#123;x&#125;&#123;y, <span class="number">2</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        prior_prob = <span class="built_in">zeros</span>(<span class="number">1</span>, num_classes); <span class="comment">% 先验概率</span></span><br><span class="line">        class_cond_prob = <span class="built_in">zeros</span>(num_features, num_classes); <span class="comment">% 类条件概率</span></span><br><span class="line">        pij = []; <span class="comment">% i类的样本第j个特征为1的概率</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_classes</span><br><span class="line">            <span class="comment">% 计算先验概率</span></span><br><span class="line">            prior_prob(<span class="built_in">i</span>) = <span class="number">0.1</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:num_features <span class="comment">% 每个数字图片提取出来的特征数</span></span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> k = <span class="number">1</span>:num_train <span class="comment">% 每个类别下训练样本的个数</span></span><br><span class="line">                    i_feature = train_samples&#123;<span class="built_in">i</span>&#125;&#123;k, <span class="number">2</span>&#125;; <span class="comment">% 获取第k个训练样本的特征向量</span></span><br><span class="line">                    sum = sum + i_feature(<span class="built_in">j</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">% disp(sum);</span></span><br><span class="line">                pij(<span class="built_in">i</span>,<span class="built_in">j</span>) = (sum + <span class="number">1</span>) / (num_train + <span class="number">2</span>); <span class="comment">% 计算概率估计值即Pj(ωi)，注意拉普拉斯平滑处理</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_classes</span><br><span class="line">            multi = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:num_features <span class="comment">% 每个数字图片提取出来的特征数</span></span><br><span class="line">                <span class="keyword">if</span>(test_sample(<span class="built_in">j</span>) == <span class="number">1</span>)</span><br><span class="line">                    multi = multi * pij(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    multi = multi * (<span class="number">1</span> - pij(<span class="built_in">i</span>,<span class="built_in">j</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            class_cond_prob(<span class="built_in">i</span>) = multi;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%计算后验概率</span></span><br><span class="line">        p_class = []; <span class="comment">% 后验概率</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:num_classes<span class="comment">%数字类别个数</span></span><br><span class="line">            sum = sum + prior_prob(<span class="built_in">i</span>) * class_cond_prob(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_classes <span class="comment">% 数字类别个数</span></span><br><span class="line">            p_class(<span class="built_in">i</span>) = prior_prob(<span class="built_in">i</span>) * class_cond_prob(<span class="built_in">i</span>) / sum;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        [maxval, maxpos] = <span class="built_in">max</span>(p_class);</span><br><span class="line">        <span class="keyword">if</span> maxpos == x</span><br><span class="line">            <span class="built_in">true</span>_positives(x) = <span class="built_in">true</span>_positives(x) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error_count = error_count + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">false</span>_positives(maxpos) = <span class="built_in">false</span>_positives(maxpos) + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">false</span>_negatives(x) = <span class="built_in">false</span>_negatives(x) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算准确率（acc）、精确率（precision）、召回率（recall）、F1-score</span></span><br><span class="line">precision = <span class="built_in">true</span>_positives ./ (<span class="built_in">true</span>_positives + <span class="built_in">false</span>_positives);</span><br><span class="line">recall = <span class="built_in">true</span>_positives ./ (<span class="built_in">true</span>_positives + <span class="built_in">false</span>_negatives);</span><br><span class="line">f1_score = <span class="number">2</span> * (precision .* recall) ./ (precision + recall);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算错误率和正确率</span></span><br><span class="line">error_rate = error_count / <span class="number">100</span>;</span><br><span class="line">accuracy = <span class="number">1</span> - error_rate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Accuracy: &#x27;</span>, num2str(accuracy)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Precision: &#x27;</span>, num2str(<span class="built_in">mean</span>(precision))]); <span class="comment">% Changed here</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Recall: &#x27;</span>, num2str(<span class="built_in">mean</span>(recall))]); <span class="comment">% Changed here</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;F1 Score: &#x27;</span>, num2str(<span class="built_in">mean</span>(f1_score))]); <span class="comment">% Changed here</span></span><br></pre></td></tr></table></figure></p><p>得到结果:<br>Accuracy: 0.66<br>Precision: 0.67991<br>Recall: 0.66<br>F1 Score: 0.65476</p><h2 id="Fisher判别分类"><a href="#Fisher判别分类" class="headerlink" title="Fisher判别分类"></a>Fisher判别分类</h2><p>使用 Fisher 线性判别方法求分类器的步骤:</p><ol><li>计算各类的均值向量: $\mu_i = \frac{1}{N_i}\sum_{x\in X_i}x$ ;</li><li>计算各类的类内离散矩阵: $S_{wi} = \sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^T$ ;</li><li>计算类内总离散矩阵: $S_w = S_{w0}+S_{w1}+\cdots$ ;</li><li>计算总离散矩阵的逆矩阵: $S_w^{-1}$ ;</li><li>求出向量 $w^* = S_w^{-1}(\mu_1-\mu_0)$ ;</li><li>判别函数为: $y=(w^*)^Tx$ ;</li><li>求出判别函数的阈值: $w_0 = \frac{(w^*)^T(\mu_0+\mu_1+\cdots)}{2}$ ;</li><li>比较 $y$ 值与阈值的大小得出分类。</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Fisher分类代码</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line">clc,clear;</span><br><span class="line">load(<span class="string">&#x27;datasets.mat&#x27;</span>);</span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line"></span><br><span class="line">numClasses = <span class="number">10</span>; <span class="comment">% 类别数</span></span><br><span class="line">numImages = <span class="number">50</span>; <span class="comment">% 每个类别的图像数</span></span><br><span class="line">numFeatures = <span class="number">25</span>; <span class="comment">% 特征数</span></span><br><span class="line">trainingSize = <span class="number">40</span>; <span class="comment">% 训练集大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建训练集和测试集</span></span><br><span class="line">trainingData = <span class="built_in">zeros</span>(numClasses * trainingSize, numFeatures);</span><br><span class="line">trainingLabels = <span class="built_in">zeros</span>(numClasses * trainingSize, <span class="number">1</span>);</span><br><span class="line">testData = <span class="built_in">zeros</span>(numClasses * (numImages - trainingSize), numFeatures);</span><br><span class="line">testLabels = <span class="built_in">zeros</span>(numClasses * (numImages - trainingSize), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:numClasses</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:numImages</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">j</span> &lt;= trainingSize</span><br><span class="line">            trainingData((<span class="built_in">i</span><span class="number">-1</span>)*trainingSize + <span class="built_in">j</span>, :) = mnistData&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125;&#123;<span class="built_in">j</span>,<span class="number">2</span>&#125;;</span><br><span class="line">            trainingLabels((<span class="built_in">i</span><span class="number">-1</span>)*trainingSize + <span class="built_in">j</span>) = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            testData((<span class="built_in">i</span><span class="number">-1</span>)*(numImages - trainingSize) + <span class="built_in">j</span> - trainingSize, :) = mnistData&#123;<span class="built_in">i</span>,<span class="number">1</span>&#125;&#123;<span class="number">51</span>-<span class="built_in">j</span>,<span class="number">2</span>&#125;;</span><br><span class="line">            testLabels((<span class="built_in">i</span><span class="number">-1</span>)*(numImages - trainingSize) + <span class="built_in">j</span> - trainingSize) = <span class="built_in">i</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Fisher线性判别方法进行训练</span></span><br><span class="line">MdlLinear = fitcdiscr(trainingData, trainingLabels, <span class="string">&#x27;DiscrimType&#x27;</span>, <span class="string">&#x27;pseudoLinear&#x27;</span>);</span><br><span class="line"><span class="comment">% 对测试集进行预测</span></span><br><span class="line"></span><br><span class="line">predictedLabels = predict(MdlLinear, testData);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算错误率</span></span><br><span class="line">errorRate = sum(predictedLabels ~= testLabels) / <span class="built_in">length</span>(testLabels);</span><br><span class="line">fprintf(<span class="string">&#x27;Error Rate: %.2f%%\n&#x27;</span>, errorRate * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line">prior = <span class="built_in">ones</span>(<span class="number">1</span>, numClasses) / numClasses; <span class="comment">% 先验概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Fisher线性判别方法进行训练</span></span><br><span class="line">MdlLinear = fitcdiscr(trainingData, trainingLabels, <span class="string">&#x27;DiscrimType&#x27;</span>, <span class="string">&#x27;pseudoLinear&#x27;</span>, <span class="string">&#x27;Prior&#x27;</span>, prior);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对测试集进行预测</span></span><br><span class="line">predictedLabels = predict(MdlLinear, testData);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算错误率</span></span><br><span class="line">errorRate = sum(predictedLabels ~= testLabels) / <span class="built_in">length</span>(testLabels);</span><br><span class="line">fprintf(<span class="string">&#x27;Error Rate: %.2f%%\n&#x27;</span>, errorRate * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算混淆矩阵</span></span><br><span class="line">C = confusionmat(testLabels, predictedLabels);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算准确率（accuracy）</span></span><br><span class="line">accuracy = sum(<span class="built_in">diag</span>(C)) / sum(C(:));</span><br><span class="line">fprintf(<span class="string">&#x27;Accuracy: %.2f%%\n&#x27;</span>, accuracy * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算精确率（precision）</span></span><br><span class="line">precision = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">2</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;Precision: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(precision) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算召回率（recall）</span></span><br><span class="line">recall = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">1</span>)&#x27;;</span><br><span class="line">fprintf(<span class="string">&#x27;Recall: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(recall) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算F1-score</span></span><br><span class="line">f1score = <span class="number">2</span> * (precision .* recall) ./ (precision + recall);</span><br><span class="line">fprintf(<span class="string">&#x27;F1-score: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(f1score) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="多分类支持向量机"><a href="#多分类支持向量机" class="headerlink" title="多分类支持向量机"></a>多分类支持向量机</h2><h3 id="二分类支持向量机介绍"><a href="#二分类支持向量机介绍" class="headerlink" title="二分类支持向量机介绍"></a>二分类支持向量机介绍</h3><p>对于线性不可分情况引入惩罚因子 $C$ ，于是广义最优分类面问题模型如下:</p><script type="math/tex; mode=display">\max_{a} \sum_{j=1}^N a_j - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N} y_iy_ja_ia_jK(x_i,x_j) , s.t.\sum_{ i=1}^N y_ia_i=0</script><p>其中 $0\le a_i\le C$ 。</p><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>用于训练SVM的特征使用的是图像的完整像素特征，即一张 $28\times 28$ 的图像，它的特征向量的大小为 $1\times 784$ 。将该特征进行标准化处理后即可用于训练SVM。</p><h3 id="ECOC编码与多分类SVM"><a href="#ECOC编码与多分类SVM" class="headerlink" title="ECOC编码与多分类SVM"></a>ECOC编码与多分类SVM</h3><p>ECOC(Error-Correcting Output Codes)编码是一种纠错输出编码用于将多分类任务高效地转换为多个二分类任务。Mnist数据集有0~9个数字共10分类。对应的ECOC编码如下图:</p><p><img src="https://raw.githubusercontent.com/wxLiu925/blog-images/master/FBxr2.png" alt="FBxr2.png"></p><p>代码如下:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 支持向量机代码</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ----------</span></span><br><span class="line"></span><br><span class="line">clc,clear;</span><br><span class="line"></span><br><span class="line">[train_X, train_Y, test_X, test_Y] = load_datasets(<span class="number">0.8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 核函数选择，可选：&#x27;linear&#x27;,&#x27;gaussian&#x27;,&#x27;rbf&#x27;,&#x27;polynomial&#x27;</span></span><br><span class="line">KernelFunction = <span class="string">&#x27;polynomial&#x27;</span>;</span><br><span class="line"><span class="comment">% 惩罚参数C确认</span></span><br><span class="line">C = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">template = templateSVM(...</span><br><span class="line">    <span class="string">&#x27;KernelFunction&#x27;</span>, KernelFunction, ...</span><br><span class="line">    <span class="string">&#x27;PolynomialOrder&#x27;</span>, <span class="number">3</span>, ...</span><br><span class="line">    <span class="string">&#x27;KernelScale&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, ...</span><br><span class="line">    <span class="string">&#x27;BoxConstraint&#x27;</span>, C, ...</span><br><span class="line">    <span class="string">&#x27;Standardize&#x27;</span>, <span class="built_in">true</span>);</span><br><span class="line">svm_model = fitcecoc(...</span><br><span class="line">    train_X, ...</span><br><span class="line">    train_Y, ...</span><br><span class="line">    <span class="string">&#x27;Learners&#x27;</span>, template);</span><br><span class="line"></span><br><span class="line"><span class="comment">% spy(svm_model.BinaryY(1:40:400,:));</span></span><br><span class="line"><span class="comment">% title(&#x27;ECOC编码&#x27;);</span></span><br><span class="line"><span class="comment">% yticks(1:10);</span></span><br><span class="line"><span class="comment">% yticklabels(0:9);</span></span><br><span class="line"><span class="comment">% xlabel(&#x27;分类器数目&#x27;);</span></span><br><span class="line"></span><br><span class="line">predicted_labels = predict(svm_model, test_X);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算混淆矩阵</span></span><br><span class="line">C = confusionmat(test_Y, predicted_labels);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算准确率（accuracy）</span></span><br><span class="line">accuracy = sum(<span class="built_in">diag</span>(C)) / sum(C(:));</span><br><span class="line">fprintf(<span class="string">&#x27;Accuracy: %.2f%%\n&#x27;</span>, accuracy * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算精确率（precision）</span></span><br><span class="line">precision = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">2</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;Precision: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(precision) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算召回率（recall）</span></span><br><span class="line">recall = <span class="built_in">diag</span>(C) ./ sum(C, <span class="number">1</span>)&#x27;;</span><br><span class="line">fprintf(<span class="string">&#x27;Recall: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(recall) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算F1-score</span></span><br><span class="line">f1score = <span class="number">2</span> * (precision .* recall) ./ (precision + recall);</span><br><span class="line">fprintf(<span class="string">&#x27;F1-score: %.2f%%\n&#x27;</span>, <span class="built_in">mean</span>(f1score) * <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><p>下表为使用全部特征进行训练、测试得到的结果。</p><div class="table-container"><table><thead><tr><th style="text-align:center">核函数</th><th style="text-align:center">惩罚参数C</th><th style="text-align:center">准确率(%)</th><th style="text-align:center">精确率(%)</th><th style="text-align:center">召回率(%)</th><th style="text-align:center">F1-score(%)</th></tr></thead><tbody><tr><td style="text-align:center">线性</td><td style="text-align:center">1</td><td style="text-align:center">86.00</td><td style="text-align:center">86.00</td><td style="text-align:center">87.83</td><td style="text-align:center">85.77</td></tr><tr><td style="text-align:center">线性</td><td style="text-align:center">100</td><td style="text-align:center">82.00</td><td style="text-align:center">82.00</td><td style="text-align:center">84.35</td><td style="text-align:center">81.44</td></tr><tr><td style="text-align:center">线性</td><td style="text-align:center">1000</td><td style="text-align:center">82.00</td><td style="text-align:center">82.00</td><td style="text-align:center">84.35</td><td style="text-align:center">81.44</td></tr><tr><td style="text-align:center">高斯</td><td style="text-align:center">1</td><td style="text-align:center">71.00</td><td style="text-align:center">71.00</td><td style="text-align:center">83.30</td><td style="text-align:center">73.64</td></tr><tr><td style="text-align:center">高斯</td><td style="text-align:center">100</td><td style="text-align:center">72.00</td><td style="text-align:center">72.00</td><td style="text-align:center">82.89</td><td style="text-align:center">73.80</td></tr><tr><td style="text-align:center">高斯</td><td style="text-align:center">1000</td><td style="text-align:center">72.00</td><td style="text-align:center">72.00</td><td style="text-align:center">82.89</td><td style="text-align:center">73.80</td></tr><tr><td style="text-align:center">三次多项式</td><td style="text-align:center">1</td><td style="text-align:center">87.00</td><td style="text-align:center">87.00</td><td style="text-align:center">87.18</td><td style="text-align:center">86.58</td></tr><tr><td style="text-align:center">三次多项式</td><td style="text-align:center">100</td><td style="text-align:center">87.00</td><td style="text-align:center">87.00</td><td style="text-align:center">87.18</td><td style="text-align:center">86.58</td></tr><tr><td style="text-align:center">三次多项式</td><td style="text-align:center">1000</td><td style="text-align:center">87.00</td><td style="text-align:center">87.00</td><td style="text-align:center">87.18</td><td style="text-align:center">86.58</td></tr></tbody></table></div><p>由上表得，三次多项式作为核函数效果最佳，且乘法参数C取值对评估结果没有影响。但如果选取原始特征提取方法(图像被分为5x5个块，一共提取了25个特征)，准确率将有所下降，仅能达到 60% 左右。</p><h2 id="各分类器间的比较"><a href="#各分类器间的比较" class="headerlink" title="各分类器间的比较"></a>各分类器间的比较</h2><p>无论是贝叶斯判别还是Fisher分类，两者改为多分类方法比较容易。SVM是一个性能很好的二分类算法，然而在进行多分类任务时需要多个SVM才能进行，这导致SVM在多分类任务中的准确率下降。本次实验如果全部使用提取特征后的数据来训练模型，Fisher判别表现最好，准确率在74%；其次是贝叶斯判别，准确率在66%. SVM分类效果最差，准确率为61%.</p><p>总的来说，分类算法的选择更多取决于数据集。如果数据集规模较大，且基本线性可分，使用贝叶斯或是Fisher判别效率更高，反之应使用SVM处理更加复杂的非线性分类任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;数据集选择&lt;/li&gt;
&lt;li&gt;Bayes判别分类&lt;/li&gt;
&lt;li&gt;Fisher 线性判别&lt;/li&gt;
&lt;li&gt;S</summary>
      
    
    
    
    
    <category term="Bayes" scheme="https://wxliu925.github.io/tags/Bayes/"/>
    
    <category term="Fisher" scheme="https://wxliu925.github.io/tags/Fisher/"/>
    
    <category term="SVM" scheme="https://wxliu925.github.io/tags/SVM/"/>
    
    <category term="matlab" scheme="https://wxliu925.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>C++面经Part1</title>
    <link href="https://wxliu925.github.io/2023/10/25/C-%E9%9D%A2%E7%BB%8FPart1/"/>
    <id>https://wxliu925.github.io/2023/10/25/C-%E9%9D%A2%E7%BB%8FPart1/</id>
    <published>2023-10-25T06:26:07.000Z</published>
    <updated>2023-11-03T11:35:07.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>主要有以下作用:</p><ol><li>修饰变量，说明该变量不可改变;</li><li>修饰指针，这里分为<strong>指向常量的指针(指针常量，pointer to const)</strong>和<strong>自身是常量的指针(常量指针，const pointer)</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;a; <span class="comment">// 指针常量，指向的值不可以使用*p修改，*p = 10 错误，可以修改指向的地址</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p2 = &amp;a; <span class="comment">// 常量指针，指针指向的地址不可改变，p2 = &amp;b 错误，可以修改该地址的变量值</span></span><br></pre></td></tr></table></figure></li><li>修饰引用，指向常量的引用，用于形参类型，既避免了拷贝，又避免了函数对值进行修改</li><li>类内修饰成员函数，说明该成员函数内不能修改成员变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x) &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一个普通函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 常成员函数，不得修改类中任何数据的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一个常函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj1;</span><br><span class="line">    <span class="type">const</span> A obj2;</span><br><span class="line">    obj1.<span class="built_in">func</span>(); <span class="comment">// &quot;这是一个普通函数&quot;</span></span><br><span class="line">    obj2.<span class="built_in">func</span>(); <span class="comment">// &quot;这是一个常函数&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，普通对象可以调用普通函数也可以调用常函数，前者优先，如果是常量对象的话，只能调用常函数，如果调用普通函数会导致报错。</p><p>进一步地<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">(<span class="type">char</span>* <span class="type">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function4</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"><span class="comment">// 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="type">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>主要有以下作用:</p><ol><li><strong>修饰普通变量:</strong> 修改变量的存储区域和生命周期，使变量存储在静态区域，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。需要注意的是: 在函数内部定义了一个静态变量，生命周期到程序结束，但是这个变量的作用域仅限于声明它的函数内部。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myFunction</span>(); <span class="comment">// 输出 Count: 1</span></span><br><span class="line">    <span class="built_in">myFunction</span>(); <span class="comment">// 输出 Count: 2</span></span><br><span class="line">    <span class="comment">// 这里无法直接访问 count</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>修饰普通函数:</strong> 表明函数的作用范围，仅在定义该函数的文件内才能使用，它的作用域被限制在声明它的文件中，即它变成了一个“内部链接”的函数，只能在当前文件内部访问。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;这是一个静态函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// File2.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myFunction</span>(); <span class="comment">// 错误，无法访问静态函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>修饰成员变量:</strong> 修饰成员变量时该变量将被所有该类的对象共享，而不是每个对象拥有一份副本，而且不需要生成对象就可以访问该成员。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 静态成员变量的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line"></span><br><span class="line">    obj1.count = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; obj2.count &lt;&lt; std::endl; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>修饰成员函数:</strong> 修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内只能访问 static 成员。</li></ol><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p><code>this</code> 指针是一个特殊的指针，它指向当前对象的地址。在 C++ 中，每个类的非静态成员函数都有一个隐含的 <code>this</code> 指针，它指向调用该成员函数的对象。</p><p>当一个类对象调用成员函数时，编译程序先将对象的地址赋给了 <code>this</code> 指针，然后调用该成员函数，每次成员函数存取数据成员时，都其实是在隐式地使用 <code>this</code> 指针。</p><p><code>this</code> 指针是一个常量指针，被隐含地声明为: <code>ClassName *const this</code> ，这意味着不能给 <code>this</code> 指针赋值，而在 <code>const</code> 成员函数里被声明为 <code>const ClassName* const</code></p><p>最后还需要注意的是，<code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址(不能 <code>&amp;this</code>)</p><h3 id="左值和右值-引用"><a href="#左值和右值-引用" class="headerlink" title="左值和右值(引用)"></a>左值和右值(引用)</h3><ol><li>左值(lvalue)</li></ol><ul><li>左值既能够出现在等号左边，也能出现在等号右边</li><li>左值可以被赋值，可以作为赋值语句的目标</li><li>左值是可寻址的变量，有持久性</li><li>具体来说，变量、对象或者通过解引用获得的指针都属于左值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// x 是左值，因为它代表一个内存位置，可以被赋值</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;x; <span class="comment">// &amp;x 是左值，因为它是变量 x 的地址</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>右值(rvalue)</li></ol><ul><li>右值是不能被赋值的表达式，它们代表的是一个数值或者临时值，通常在赋值语句的右侧</li><li>右值可以是一个常数、一个临时的计算结果或者一个表达式的返回值。</li><li>右值在使用后就失去意义，因此不能被取地址<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>; <span class="comment">// 10 是右值，因为它代表一个数值，不能被赋值</span></span><br><span class="line"><span class="type">int</span> z = x + y; <span class="comment">// x + y 是右值，因为它代表一个临时计算结果</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>C++ Primer:” 当一个对象被用作右值的时候，用的是对象的值(内容);当对象被用作左值时，用的是对象的身份(在内存中的位置)”</p></blockquote><p>左值引用(lvalue reference)和右值引用(rvalue reference)是C++中引入的两种不同类型的引用。</p><ol><li><strong>左值引用:</strong> 左值引用是最常见的引用类型。它们使用 <code>&amp;</code> 符号声明，并且只能绑定到左值(可以取地址的表达式)。</li><li><strong>右值引用:</strong> 右值引用是在C++11中引入的新特性，用 &amp;&amp; 符号表示。它们可以绑定到临时值、表达式结果或具有名称的右值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">6</span>; <span class="comment">// x是左值，6是右值</span></span><br><span class="line"><span class="type">int</span> &amp;y = x; <span class="comment">// 左值引用，y引用x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;z1 = x * <span class="number">6</span>; <span class="comment">// 错误，x*6是一个右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;z2 = x * <span class="number">6</span>; <span class="comment">// 正确，右值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;z3 = x; <span class="comment">// 错误，x是一个左值</span></span><br></pre></td></tr></table></figure><blockquote><p>可以引用右值的除了右值引用外还有 const 左值引用，例如 <code>const int &amp;z4 =  x * 6;</code> 正确，可以将一个const引用绑定到一个右值。例如 <code>std::vector</code> 的 <code>push_back</code> 函数就使用了 const 左值引用(<code>void push_back (const value_type&amp; val);</code>) ，这样能让我们使用 <code>v.push_back(1)</code> 这样的代码。</p></blockquote></li></ol><p><code>std::move</code> 可以实现将左值转换成右值以实现对左值进行右值引用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j;</span><br><span class="line">j = std::<span class="built_in">move</span>(<span class="number">2</span>); <span class="comment">// 合法，从一个右值移动数据</span></span><br><span class="line">j = std::<span class="built_in">move</span>(i); <span class="comment">// 合法，从一个左值移动数据，i的值之后是不确定的。</span></span><br></pre></td></tr></table></figure></p><h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><p>主要有以下特征:</p><ul><li>相当于把内联函数里面的内容写在调用内联函数处;</li><li>相当于不用执行进入函数的步骤，直接执行函数体;</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性;</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数;</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在类内定义的成员函数会隐式成为inline，而在类外定义的成员函数不会(当然是否内联完全取决于编译器)</span></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure><p>虚函数可以是内联函数吗？<br><a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics#:~:text=Therefore%20the%20only%20time%20an,or%20reference%20to%20an%20object.">Standard C++: Are “inline virtual” member functions ever actually “inlined”?</a><br><a href="https://stackoverflow.com/questions/18432040/can-virtual-functions-be-inlined">Stackoverflow: Can virtual functions be inlined [duplicate]</a></p><p>虚函数可以是内联函数，但是当虚函数表现出多态性的时候不能内联，因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性的时候不可以内联。</p><p>下面是虚函数内联使用例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// // 不写 inline 时会隐式内联</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base fa;</span><br><span class="line">    fa.<span class="built_in">who</span>(); <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体来说，就是</p><ol><li>当使用类的对象来调用时，则虚函数可以当做是内联的，因为编译器在编译时就确切知道对象是哪个类的;</li><li>当使用基类指针或引用来调用虚函数时，它都不能是内联函数，因为调用发生在运行时，是动态绑定的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;const&quot;&gt;&lt;a href=&quot;#const&quot; class=&quot;headerlink&quot; title=&quot;const&quot;&gt;&lt;/a&gt;const&lt;/h3&gt;&lt;p&gt;主要有以下作用:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修饰变量，说明该变量不可改变;&lt;/li&gt;
&lt;li&gt;修饰指针，这里分为&lt;s</summary>
      
    
    
    
    
    <category term="C++" scheme="https://wxliu925.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-计算机系统漫游</title>
    <link href="https://wxliu925.github.io/2023/10/23/CSAPP-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>https://wxliu925.github.io/2023/10/23/CSAPP-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2023-10-23T03:21:29.000Z</published>
    <updated>2023-10-26T04:40:42.617Z</updated>
    
    <content type="html"><![CDATA[<p>之前在读 xv6-book 的时候，发现自己对一些计算机底层的知识了解的太少，导致看到虚拟内存映射、物理地址这些东西的时候就很头大。在一个群友的推荐下，我决定先来看一下CSAPP的1、2、3、6、7、8、9章(当然，还有一种方案是学习CS61C)，于是有了这个系列。</p><p>gitbook: <a href="https://hansimov.gitbook.io/csapp/">https://hansimov.gitbook.io/csapp/</a></p><h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><h3 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h3><p>总线是贯穿整个系统的一组电子管道。它们携带者信息字节在各个部件之间传递，传送定长的字节块(字)。字中的字节数(字长)是一个基本的系统参数，通常是4个字节(32位)、8个字节(64位)。</p><h3 id="2-I-O-设备"><a href="#2-I-O-设备" class="headerlink" title="2.I/O 设备"></a>2.I/O 设备</h3><p>示例有作为用户输入的键盘和鼠标，作为用户输出的显示器，用于长期存储数据和程序的磁盘驱动器(磁盘)。每个 I/O 设备都通过一个<strong>控制器</strong>或者<strong>适配器</strong>与 I/O 总线相连。</p><blockquote><p>控制器和适配器之间的区别在于它们的封装方式: 控制器是 I/O 设备本身或系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。功能都是在 I/O 总线和 I/O 设备之间传递信息。</p></blockquote><h3 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h3><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组 <strong>动态随机获取存储器(DRAM)</strong> 芯片组成;从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。</p><h3 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h3><p><strong>中央处理单元(CPU)</strong>简称为处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或<strong>寄存器</strong>)，称为<strong>程序计数器(PC)</strong>。在任何时刻，PC都指向主存中的某条机器语言指令(该指令的地址)</p><p>处理器从通电到系统断电一直在不断从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令。</p><p>这样的操作围绕着主存、寄存器文件(register file)和算数/逻辑单元(ALU)进。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。</p><p>CPU在指令的要求下可能会执行如下操作:</p><ul><li><strong>加载:</strong> 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容;</li><li><strong>存储:</strong> 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容;</li><li><strong>操作:</strong> 把两个寄存器的内容复制到ALU，ALU对这两个字做算数运算，并将结果存放到一个寄存器中;</li><li><strong>跳转:</strong> 从指令本身抽取一个字，并将这个字复制到PC中，以覆盖PC中原先的值。</li></ul><h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>操作系统有两个基本功能∶ </p><ol><li>防止硬件被失控的应用程序滥用;</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ol><p>操作系统通过几个基本的抽象概念(<strong>进程、虚拟内存和文件</strong>)来实现。</p><blockquote><p>文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。</p></blockquote><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序进行的一种抽象。一个CPU在同一时间只能执行一个进程，但是可以<strong>并发运行</strong>，即一个进程的指令和另一个进程的指令是交错执行，操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>，而上下文就是操作系统保持跟踪进程运行所需的所有状态信息。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在现代操作系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>使用 xv6 里的解释</p><p>虚拟内存是每个进程都会有自己独立的 page table，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的 page table 中。</p><blockquote><p>就比如 ls 程序会有一个内存地址 0，echo 程序也会有一个内存地址 0，但是操作系统会将两个程序的内存地址0映射到不同的物理内存地址，所以ls程序不能访问echo程序的内存，同样echo程序也不能访问ls程序的内存。</p></blockquote><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件就是字节序列。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。</p><h2 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><p>从一个单独的系统来看，网络可视为一个 I/O 设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前在读 xv6-book 的时候，发现自己对一些计算机底层的知识了解的太少，导致看到虚拟内存映射、物理地址这些东西的时候就很头大。在一个群友的推荐下，我决定先来看一下CSAPP的1、2、3、6、7、8、9章(当然，还有一种方案是学习CS61C)，于是有了这个系列。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="CSAPP" scheme="https://wxliu925.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>微信Robot使用手册</title>
    <link href="https://wxliu925.github.io/2023/10/22/%E5%BE%AE%E4%BF%A1Robot%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://wxliu925.github.io/2023/10/22/%E5%BE%AE%E4%BF%A1Robot%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2023-10-22T08:08:42.000Z</published>
    <updated>2023-10-23T03:19:36.475Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>bot wechat id: liuwx_robot</p></blockquote><p>该机器人依赖于 <a href="https://github.com/zhayujie/chatgpt-on-wechat">chatgpt-on-wechat</a> 项目进行开发</p><p>主要在私聊和群聊中使用，私聊需要使用 bot 作为前缀，比如发送:”bot 你是谁？”，如果没有前缀将会被视为普通消息而不予回复。群聊直接 @ 即可。</p><h2 id="角色功能如下"><a href="#角色功能如下" class="headerlink" title="角色功能如下:"></a>角色功能如下:</h2><p>以下示例指令都使用 <code>bot</code> 为前缀，这是在私聊场景中的使用方法，在群聊中，你只需要将 <code>bot</code> 前缀更换为 @ bot 即可。</p><h3 id="1-Chatgpt3-5"><a href="#1-Chatgpt3-5" class="headerlink" title="1.Chatgpt3.5"></a>1.Chatgpt3.5</h3><p>bot 接入了 chatgpt3.5 ，可以回复你想问的任何问题，即你可以直接将该 bot 当作一个不需要挂代理的 chatgpt 使用，需要注意的是，问题回复的时间将由此时的网络代理环境和回复答案的字数而定，请耐心等待。</p><h3 id="2-语音识别"><a href="#2-语音识别" class="headerlink" title="2.语音识别"></a>2.语音识别</h3><p>bot 可以进行语音识别，你可以直接发送语音消息进行提问，bot 会对私聊和群聊中所有的语音消息进行识别并且作出回复，需要注意的是，你应该尽量使用标准的普通话。</p><h3 id="3-AI绘画"><a href="#3-AI绘画" class="headerlink" title="3.AI绘画"></a>3.AI绘画</h3><p>bot 接入了基于 LinkAI 提供的 Midjourney 绘画，提问时只需要以为 “画” 为开头即可完成绘画，比如在私聊场景下你可以发送 “bot 画一只青蛙” 来进行绘画。</p><h3 id="4-文档总结"><a href="#4-文档总结" class="headerlink" title="4.文档总结"></a>4.文档总结</h3><p>bot 接入了基于 LinkAI 提供的文档总结对话，你向机器人发送 <strong>文件</strong> 或 <strong>分享链接卡片</strong> 即可生成摘要，进一步可以与文件或链接的内容进行多轮对话。</p><blockquote><p>值得注意的是，目前 bot 仅支持 txt, docx, pdf, md, csv 格式的文件，同时文件大小不能超过 5M ，文件字数最多可支持百万字的文件。分享链接 目前仅支持 公众号文章，后续会支持更多文章类型及视频链接等。</p></blockquote><h3 id="5-角色预设"><a href="#5-角色预设" class="headerlink" title="5.角色预设"></a>5.角色预设</h3><p>bot 可以进行角色设定，具体使用方法以及可用角色设定可以使用 <code>bot $role help</code> 即可进行查看。</p><h3 id="6-冒险游戏"><a href="#6-冒险游戏" class="headerlink" title="6.冒险游戏"></a>6.冒险游戏</h3><p>使用 <code>bot $开始冒险 &lt;故事背景&gt;</code> ，如果不填写故事背景则会使用默认故事背景，bot 回复后你需要继续告诉 bot 后续发展，这样在你的引导下 bot 会慢慢完善这个完整的冒险游戏。</p><h3 id="7-管理员指令"><a href="#7-管理员指令" class="headerlink" title="7.管理员指令"></a>7.管理员指令</h3><p>可以根据 <code>@bot #help</code> 进行查看，设置管理员需要在私聊中设置，具体方法为 <code>#auth &lt;口令&gt;</code> ，口令仅有我本人知晓。</p><p>目前该机器人部署在我的个人电脑上，因此仅在开机时可以使用，后续会考虑将其部署至服务器上。</p><p>该 bot 使用日期为即日起至 bot 被腾讯风控或者本人无力继续维护时，且用且珍惜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;bot wechat id: liuwx_robot&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该机器人依赖于 &lt;a href=&quot;https://github.com/zhayujie/chatgpt-on-wechat&quot;&gt;chatgpt-on-w</summary>
      
    
    
    
    
    <category term="Robot" scheme="https://wxliu925.github.io/tags/Robot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wxliu925.github.io/2023/10/19/hello/"/>
    <id>https://wxliu925.github.io/2023/10/19/hello/</id>
    <published>2023-10-19T08:14:03.000Z</published>
    <updated>2023-10-22T14:11:39.505Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你好, 世界!</p></blockquote><p>本博客搭建于2023年10月18日，使用 github pages + hexo 进行搭建，使用 aircloud 主题，这是一个简洁轻量的 hexo 博客主题。</p><p>这是笔者第三次搭建博客，第一次也是使用 hexo 搭建的一个静态博客，可惜后来在维护过程中遇到了一些当时无法解决的问题，于是放弃。第二次是使用腾讯云服务器，基于 wordpress 框架搭建的一个动态网站，还给它取了一个响亮的名字 —— 「牛牛网」，只是可惜在使用几个月之后因为一直忙于其他事没有管理，又刚好被人注入赌博网站的暗链，导致网站被查封了。</p><p>大概快一个月前，我在知乎上发布了这样一条想法:</p><blockquote><p>“感觉简中互联网环境下很难找到一个可以随便分享东西的平台，微信朋友圈发东西需要考虑一些微信好友的感受(浏览很多知乎问题可以看出来大家对朋友发pyq的戾气)，小红书和vb环境太差，知乎里发想法没试过，但是感觉应该也不怎么好用，其实tt是一个很合适的平台，但是感觉海外的中文互联网是一个很小的圈子大部分都是中国留学生和一些出去释放压力的非正常人完全融入不进去，而且也不想发的东西完全没人看(是的，我就是这么矛盾，想让别人看又不想让别人看)”</p></blockquote><p>今天突然想到，自己搭一个网站或许是一个不错的选择，于是就有了现在的这个网站。换句话说，搭建这个网站的初衷其实不是作为一个知识分享的平台，而且作为一个个人生活分享平台，平时也许会发布一些碎碎念、一些随想随记，又或者是一些学习笔记，总而言之，这将会是一个独属于我自己的小世界，发布的内容完全随机，所以，如果某些文章内容对你造成了一些不好的影响，在此我深表歉意。</p><p>我其实是一个分享欲比较强烈的人，但是从广义上来看，人生本来就是一场孤独的旅行，所以，我总是需要写点什么东西来聊以慰藉。也希望大家都能多多记录一下自己，不为被看见，只为留下痕迹。每一个当下，每一刻的感受，都是我们活着的证据。更重要的是，每一分、每一秒都是倒计时，请务必为自己而活。</p><p>2023年10月19日，于湖北武汉记。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你好, 世界!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本博客搭建于2023年10月18日，使用 github pages + hexo 进行搭建，使用 aircloud 主题，这是一个简洁轻量的 hexo 博客主题。&lt;/p&gt;
&lt;p&gt;这是笔者第三</summary>
      
    
    
    
    
  </entry>
  
</feed>
